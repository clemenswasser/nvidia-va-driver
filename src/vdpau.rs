/* automatically generated by rust-bindgen 0.54.1 */

#![allow(warnings)]

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VDP_TRUE: u32 = 1;
pub const VDP_FALSE: u32 = 0;
pub const VDP_INVALID_HANDLE: u32 = 4294967295;
pub const VDPAU_INTERFACE_VERSION: u32 = 1;
pub const VDPAU_VERSION: u32 = 1;
pub const VDP_PROCAMP_VERSION: u32 = 0;
pub const VDP_OUTPUT_SURFACE_RENDER_BLEND_STATE_VERSION: u32 = 0;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_0: u32 = 0;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_90: u32 = 1;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_180: u32 = 2;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_270: u32 = 3;
pub const VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX: u32 = 4;
pub const VDP_DECODER_LEVEL_MPEG1_NA: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG2_LL: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG2_ML: u32 = 1;
pub const VDP_DECODER_LEVEL_MPEG2_HL14: u32 = 2;
pub const VDP_DECODER_LEVEL_MPEG2_HL: u32 = 3;
pub const VDP_DECODER_LEVEL_H264_1: u32 = 10;
pub const VDP_DECODER_LEVEL_H264_1b: u32 = 9;
pub const VDP_DECODER_LEVEL_H264_1_1: u32 = 11;
pub const VDP_DECODER_LEVEL_H264_1_2: u32 = 12;
pub const VDP_DECODER_LEVEL_H264_1_3: u32 = 13;
pub const VDP_DECODER_LEVEL_H264_2: u32 = 20;
pub const VDP_DECODER_LEVEL_H264_2_1: u32 = 21;
pub const VDP_DECODER_LEVEL_H264_2_2: u32 = 22;
pub const VDP_DECODER_LEVEL_H264_3: u32 = 30;
pub const VDP_DECODER_LEVEL_H264_3_1: u32 = 31;
pub const VDP_DECODER_LEVEL_H264_3_2: u32 = 32;
pub const VDP_DECODER_LEVEL_H264_4: u32 = 40;
pub const VDP_DECODER_LEVEL_H264_4_1: u32 = 41;
pub const VDP_DECODER_LEVEL_H264_4_2: u32 = 42;
pub const VDP_DECODER_LEVEL_H264_5: u32 = 50;
pub const VDP_DECODER_LEVEL_H264_5_1: u32 = 51;
pub const VDP_DECODER_LEVEL_VC1_SIMPLE_LOW: u32 = 0;
pub const VDP_DECODER_LEVEL_VC1_SIMPLE_MEDIUM: u32 = 1;
pub const VDP_DECODER_LEVEL_VC1_MAIN_LOW: u32 = 0;
pub const VDP_DECODER_LEVEL_VC1_MAIN_MEDIUM: u32 = 1;
pub const VDP_DECODER_LEVEL_VC1_MAIN_HIGH: u32 = 2;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L0: u32 = 0;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L2: u32 = 2;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L3: u32 = 3;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L4: u32 = 4;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L0: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L2: u32 = 2;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L3: u32 = 3;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L0: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L2: u32 = 2;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L3: u32 = 3;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L4: u32 = 4;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L5: u32 = 5;
pub const VDP_DECODER_LEVEL_DIVX_NA: u32 = 0;
pub const VDP_DECODER_LEVEL_VP9_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_HEVC_1: u32 = 30;
pub const VDP_DECODER_LEVEL_HEVC_2: u32 = 60;
pub const VDP_DECODER_LEVEL_HEVC_2_1: u32 = 63;
pub const VDP_DECODER_LEVEL_HEVC_3: u32 = 90;
pub const VDP_DECODER_LEVEL_HEVC_3_1: u32 = 93;
pub const VDP_DECODER_LEVEL_HEVC_4: u32 = 120;
pub const VDP_DECODER_LEVEL_HEVC_4_1: u32 = 123;
pub const VDP_DECODER_LEVEL_HEVC_5: u32 = 150;
pub const VDP_DECODER_LEVEL_HEVC_5_1: u32 = 153;
pub const VDP_DECODER_LEVEL_HEVC_5_2: u32 = 156;
pub const VDP_DECODER_LEVEL_HEVC_6: u32 = 180;
pub const VDP_DECODER_LEVEL_HEVC_6_1: u32 = 183;
pub const VDP_DECODER_LEVEL_HEVC_6_2: u32 = 186;
pub const VDP_BITSTREAM_BUFFER_VERSION: u32 = 0;
pub const VDP_LAYER_VERSION: u32 = 0;
pub const VDP_FUNC_ID_BASE_WINSYS: u32 = 4096;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " \\brief A boolean value, holding \\ref VDP_TRUE or \\ref"]
#[doc = " VDP_FALSE."]
pub type VdpBool = ::std::os::raw::c_int;
#[doc = " \\brief The set of all chroma formats for \\ref VdpVideoSurface"]
#[doc = " \"VdpVideoSurface\"s."]
pub type VdpChromaType = u32;
#[doc = " \\brief The set of all known YCbCr surface formats."]
pub type VdpYCbCrFormat = u32;
#[doc = " \\brief  The set of all known RGB surface formats."]
pub type VdpRGBAFormat = u32;
#[doc = " \\brief  The set of all known indexed surface formats."]
pub type VdpIndexedFormat = u32;
#[doc = " \\brief A location within a surface."]
#[doc = ""]
#[doc = " The VDPAU co-ordinate system has its origin at the top-left"]
#[doc = " of a surface, with x and y components increasing right and"]
#[doc = " down."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpPoint {
    #[doc = " X co-ordinate."]
    pub x: u32,
    #[doc = " Y co-ordinate."]
    pub y: u32,
}
#[test]
fn bindgen_test_layout_VdpPoint() {
    assert_eq!(
        ::std::mem::size_of::<VdpPoint>(),
        8usize,
        concat!("Size of: ", stringify!(VdpPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPoint),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief A rectangular region of a surface."]
#[doc = ""]
#[doc = " The co-ordinates are top-left inclusive, bottom-right"]
#[doc = " exclusive."]
#[doc = ""]
#[doc = " The VDPAU co-ordinate system has its origin at the top-left"]
#[doc = " of a surface, with x and y components increasing right and"]
#[doc = " down."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpRect {
    #[doc = " Left X co-ordinate. Inclusive."]
    pub x0: u32,
    #[doc = " Top Y co-ordinate. Inclusive."]
    pub y0: u32,
    #[doc = " Right X co-ordinate. Exclusive."]
    pub x1: u32,
    #[doc = " Bottom Y co-ordinate. Exclusive."]
    pub y1: u32,
}
#[test]
fn bindgen_test_layout_VdpRect() {
    assert_eq!(
        ::std::mem::size_of::<VdpRect>(),
        16usize,
        concat!("Size of: ", stringify!(VdpRect))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpRect>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).y0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).x1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).y1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(y1)
        )
    );
}
#[doc = " A constant RGBA color."]
#[doc = ""]
#[doc = " Note that the components are stored as float values in the"]
#[doc = " range 0.0...1.0 rather than format-specific integer values."]
#[doc = " This allows VdpColor values to be independent from the exact"]
#[doc = " surface format(s) in use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpColor {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
#[test]
fn bindgen_test_layout_VdpColor() {
    assert_eq!(
        ::std::mem::size_of::<VdpColor>(),
        16usize,
        concat!("Size of: ", stringify!(VdpColor))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpColor>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpColor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).green as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).alpha as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " The operation completed successfully; no error."]
pub const VdpStatus_VDP_STATUS_OK: VdpStatus = 0;
#[doc = " No backend implementation could be loaded."]
pub const VdpStatus_VDP_STATUS_NO_IMPLEMENTATION: VdpStatus = 1;
#[doc = " The display was preempted, or a fatal error occurred."]
#[doc = ""]
#[doc = " The application must re-initialize VDPAU."]
pub const VdpStatus_VDP_STATUS_DISPLAY_PREEMPTED: VdpStatus = 2;
#[doc = " An invalid handle value was provided."]
#[doc = ""]
#[doc = " Either the handle does not exist at all, or refers to an object of an"]
#[doc = " incorrect type."]
pub const VdpStatus_VDP_STATUS_INVALID_HANDLE: VdpStatus = 3;
#[doc = " An invalid pointer was provided."]
#[doc = ""]
#[doc = " Typically, this means that a NULL pointer was provided for an \"output\""]
#[doc = " parameter."]
pub const VdpStatus_VDP_STATUS_INVALID_POINTER: VdpStatus = 4;
#[doc = " An invalid/unsupported \\ref VdpChromaType value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_CHROMA_TYPE: VdpStatus = 5;
#[doc = " An invalid/unsupported \\ref VdpYCbCrFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_Y_CB_CR_FORMAT: VdpStatus = 6;
#[doc = " An invalid/unsupported \\ref VdpRGBAFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_RGBA_FORMAT: VdpStatus = 7;
#[doc = " An invalid/unsupported \\ref VdpIndexedFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_INDEXED_FORMAT: VdpStatus = 8;
#[doc = " An invalid/unsupported \\ref VdpColorStandard value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_COLOR_STANDARD: VdpStatus = 9;
#[doc = " An invalid/unsupported \\ref VdpColorTableFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_COLOR_TABLE_FORMAT: VdpStatus = 10;
#[doc = " An invalid/unsupported \\ref VdpOutputSurfaceRenderBlendFactor value was"]
#[doc = " supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_BLEND_FACTOR: VdpStatus = 11;
#[doc = " An invalid/unsupported \\ref VdpOutputSurfaceRenderBlendEquation value"]
#[doc = " was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_BLEND_EQUATION: VdpStatus = 12;
#[doc = " An invalid/unsupported flag value/combination was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_FLAG: VdpStatus = 13;
#[doc = " An invalid/unsupported \\ref VdpDecoderProfile value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_DECODER_PROFILE: VdpStatus = 14;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerFeature value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_FEATURE: VdpStatus = 15;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerParameter value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_PARAMETER: VdpStatus = 16;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerAttribute value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_ATTRIBUTE: VdpStatus = 17;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerPictureStructure value was"]
#[doc = " supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_PICTURE_STRUCTURE: VdpStatus = 18;
#[doc = " An invalid/unsupported \\ref VdpFuncId value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_FUNC_ID: VdpStatus = 19;
#[doc = " The size of a supplied object does not match the object it is being"]
#[doc = " used with."]
#[doc = ""]
#[doc = " For example, a \\ref VdpVideoMixer \"VdpVideoMixer\" is configured to"]
#[doc = " process \\ref VdpVideoSurface \"VdpVideoSurface\" objects of a specific"]
#[doc = " size. If presented with a \\ref VdpVideoSurface \"VdpVideoSurface\" of a"]
#[doc = " different size, this error will be raised."]
pub const VdpStatus_VDP_STATUS_INVALID_SIZE: VdpStatus = 20;
#[doc = " An invalid/unsupported value was supplied."]
#[doc = ""]
#[doc = " This is a catch-all error code for values of type other than those"]
#[doc = " with a specific error code."]
pub const VdpStatus_VDP_STATUS_INVALID_VALUE: VdpStatus = 21;
#[doc = " An invalid/unsupported structure version was specified in a versioned"]
#[doc = " structure. This implies that the implementation is older than the"]
#[doc = " header file the application was built against."]
pub const VdpStatus_VDP_STATUS_INVALID_STRUCT_VERSION: VdpStatus = 22;
#[doc = " The system does not have enough resources to complete the requested"]
#[doc = " operation at this time."]
pub const VdpStatus_VDP_STATUS_RESOURCES: VdpStatus = 23;
#[doc = " The set of handles supplied are not all related to the same VdpDevice."]
#[doc = ""]
#[doc = " When performing operations that operate on multiple surfaces, such as"]
#[doc = " \\ref  VdpOutputSurfaceRenderOutputSurface or \\ref VdpVideoMixerRender,"]
#[doc = " all supplied surfaces must have been created within the context of the"]
#[doc = " same \\ref VdpDevice \"VdpDevice\" object. This error is raised if they were"]
#[doc = " not."]
pub const VdpStatus_VDP_STATUS_HANDLE_DEVICE_MISMATCH: VdpStatus = 24;
#[doc = " A catch-all error, used when no other error code applies."]
pub const VdpStatus_VDP_STATUS_ERROR: VdpStatus = 25;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The set of all possible error codes."]
pub type VdpStatus = u32;
#[doc = " \\brief Retrieve a string describing an error code."]
#[doc = " \\param[in] status The error code."]
#[doc = " \\return A pointer to the string. Note that this is a"]
#[doc = "       statically allocated read-only string. As such, the"]
#[doc = "       application must not free the returned pointer. The"]
#[doc = "       pointer is valid as long as the VDPAU implementation is"]
#[doc = "       present within the application's address space."]
pub type VdpGetErrorString =
    ::std::option::Option<unsafe extern "C" fn(status: VdpStatus) -> *const ::std::os::raw::c_char>;
#[doc = " \\brief Retrieve the VDPAU version implemented by the backend."]
#[doc = " \\param[out] api_version The API version."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpGetApiVersion =
    ::std::option::Option<unsafe extern "C" fn(api_version: *mut u32) -> VdpStatus>;
#[doc = " \\brief Retrieve an implementation-specific string description"]
#[doc = "        of the implementation. This typically includes detailed version"]
#[doc = "        information."]
#[doc = " \\param[out] information_string A pointer to the information"]
#[doc = "       string. Note that this is a statically allocated"]
#[doc = "       read-only string. As such, the application must not"]
#[doc = "       free the returned pointer. The pointer is valid as long"]
#[doc = "       as the implementation is present within the"]
#[doc = "       application's address space."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Note that the returned string is useful for information"]
#[doc = " reporting. It is not intended that the application should"]
#[doc = " parse this string in order to determine any information about"]
#[doc = " the implementation."]
pub type VdpGetInformationString = ::std::option::Option<
    unsafe extern "C" fn(information_string: *mut *const ::std::os::raw::c_char) -> VdpStatus,
>;
#[doc = " \\brief  An opaque handle representing a VdpDevice object."]
pub type VdpDevice = u32;
#[doc = " \\brief Destroy a VdpDevice."]
#[doc = " \\param[in] device The device to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDeviceDestroy =
    ::std::option::Option<unsafe extern "C" fn(device: VdpDevice) -> VdpStatus>;
#[doc = " \\brief Storage for a color space conversion matrix."]
#[doc = ""]
#[doc = " Note that the application may choose to construct the matrix"]
#[doc = " content by either:"]
#[doc = " - Directly filling in the fields of the CSC matrix"]
#[doc = " - Using the \\ref VdpGenerateCSCMatrix helper function."]
#[doc = ""]
#[doc = " The color space conversion equation is as follows:"]
#[doc = ""]
#[doc = " \\f["]
#[doc = " \\left( \\begin{array}{c} R \\\\ G \\\\ B \\end{array} \\right)"]
#[doc = " ="]
#[doc = " \\left( \\begin{array}{cccc}"]
#[doc = " m_{0,0} & m_{0,1} & m_{0,2} & m_{0,3} \\\\"]
#[doc = " m_{1,0} & m_{1,1} & m_{1,2} & m_{1,3} \\\\"]
#[doc = " m_{2,0} & m_{2,1} & m_{2,2} & m_{2,3}"]
#[doc = " \\end{array}"]
#[doc = " \\right)"]
#[doc = " *"]
#[doc = " \\left( \\begin{array}{c} Y \\\\ Cb \\\\ Cr \\\\ 1.0 \\end{array}"]
#[doc = "      \\right)"]
#[doc = " \\f]"]
pub type VdpCSCMatrix = [[f32; 4usize]; 3usize];
#[doc = " \\brief Procamp operation parameterization data."]
#[doc = ""]
#[doc = " When performing a color space conversion operation, various"]
#[doc = " adjustments can be performed at the same time, such as"]
#[doc = " brightness and contrast. This structure defines the level of"]
#[doc = " adjustments to make."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpProcamp {
    #[doc = " This field must be filled with VDP_PROCAMP_VERSION"]
    pub struct_version: u32,
    #[doc = " Brightness adjustment amount. A value clamped between"]
    #[doc = " -1.0 and 1.0. 0.0 represents no modification."]
    pub brightness: f32,
    #[doc = " Contrast adjustment amount. A value clamped between"]
    #[doc = " 0.0 and 10.0. 1.0 represents no modification."]
    pub contrast: f32,
    #[doc = " Saturation adjustment amount. A value clamped between 0.0 and"]
    #[doc = " 10.0. 1.0 represents no modification."]
    pub saturation: f32,
    #[doc = " Hue adjustment amount. A value clamped between"]
    #[doc = " -PI and PI. 0.0 represents no modification."]
    pub hue: f32,
}
#[test]
fn bindgen_test_layout_VdpProcamp() {
    assert_eq!(
        ::std::mem::size_of::<VdpProcamp>(),
        20usize,
        concat!("Size of: ", stringify!(VdpProcamp))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpProcamp>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpProcamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).struct_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).brightness as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(brightness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).contrast as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(contrast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).saturation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(saturation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).hue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(hue)
        )
    );
}
#[doc = " \\brief YCbCr color space specification."]
#[doc = ""]
#[doc = " A number of YCbCr color spaces exist. This enumeration"]
#[doc = " defines the specifications known to VDPAU."]
pub type VdpColorStandard = u32;
#[doc = " \\brief Generate a color space conversion matrix"]
#[doc = " \\param[in] procamp The procamp adjustments to make. If NULL,"]
#[doc = "        no adjustments will be made."]
#[doc = " \\param[in] standard The YCbCr color space to convert from."]
#[doc = " \\param[out] csc_matrix The CSC matrix to initialize."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpGenerateCSCMatrix = ::std::option::Option<
    unsafe extern "C" fn(
        procamp: *mut VdpProcamp,
        standard: VdpColorStandard,
        csc_matrix: *mut VdpCSCMatrix,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpVideoSurface"]
#[doc = "        capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_chroma_type The type of chroma type for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this chroma type supported?"]
#[doc = " \\param[out] max_width The maximum supported surface width for"]
#[doc = "       this chroma type."]
#[doc = " \\param[out] max_height The maximum supported surface height"]
#[doc = "       for this chroma type."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_chroma_type: VdpChromaType,
        is_supported: *mut VdpBool,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpVideoSurface"]
#[doc = "        GetBits/PutBits capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_chroma_type The type of chroma type for"]
#[doc = "       which information is requested."]
#[doc = " \\param[in] bits_ycbcr_format The format of application \"bits\""]
#[doc = "       buffer for which information is requested."]
#[doc = " \\param[out] is_supported Is this chroma type supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceQueryGetPutBitsYCbCrCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_chroma_type: VdpChromaType,
        bits_ycbcr_format: VdpYCbCrFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpVideoSurface"]
#[doc = "        object."]
pub type VdpVideoSurface = u32;
#[doc = " \\brief Create a VdpVideoSurface."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] chroma_type The chroma type of the new surface."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[out] surface The new surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The memory backing the surface may not be initialized during"]
#[doc = " creation. Applications are expected to initialize any region"]
#[doc = " that they use, via \\ref VdpDecoderRender or \\ref"]
#[doc = " VdpVideoSurfacePutBitsYCbCr."]
#[doc = ""]
#[doc = " Note that certain widths/heights are impossible for specific values of"]
#[doc = " chroma_type. For example, the definition of VDP_CHROMA_TYPE_420 implies"]
#[doc = " that the width must be even, since each single chroma sample covers two"]
#[doc = " luma samples horizontally. A similar argument applies to surface heights,"]
#[doc = " although doubly so, since interlaced pictures must be supported; each"]
#[doc = " field's height must itself be a multiple of 2. Hence the overall surface's"]
#[doc = " height must be a multiple of 4."]
#[doc = ""]
#[doc = " Similar rules apply to other chroma_type values."]
#[doc = ""]
#[doc = " Implementations may also impose additional restrictions on the surface"]
#[doc = " sizes they support, potentially requiring additional rounding of actual"]
#[doc = " surface sizes."]
#[doc = ""]
#[doc = " In most cases, this is not an issue, since:"]
#[doc = " - Video streams are encoded as an array of macro-blocks, which typically"]
#[doc = "   have larger size alignment requirements than video surfaces do."]
#[doc = " - APIs such as \\ref VdpVideoMixerRender allow specification of a sub-region"]
#[doc = "   of the surface to read, which allows the padding data to be clipped away."]
#[doc = ""]
#[doc = " However, other APIs such as \\ref VdpVideoSurfaceGetBitsYCbCr and"]
#[doc = " \\ref VdpVideoSurfacePutBitsYCbCr do not allow a sub-region to be specified,"]
#[doc = " and always operate on surface size that was actually allocated, rather"]
#[doc = " than the surface size that was requested. In this case, applications need"]
#[doc = " to be aware of the actual surface size, in order to allocate appropriately"]
#[doc = " sized buffers for the get-/put-bits operations."]
#[doc = ""]
#[doc = " For this reason, applications may need to call"]
#[doc = " \\ref VdpVideoSurfaceGetParameters after creation, in order to retrieve the"]
#[doc = " actual surface size."]
pub type VdpVideoSurfaceCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        chroma_type: VdpChromaType,
        width: u32,
        height: u32,
        surface: *mut VdpVideoSurface,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpVideoSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceDestroy =
    ::std::option::Option<unsafe extern "C" fn(surface: VdpVideoSurface) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpVideoSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] chroma_type The chroma type of the surface."]
#[doc = " \\param[out] width The width of the surface."]
#[doc = " \\param[out] height The height of the surface."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpVideoSurface,
        chroma_type: *mut VdpChromaType,
        width: *mut u32,
        height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from a VdpVideoSurface to application"]
#[doc = "        memory in a specified YCbCr format."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] destination_ycbcr_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] destination_data Pointers to the application data"]
#[doc = "       buffers into which the image data will be written. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceGetBitsYCbCr = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpVideoSurface,
        destination_ycbcr_format: VdpYCbCrFormat,
        destination_data: *const *mut ::std::os::raw::c_void,
        destination_pitches: *const u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in a specific"]
#[doc = "        YCbCr format to a VdpVideoSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_ycbcr_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfacePutBitsYCbCr = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpVideoSurface,
        source_ycbcr_format: VdpYCbCrFormat,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief The set of all known color table formats, for use with"]
#[doc = " \\ref VdpOutputSurfacePutBitsIndexed."]
pub type VdpColorTableFormat = u32;
#[doc = " \\brief Query the implementation's VdpOutputSurface"]
#[doc = "        capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\param[out] max_width The maximum supported surface width for"]
#[doc = "       this chroma type."]
#[doc = " \\param[out] max_height The maximum supported surface height"]
#[doc = "       for this chroma type."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        is_supported: *mut VdpBool,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's capability to perform a"]
#[doc = "        PutBits operation using application data matching the"]
#[doc = "        surface's format."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryGetPutBitsNativeCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's capability to perform a"]
#[doc = "        PutBits operation using application data in a specific"]
#[doc = "        indexed format."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[in] bits_indexed_format The format of the application"]
#[doc = "       data buffer."]
#[doc = " \\param[in] color_table_format The format of the color lookup"]
#[doc = "       table."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryPutBitsIndexedCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        bits_indexed_format: VdpIndexedFormat,
        color_table_format: VdpColorTableFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's capability to perform a"]
#[doc = "        PutBits operation using application data in a specific"]
#[doc = "        YCbCr/YUB format."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for which"]
#[doc = "       information is requested."]
#[doc = " \\param[in] bits_ycbcr_format The format of the application"]
#[doc = "       data buffer."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryPutBitsYCbCrCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        bits_ycbcr_format: VdpYCbCrFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpOutputSurface"]
#[doc = "        object."]
pub type VdpOutputSurface = u32;
#[doc = " \\brief Create a VdpOutputSurface."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] rgba_format The format of the new surface."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[out] surface The new surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The memory backing the surface will be initialized to 0 color"]
#[doc = " and 0 alpha (i.e. black.)"]
pub type VdpOutputSurfaceCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        rgba_format: VdpRGBAFormat,
        width: u32,
        height: u32,
        surface: *mut VdpOutputSurface,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceDestroy =
    ::std::option::Option<unsafe extern "C" fn(surface: VdpOutputSurface) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] rgba_format The format of the surface."]
#[doc = " \\param[out] width The width of the surface."]
#[doc = " \\param[out] height The height of the surface."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        rgba_format: *mut VdpRGBAFormat,
        width: *mut u32,
        height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from a VdpOutputSurface to application"]
#[doc = "        memory in the surface's native format."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_rect The sub-rectangle of the source"]
#[doc = "       surface to copy. If NULL, the entire surface will be"]
#[doc = "       retrieved."]
#[doc = " \\param[in] destination_data Pointers to the application data"]
#[doc = "       buffers into which the image data will be written. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceGetBitsNative = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_rect: *const VdpRect,
        destination_data: *const *mut ::std::os::raw::c_void,
        destination_pitches: *const u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in the"]
#[doc = "        surface's native format to a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfacePutBitsNative = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
        destination_rect: *const VdpRect,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in a specific"]
#[doc = "        indexed format to a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_indexed_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_indexed_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_indexed_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\param[in] color_table_format The format of the color_table."]
#[doc = " \\param[in] color_table A table that maps between source index"]
#[doc = "       and target color data. See \\ref VdpColorTableFormat for"]
#[doc = "       details regarding the memory layout."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfacePutBitsIndexed = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_indexed_format: VdpIndexedFormat,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitch: *const u32,
        destination_rect: *const VdpRect,
        color_table_format: VdpColorTableFormat,
        color_table: *const ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in a specific"]
#[doc = "        YCbCr format to a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_ycbcr_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_ycbcr_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_ycbcr_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\param[in] csc_matrix The color space conversion matrix used"]
#[doc = "       by the copy operation. If NULL, a default matrix will"]
#[doc = "       be used internally. Th default matrix is equivalent to"]
#[doc = "       ITU-R BT.601 with no procamp changes."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfacePutBitsYCbCr = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_ycbcr_format: VdpYCbCrFormat,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
        destination_rect: *const VdpRect,
        csc_matrix: *const VdpCSCMatrix,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpBitmapSurface"]
#[doc = "        capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\param[out] max_width The maximum supported surface width for"]
#[doc = "       this chroma type."]
#[doc = " \\param[out] max_height The maximum supported surface height"]
#[doc = "       for this chroma type."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfaceQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        is_supported: *mut VdpBool,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpBitmapSurface"]
#[doc = "        object."]
pub type VdpBitmapSurface = u32;
#[doc = " \\brief Create a VdpBitmapSurface."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] rgba_format The format of the new surface."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[in] frequently_accessed Is this bitmap used"]
#[doc = "       frequently, or infrequently, by compositing options?"]
#[doc = "       Implementations may use this as a hint to determine how"]
#[doc = "       to allocate the underlying storage for the surface."]
#[doc = " \\param[out] surface The new surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The memory backing the surface may not be initialized"]
#[doc = " during creation. Applications are expected initialize any"]
#[doc = " region that they use, via \\ref VdpBitmapSurfacePutBitsNative."]
pub type VdpBitmapSurfaceCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        rgba_format: VdpRGBAFormat,
        width: u32,
        height: u32,
        frequently_accessed: VdpBool,
        surface: *mut VdpBitmapSurface,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpBitmapSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfaceDestroy =
    ::std::option::Option<unsafe extern "C" fn(surface: VdpBitmapSurface) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpBitmapSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] rgba_format The format of the surface."]
#[doc = " \\param[out] width The width of the surface."]
#[doc = " \\param[out] height The height of the surface."]
#[doc = " \\param[out] frequently_accessed The frequently_accessed state"]
#[doc = "       of the surface."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfaceGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpBitmapSurface,
        rgba_format: *mut VdpRGBAFormat,
        width: *mut u32,
        height: *mut u32,
        frequently_accessed: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in the"]
#[doc = "        surface's native format to a VdpBitmapSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfacePutBitsNative = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpBitmapSurface,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
        destination_rect: *const VdpRect,
    ) -> VdpStatus,
>;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ZERO:
    VdpOutputSurfaceRenderBlendFactor = 0;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE:
    VdpOutputSurfaceRenderBlendFactor = 1;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_SRC_COLOR:
    VdpOutputSurfaceRenderBlendFactor = 2;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_SRC_COLOR : VdpOutputSurfaceRenderBlendFactor = 3 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_SRC_ALPHA:
    VdpOutputSurfaceRenderBlendFactor = 4;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA : VdpOutputSurfaceRenderBlendFactor = 5 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_DST_ALPHA:
    VdpOutputSurfaceRenderBlendFactor = 6;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_DST_ALPHA : VdpOutputSurfaceRenderBlendFactor = 7 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_DST_COLOR:
    VdpOutputSurfaceRenderBlendFactor = 8;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_DST_COLOR : VdpOutputSurfaceRenderBlendFactor = 9 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_SRC_ALPHA_SATURATE : VdpOutputSurfaceRenderBlendFactor = 10 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_CONSTANT_COLOR : VdpOutputSurfaceRenderBlendFactor = 11 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR : VdpOutputSurfaceRenderBlendFactor = 12 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_CONSTANT_ALPHA : VdpOutputSurfaceRenderBlendFactor = 13 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA : VdpOutputSurfaceRenderBlendFactor = 14 ;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The blending equation factors."]
pub type VdpOutputSurfaceRenderBlendFactor = u32;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_SUBTRACT:
    VdpOutputSurfaceRenderBlendEquation = 0;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_REVERSE_SUBTRACT : VdpOutputSurfaceRenderBlendEquation = 1 ;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_ADD:
    VdpOutputSurfaceRenderBlendEquation = 2;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_MIN:
    VdpOutputSurfaceRenderBlendEquation = 3;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_MAX:
    VdpOutputSurfaceRenderBlendEquation = 4;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The blending equations."]
pub type VdpOutputSurfaceRenderBlendEquation = u32;
#[doc = " \\brief Complete blending operation definition."]
#[doc = ""]
#[doc = " A \"blend state\" operation controls the math behind certain rendering"]
#[doc = " operations."]
#[doc = ""]
#[doc = " The blend math is the familiar OpenGL blend math:"]
#[doc = "     \\f["]
#[doc = "     dst.a = equation(blendFactorDstAlpha*dst.a,"]
#[doc = "     blendFactorSrcAlpha*src.a);"]
#[doc = "     \\f]"]
#[doc = "     \\f["]
#[doc = "     dst.rgb = equation(blendFactorDstColor*dst.rgb,"]
#[doc = "     blendFactorSrcColor*src.rgb);"]
#[doc = "     \\f]"]
#[doc = ""]
#[doc = " Note that when equation is MIN or MAX, the blend factors and constants"]
#[doc = " are ignored, and are treated as if they were 1.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpOutputSurfaceRenderBlendState {
    #[doc = " This field must be filled with VDP_OUTPUT_SURFACE_RENDER_BLEND_STATE_VERSIION"]
    pub struct_version: u32,
    pub blend_factor_source_color: VdpOutputSurfaceRenderBlendFactor,
    pub blend_factor_destination_color: VdpOutputSurfaceRenderBlendFactor,
    pub blend_factor_source_alpha: VdpOutputSurfaceRenderBlendFactor,
    pub blend_factor_destination_alpha: VdpOutputSurfaceRenderBlendFactor,
    pub blend_equation_color: VdpOutputSurfaceRenderBlendEquation,
    pub blend_equation_alpha: VdpOutputSurfaceRenderBlendEquation,
    pub blend_constant: VdpColor,
}
#[test]
fn bindgen_test_layout_VdpOutputSurfaceRenderBlendState() {
    assert_eq!(
        ::std::mem::size_of::<VdpOutputSurfaceRenderBlendState>(),
        44usize,
        concat!("Size of: ", stringify!(VdpOutputSurfaceRenderBlendState))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpOutputSurfaceRenderBlendState>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VdpOutputSurfaceRenderBlendState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).struct_version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_factor_source_color
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_source_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>()))
                .blend_factor_destination_color as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_destination_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_factor_source_alpha
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_source_alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>()))
                .blend_factor_destination_alpha as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_destination_alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_equation_color
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_equation_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_equation_alpha
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_equation_alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_constant as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_constant)
        )
    );
}
#[doc = " \\brief Composite a sub-rectangle of a \\ref VdpOutputSurface"]
#[doc = "        \"VdpOutputSurface\" into a sub-rectangle of another"]
#[doc = "        \\ref VdpOutputSurface VdpOutputSurface."]
#[doc = " \\param[in] destination_surface The destination surface of the"]
#[doc = "       compositing operation."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the"]
#[doc = "       destination surface to update. If NULL, the entire"]
#[doc = "       destination surface will be updated."]
#[doc = " \\param[in] source_surface The source surface for the"]
#[doc = "       compositing operation. The surface is treated as having"]
#[doc = "       four components: red, green, blue and alpha. Any"]
#[doc = "       missing components are treated as 1.0. For example, for"]
#[doc = "       an A8 VdpOutputSurface, alpha will come from the surface"]
#[doc = "       but red, green and blue will be treated as 1.0. If"]
#[doc = "       source_surface is VDP_INVALID_HANDLE, all components will"]
#[doc = "       be treated as 1.0. Note that destination_surface and"]
#[doc = "       source_surface must have been allocated via the same"]
#[doc = "       \\ref VdpDevice \"VdpDevice\"."]
#[doc = " \\param[in] source_rect The sub-rectangle of the source"]
#[doc = "       surface to read from. If NULL, the entire"]
#[doc = "       source_surface will be read. Left/right and/or top/bottom"]
#[doc = "       co-ordinates may be swapped to flip the source. Any"]
#[doc = "       flip occurs prior to any requested rotation. Values"]
#[doc = "       from outside the source surface are valid and samples"]
#[doc = "       at those locations will be taken from the nearest edge."]
#[doc = " \\param[in] colors A pointer to an array of \\ref VdpColor"]
#[doc = "      \"VdpColor\" objects. If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is set,"]
#[doc = "      VDPAU will four entries from the array, and treat them"]
#[doc = "      as the colors corresponding to the upper-left,"]
#[doc = "      upper-right, lower-right and lower-left corners of the"]
#[doc = "      post-rotation source (i.e. indices 0, 1, 2 and 3 run"]
#[doc = "      clockwise from the upper left corner). If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is not"]
#[doc = "      set, VDPAU will use the single VdpColor for all four"]
#[doc = "      corners. If colors is NULL then red, green, blue and"]
#[doc = "      alpha values of 1.0 will be used."]
#[doc = " \\param[in] blend_state If a blend state is provided, the"]
#[doc = "     blend state will be used for the composite operation. If"]
#[doc = "     NULL, blending is effectively disabled, which is"]
#[doc = "     equivalent to a blend equation of ADD, source blend"]
#[doc = "     factors of ONE and destination blend factors of ZERO."]
#[doc = "     See \\ref VdpOutputSurfaceRenderBlendState for details"]
#[doc = "     regarding the mathematics of the blending operation."]
#[doc = " \\param[in] flags A set of flags influencing how the"]
#[doc = "       compositing operation works."]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_0"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_90"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_180"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_270"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX"]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The general compositing pipeline is as follows."]
#[doc = ""]
#[doc = " -# Extract source_rect from source_surface."]
#[doc = ""]
#[doc = " -# The extracted source is rotated 0, 90, 180 or 270 degrees"]
#[doc = "    according to the flags."]
#[doc = ""]
#[doc = " -# The rotated source is component-wise multiplied by a"]
#[doc = "    smooth-shaded quad with a (potentially) different color at"]
#[doc = "    each vertex."]
#[doc = ""]
#[doc = " -# The resulting rotated, smooth-shaded quad is scaled to the"]
#[doc = "    size of destination_rect and composited with"]
#[doc = "    destination_surface using the provided blend state."]
#[doc = ""]
pub type VdpOutputSurfaceRenderOutputSurface = ::std::option::Option<
    unsafe extern "C" fn(
        destination_surface: VdpOutputSurface,
        destination_rect: *const VdpRect,
        source_surface: VdpOutputSurface,
        source_rect: *const VdpRect,
        colors: *const VdpColor,
        blend_state: *const VdpOutputSurfaceRenderBlendState,
        flags: u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Composite a sub-rectangle of a \\ref VdpBitmapSurface"]
#[doc = "        \"VdpBitmapSurface\" into a sub-rectangle of a"]
#[doc = "        \\ref VdpOutputSurface VdpOutputSurface."]
#[doc = " \\param[in] destination_surface The destination surface of the"]
#[doc = "       compositing operation."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the"]
#[doc = "       destination surface to update. If NULL, the entire"]
#[doc = "       destination surface will be updated."]
#[doc = " \\param[in] source_surface The source surface for the"]
#[doc = "       compositing operation. The surface is treated as having"]
#[doc = "       four components: red, green, blue and alpha. Any"]
#[doc = "       missing components are treated as 1.0. For example, for"]
#[doc = "       an A8 VdpBitmapSurface, alpha will come from the surface"]
#[doc = "       but red, green and blue will be treated as 1.0. If"]
#[doc = "       source_surface is VDP_INVALID_HANDLE, all components will"]
#[doc = "       be treated as 1.0. Note that destination_surface and"]
#[doc = "       source_surface must have been allocated via the same"]
#[doc = "       \\ref VdpDevice \"VdpDevice\"."]
#[doc = " \\param[in] source_rect The sub-rectangle of the source"]
#[doc = "       surface to read from. If NULL, the entire"]
#[doc = "       source_surface will be read. Left/right ot top/bottom"]
#[doc = "       co-ordinates may be swapped to flip the source. Any"]
#[doc = "       flip occurs prior to any requested rotation. Values"]
#[doc = "       from outside the source surface are valid and samples"]
#[doc = "       at those locations will be taken from the nearest edge."]
#[doc = " \\param[in] colors A pointer to an array of \\ref VdpColor"]
#[doc = "      \"VdpColor\" objects. If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is set,"]
#[doc = "      VDPAU will four entries from the array, and treat them"]
#[doc = "      as the colors corresponding to the upper-left,"]
#[doc = "      upper-right, lower-right and lower-left corners of the"]
#[doc = "      post-rotation source (i.e. indices 0, 1, 2 and 3 run"]
#[doc = "      clockwise from the upper left corner). If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is not"]
#[doc = "      set, VDPAU will use the single VdpColor for all four"]
#[doc = "      corners. If colors is NULL then red, green, blue and"]
#[doc = "      alpha values of 1.0 will be used."]
#[doc = " \\param[in] blend_state If a blend state is provided, the"]
#[doc = "     blend state will be used for the composite operation. If"]
#[doc = "     NULL, blending is effectively disabled, which is"]
#[doc = "     equivalent to a blend equation of ADD, source blend"]
#[doc = "     factors of ONE and destination blend factors of ZERO."]
#[doc = "     See \\ref VdpOutputSurfaceRenderBlendState for details"]
#[doc = "     regarding the mathematics of the blending operation."]
#[doc = " \\param[in] flags A set of flags influencing how the"]
#[doc = "       compositing operation works."]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_0"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_90"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_180"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_270"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX"]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The general compositing pipeline is as follows."]
#[doc = ""]
#[doc = " -# Extract source_rect from source_surface."]
#[doc = ""]
#[doc = " -# The extracted source is rotated 0, 90, 180 or 270 degrees"]
#[doc = "   according to the flags."]
#[doc = ""]
#[doc = " -# The rotated source is component-wise multiplied by a"]
#[doc = "    smooth-shaded quad with a (potentially) different color at"]
#[doc = "    each vertex."]
#[doc = ""]
#[doc = " -# The resulting rotated, smooth-shaded quad is scaled to the"]
#[doc = "    size of destination_rect and composited with"]
#[doc = "    destination_surface using the provided blend state."]
#[doc = ""]
pub type VdpOutputSurfaceRenderBitmapSurface = ::std::option::Option<
    unsafe extern "C" fn(
        destination_surface: VdpOutputSurface,
        destination_rect: *const VdpRect,
        source_surface: VdpBitmapSurface,
        source_rect: *const VdpRect,
        colors: *const VdpColor,
        blend_state: *const VdpOutputSurfaceRenderBlendState,
        flags: u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief The set of all known compressed video formats, and"]
#[doc = "        associated profiles, that may be decoded."]
pub type VdpDecoderProfile = u32;
pub const VdpVideoSurfaceSupportedPictureStructure_VDP_VIDEO_SURFACE_FIELD_STRUCTURE:
    VdpVideoSurfaceSupportedPictureStructure = 1;
pub const VdpVideoSurfaceSupportedPictureStructure_VDP_VIDEO_SURFACE_FRAME_STRUCTURE:
    VdpVideoSurfaceSupportedPictureStructure = 2;
pub type VdpVideoSurfaceSupportedPictureStructure = u32;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_LEVEL: VdpDecoderCapability = 0;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_MACROBLOCKS: VdpDecoderCapability = 1;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_WIDTH: VdpDecoderCapability = 2;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_HEIGHT: VdpDecoderCapability = 3;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_SUPPORTED_PICTURE_STRUCTURE:
    VdpDecoderCapability = 4;
#[doc = " A list of supported chroma types, stored as a bitmask of 1 shifted"]
#[doc = " by each supported VdpChromaType value.  E.g.,"]
#[doc = "   (1 << VDP_CHROMA_TYPE_420) |"]
#[doc = "   (1 << VDP_CHROMA_TYPE_422) |"]
#[doc = "   (1 << VDP_CHROMA_TYPE_444)"]
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_SUPPORTED_CHROMA_TYPES: VdpDecoderCapability = 5;
pub type VdpDecoderCapability = u32;
#[doc = " \\brief Query the supported value of the requested capability, for"]
#[doc = "       the specified profile on the specified device."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] profile The decoder profile for which information is requested."]
#[doc = " \\param[in] capability The decoder profile capability for which the value"]
#[doc = "       is requested."]
#[doc = " \\param[out] capability_value The value of the requested capability."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderQueryProfileCapability = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        profile: VdpDecoderProfile,
        capability: VdpDecoderCapability,
        capability_value: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpDecoder capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] profile The decoder profile for which information is requested."]
#[doc = " \\param[out] is_supported Is this profile supported?"]
#[doc = " \\param[out] max_level The maximum specification level supported for this"]
#[doc = "       profile."]
#[doc = " \\param[out] max_macroblocks The maximum supported surface size in"]
#[doc = "       macroblocks. Note that this could be greater than that dictated by"]
#[doc = "       the maximum level."]
#[doc = " \\param[out] max_width The maximum supported surface width for this profile."]
#[doc = "       Note that this could be greater than that dictated by the maximum"]
#[doc = "       level."]
#[doc = " \\param[out] max_height The maximum supported surface height for this"]
#[doc = "       profile. Note that this could be greater than that dictated by the"]
#[doc = "       maximum level."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        profile: VdpDecoderProfile,
        is_supported: *mut VdpBool,
        max_level: *mut u32,
        max_macroblocks: *mut u32,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpDecoder object."]
pub type VdpDecoder = u32;
#[doc = " \\brief Create a VdpDecoder."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] profile The video format the decoder will decode."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[in] max_references The maximum number of references that may be"]
#[doc = "       used by a single frame in the stream to be decoded. This parameter"]
#[doc = "       exists mainly for formats such as H.264, where different streams"]
#[doc = "       may use a different number of references. Requesting too many"]
#[doc = "       references may waste memory, but decoding should still operate"]
#[doc = "       correctly. Requesting too few references will cause decoding to"]
#[doc = "       fail."]
#[doc = " \\param[out] decoder The new decoder's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        profile: VdpDecoderProfile,
        width: u32,
        height: u32,
        max_references: u32,
        decoder: *mut VdpDecoder,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpDecoder."]
#[doc = " \\param[in] surface The decoder's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderDestroy =
    ::std::option::Option<unsafe extern "C" fn(decoder: VdpDecoder) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpDecoder."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] profile The video format used to create the"]
#[doc = "       decoder."]
#[doc = " \\param[out] width The width of surfaces decode by the"]
#[doc = "       decoder."]
#[doc = " \\param[out] height The height of surfaces decode by the"]
#[doc = "       decoder"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: VdpDecoder,
        profile: *mut VdpDecoderProfile,
        width: *mut u32,
        height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Application data buffer containing compressed video"]
#[doc = "        data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpBitstreamBuffer {
    #[doc = " This field must be filled with VDP_BITSTREAM_BUFFER_VERSION"]
    pub struct_version: u32,
    #[doc = " A pointer to the bitstream data bytes"]
    pub bitstream: *const ::std::os::raw::c_void,
    #[doc = " The number of data bytes"]
    pub bitstream_bytes: u32,
}
#[test]
fn bindgen_test_layout_VdpBitstreamBuffer() {
    assert_eq!(
        ::std::mem::size_of::<VdpBitstreamBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(VdpBitstreamBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpBitstreamBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(VdpBitstreamBuffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpBitstreamBuffer>())).struct_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpBitstreamBuffer),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpBitstreamBuffer>())).bitstream as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpBitstreamBuffer),
            "::",
            stringify!(bitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpBitstreamBuffer>())).bitstream_bytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpBitstreamBuffer),
            "::",
            stringify!(bitstream_bytes)
        )
    );
}
#[doc = " \\brief A generic \"picture information\" type."]
#[doc = ""]
#[doc = " This type serves solely to document the expected usage of a"]
#[doc = " generic (void *) function parameter. In actual usage, the"]
#[doc = " application is expected to physically provide a pointer to an"]
#[doc = " instance of one of the \"real\" VdpPictureInfo* structures,"]
#[doc = " picking the type appropriate for the decoder object in"]
#[doc = " question."]
pub type VdpPictureInfo = ::std::os::raw::c_void;
#[doc = " \\brief Picture parameter information for an MPEG 1 or MPEG 2"]
#[doc = "        picture."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoMPEG1Or2 {
    #[doc = " Reference used by B and P frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub forward_reference: VdpVideoSurface,
    #[doc = " Reference used by B frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub backward_reference: VdpVideoSurface,
    #[doc = " Number of slices in the bitstream provided."]
    pub slice_count: u32,
    #[doc = " \\name MPEG bitstream"]
    #[doc = ""]
    #[doc = " Copies of the MPEG bitstream fields."]
    #[doc = " @{"]
    pub picture_structure: u8,
    pub picture_coding_type: u8,
    pub intra_dc_precision: u8,
    pub frame_pred_frame_dct: u8,
    pub concealment_motion_vectors: u8,
    pub intra_vlc_format: u8,
    pub alternate_scan: u8,
    pub q_scale_type: u8,
    pub top_field_first: u8,
    #[doc = " MPEG-1 only. For MPEG-2, set to 0."]
    pub full_pel_forward_vector: u8,
    #[doc = " MPEG-1 only. For MPEG-2, set to 0."]
    pub full_pel_backward_vector: u8,
    #[doc = " For MPEG-1, fill both horizontal and vertical entries."]
    pub f_code: [[u8; 2usize]; 2usize],
    #[doc = " Convert to raster order."]
    pub intra_quantizer_matrix: [u8; 64usize],
    #[doc = " Convert to raster order."]
    pub non_intra_quantizer_matrix: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoMPEG1Or2() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoMPEG1Or2>(),
        156usize,
        concat!("Size of: ", stringify!(VdpPictureInfoMPEG1Or2))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoMPEG1Or2>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoMPEG1Or2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).forward_reference as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(forward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).backward_reference as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(backward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).slice_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).picture_structure as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).picture_coding_type as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(picture_coding_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).intra_dc_precision as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).frame_pred_frame_dct as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(frame_pred_frame_dct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).concealment_motion_vectors
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(concealment_motion_vectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).intra_vlc_format as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(intra_vlc_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).alternate_scan as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(alternate_scan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).q_scale_type as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(q_scale_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).top_field_first as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).full_pel_forward_vector as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(full_pel_forward_vector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).full_pel_backward_vector as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(full_pel_backward_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).f_code as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(f_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).intra_quantizer_matrix as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(intra_quantizer_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).non_intra_quantizer_matrix
                as *const _ as usize
        },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(non_intra_quantizer_matrix)
        )
    );
}
impl ::std::fmt::Debug for VdpPictureInfoMPEG1Or2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "VdpPictureInfoMPEG1Or2 {{ forward_reference: {:?}, backward_reference: {:?}, slice_count: {:?}, picture_structure: {:?}, picture_coding_type: {:?}, intra_dc_precision: {:?}, frame_pred_frame_dct: {:?}, concealment_motion_vectors: {:?}, intra_vlc_format: {:?}, alternate_scan: {:?}, q_scale_type: {:?}, top_field_first: {:?}, full_pel_forward_vector: {:?}, full_pel_backward_vector: {:?}, f_code: {:?}, intra_quantizer_matrix: [{}], non_intra_quantizer_matrix: [{}] }}" , self . forward_reference , self . backward_reference , self . slice_count , self . picture_structure , self . picture_coding_type , self . intra_dc_precision , self . frame_pred_frame_dct , self . concealment_motion_vectors , self . intra_vlc_format , self . alternate_scan , self . q_scale_type , self . top_field_first , self . full_pel_forward_vector , self . full_pel_backward_vector , self . f_code , self . intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . non_intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
#[doc = " \\brief Information about an H.264 reference frame"]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpReferenceFrameH264 {
    #[doc = " The surface that contains the reference image."]
    #[doc = " Set to VDP_INVALID_HANDLE for unused entries."]
    pub surface: VdpVideoSurface,
    #[doc = " Is this a long term reference (else short term)."]
    pub is_long_term: VdpBool,
    #[doc = " Is the top field used as a reference."]
    #[doc = " Set to VDP_FALSE for unused entries."]
    pub top_is_reference: VdpBool,
    #[doc = " Is the bottom field used as a reference."]
    #[doc = " Set to VDP_FALSE for unused entries."]
    pub bottom_is_reference: VdpBool,
    #[doc = " [0]: top, [1]: bottom"]
    pub field_order_cnt: [i32; 2usize],
    #[doc = " Copy of the H.264 bitstream field:"]
    #[doc = " frame_num from slice_header for short-term references,"]
    #[doc = " LongTermPicNum from decoding algorithm for long-term references."]
    pub frame_idx: u16,
}
#[test]
fn bindgen_test_layout_VdpReferenceFrameH264() {
    assert_eq!(
        ::std::mem::size_of::<VdpReferenceFrameH264>(),
        28usize,
        concat!("Size of: ", stringify!(VdpReferenceFrameH264))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpReferenceFrameH264>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpReferenceFrameH264))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpReferenceFrameH264>())).surface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).is_long_term as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(is_long_term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).top_is_reference as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(top_is_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).bottom_is_reference as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(bottom_is_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).field_order_cnt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpReferenceFrameH264>())).frame_idx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(frame_idx)
        )
    );
}
#[doc = " \\brief Picture parameter information for an H.264 picture."]
#[doc = ""]
#[doc = " Note: The \\ref referenceFrames array must contain the \"DPB\" as"]
#[doc = " defined by the H.264 specification. In particular, once a"]
#[doc = " reference frame has been decoded to a surface, that surface must"]
#[doc = " continue to appear in the DPB until no longer required to predict"]
#[doc = " any future frame. Once a surface is removed from the DPB, it can"]
#[doc = " no longer be used as a reference, unless decoded again."]
#[doc = ""]
#[doc = " Also note that only surfaces previously generated using \\ref"]
#[doc = " VdpDecoderRender may be used as reference frames. In particular,"]
#[doc = " surfaces filled using any \"put bits\" API will not work."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[doc = ""]
#[doc = " Note: VDPAU clients must use VdpPictureInfoH264Predictive to describe the"]
#[doc = " attributes of a frame being decoded with"]
#[doc = " VDP_DECODER_PROFILE_H264_HIGH_444_PREDICTIVE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoH264 {
    #[doc = " Number of slices in the bitstream provided."]
    pub slice_count: u32,
    #[doc = " [0]: top, [1]: bottom"]
    pub field_order_cnt: [i32; 2usize],
    #[doc = " Will the decoded frame be used as a reference later."]
    pub is_reference: VdpBool,
    #[doc = " \\name H.264 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the H.264 bitstream fields."]
    #[doc = " @{"]
    pub frame_num: u16,
    pub field_pic_flag: u8,
    pub bottom_field_flag: u8,
    pub num_ref_frames: u8,
    pub mb_adaptive_frame_field_flag: u8,
    pub constrained_intra_pred_flag: u8,
    pub weighted_pred_flag: u8,
    pub weighted_bipred_idc: u8,
    pub frame_mbs_only_flag: u8,
    pub transform_8x8_mode_flag: u8,
    pub chroma_qp_index_offset: i8,
    pub second_chroma_qp_index_offset: i8,
    pub pic_init_qp_minus26: i8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub log2_max_frame_num_minus4: u8,
    pub pic_order_cnt_type: u8,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
    pub delta_pic_order_always_zero_flag: u8,
    pub direct_8x8_inference_flag: u8,
    pub entropy_coding_mode_flag: u8,
    pub pic_order_present_flag: u8,
    pub deblocking_filter_control_present_flag: u8,
    pub redundant_pic_cnt_present_flag: u8,
    #[doc = " Convert to raster order."]
    pub scaling_lists_4x4: [[u8; 16usize]; 6usize],
    #[doc = " Convert to raster order."]
    pub scaling_lists_8x8: [[u8; 64usize]; 2usize],
    #[doc = " See \\ref VdpPictureInfoH264 for instructions regarding this field."]
    pub referenceFrames: [VdpReferenceFrameH264; 16usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoH264() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoH264>(),
        716usize,
        concat!("Size of: ", stringify!(VdpPictureInfoH264))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoH264>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoH264))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoH264>())).slice_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).field_order_cnt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoH264>())).is_reference as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(is_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoH264>())).frame_num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).field_pic_flag as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(field_pic_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).bottom_field_flag as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(bottom_field_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).num_ref_frames as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(num_ref_frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).mb_adaptive_frame_field_flag as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(mb_adaptive_frame_field_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).constrained_intra_pred_flag as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(constrained_intra_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).weighted_pred_flag as *const _ as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(weighted_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).weighted_bipred_idc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(weighted_bipred_idc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).frame_mbs_only_flag as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(frame_mbs_only_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).transform_8x8_mode_flag as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(transform_8x8_mode_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).chroma_qp_index_offset as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).second_chroma_qp_index_offset as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(second_chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).pic_init_qp_minus26 as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(pic_init_qp_minus26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).num_ref_idx_l0_active_minus1 as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(num_ref_idx_l0_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).num_ref_idx_l1_active_minus1 as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(num_ref_idx_l1_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).log2_max_frame_num_minus4 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(log2_max_frame_num_minus4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).pic_order_cnt_type as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(pic_order_cnt_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).log2_max_pic_order_cnt_lsb_minus4
                as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(log2_max_pic_order_cnt_lsb_minus4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).delta_pic_order_always_zero_flag
                as *const _ as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(delta_pic_order_always_zero_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).direct_8x8_inference_flag as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(direct_8x8_inference_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).entropy_coding_mode_flag as *const _
                as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(entropy_coding_mode_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).pic_order_present_flag as *const _
                as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(pic_order_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).deblocking_filter_control_present_flag
                as *const _ as usize
        },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(deblocking_filter_control_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).redundant_pic_cnt_present_flag
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(redundant_pic_cnt_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).scaling_lists_4x4 as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(scaling_lists_4x4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).scaling_lists_8x8 as *const _ as usize
        },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(scaling_lists_8x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).referenceFrames as *const _ as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(referenceFrames)
        )
    );
}
#[doc = " \\brief Picture parameter information for an H.264 Hi444PP picture."]
#[doc = ""]
#[doc = " Note: VDPAU clients must use VdpPictureInfoH264Predictive to describe the"]
#[doc = " attributes of a frame being decoded with"]
#[doc = " VDP_DECODER_PROFILE_H264_HIGH_444_PREDICTIVE."]
#[doc = ""]
#[doc = " Note: software drivers may choose to honor values of"]
#[doc = " qpprime_y_zero_transform_bypass_flag greater than 1 for internal use."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoH264Predictive {
    #[doc = " \\ref VdpPictureInfoH264 struct."]
    pub pictureInfo: VdpPictureInfoH264,
    #[doc = " \\name H.264 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the H.264 bitstream fields."]
    #[doc = " @{ */"]
    #[doc = "  0 - lossless disabled"]
    #[doc = "  1 - lossless enabled"]
    pub qpprime_y_zero_transform_bypass_flag: u8,
    #[doc = "  0 - disabled"]
    #[doc = "  1 - enabled"]
    pub separate_colour_plane_flag: u8,
}
#[test]
fn bindgen_test_layout_VdpPictureInfoH264Predictive() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoH264Predictive>(),
        720usize,
        concat!("Size of: ", stringify!(VdpPictureInfoH264Predictive))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoH264Predictive>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoH264Predictive))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264Predictive>())).pictureInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264Predictive),
            "::",
            stringify!(pictureInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264Predictive>()))
                .qpprime_y_zero_transform_bypass_flag as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264Predictive),
            "::",
            stringify!(qpprime_y_zero_transform_bypass_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264Predictive>())).separate_colour_plane_flag
                as *const _ as usize
        },
        717usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264Predictive),
            "::",
            stringify!(separate_colour_plane_flag)
        )
    );
}
#[doc = " \\brief Picture parameter information for a VC1 picture."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpPictureInfoVC1 {
    #[doc = " Reference used by B and P frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub forward_reference: VdpVideoSurface,
    #[doc = " Reference used by B frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub backward_reference: VdpVideoSurface,
    #[doc = " Number of slices in the bitstream provided."]
    pub slice_count: u32,
    #[doc = " I=0, P=1, B=3, BI=4  from 7.1.1.4."]
    pub picture_type: u8,
    #[doc = " Progressive=0, Frame-interlace=2, Field-interlace=3; see VC-1 7.1.1.15."]
    pub frame_coding_mode: u8,
    #[doc = " \\name VC-1 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the VC-1 bitstream fields."]
    #[doc = " @{ */"]
    pub postprocflag: u8,
    #[doc = " See VC-1 6.1.8."]
    pub pulldown: u8,
    #[doc = " See VC-1 6.1.9."]
    pub interlace: u8,
    #[doc = " See VC-1 6.1.10."]
    pub tfcntrflag: u8,
    #[doc = " See VC-1 6.1.11."]
    pub finterpflag: u8,
    #[doc = " See VC-1 6.1.3."]
    pub psf: u8,
    #[doc = " See VC-1 6.2.8."]
    pub dquant: u8,
    #[doc = " See VC-1 6.2.3."]
    pub panscan_flag: u8,
    #[doc = " See VC-1 6.2.4."]
    pub refdist_flag: u8,
    #[doc = " See VC-1 6.2.11."]
    pub quantizer: u8,
    #[doc = " See VC-1 6.2.7."]
    pub extended_mv: u8,
    #[doc = " See VC-1 6.2.14."]
    pub extended_dmv: u8,
    #[doc = " See VC-1 6.2.10."]
    pub overlap: u8,
    #[doc = " See VC-1 6.2.9."]
    pub vstransform: u8,
    #[doc = " See VC-1 6.2.5."]
    pub loopfilter: u8,
    #[doc = " See VC-1 6.2.6."]
    pub fastuvmc: u8,
    #[doc = " See VC-1 6.12.15."]
    pub range_mapy_flag: u8,
    pub range_mapy: u8,
    #[doc = " See VC-1 6.2.16."]
    pub range_mapuv_flag: u8,
    pub range_mapuv: u8,
    #[doc = " See VC-1 J.1.10."]
    #[doc = " Only used by simple and main profiles."]
    pub multires: u8,
    #[doc = " See VC-1 J.1.16."]
    #[doc = " Only used by simple and main profiles."]
    pub syncmarker: u8,
    #[doc = " VC-1 SP/MP range reduction control."]
    #[doc = " Only used by simple and main profiles."]
    #[doc = " Bit 0: Copy of rangered VC-1 bitstream field; See VC-1 J.1.17."]
    #[doc = " Bit 1: Copy of rangeredfrm VC-1 bitstream fiels; See VC-1 7.1.13."]
    pub rangered: u8,
    #[doc = " See VC-1 J.1.17."]
    #[doc = " Only used by simple and main profiles."]
    pub maxbframes: u8,
    #[doc = " Out-of-loop deblocking enable."]
    #[doc = " Bit 0 of POSTPROC from VC-1 7.1.1.27"]
    #[doc = " Note that bit 1 of POSTPROC (dering enable) should not be included."]
    pub deblockEnable: u8,
    #[doc = " Parameter used by VC-1 Annex H deblocking algorithm. Note that VDPAU"]
    #[doc = " implementations may choose which deblocking algorithm to use."]
    #[doc = " See VC-1 7.1.1.6"]
    pub pquant: u8,
}
#[test]
fn bindgen_test_layout_VdpPictureInfoVC1() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoVC1>(),
        40usize,
        concat!("Size of: ", stringify!(VdpPictureInfoVC1))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoVC1>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoVC1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).forward_reference as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(forward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).backward_reference as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(backward_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).slice_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).picture_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(picture_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).frame_coding_mode as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(frame_coding_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).postprocflag as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(postprocflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).pulldown as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(pulldown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).interlace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(interlace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).tfcntrflag as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(tfcntrflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).finterpflag as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(finterpflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).psf as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(psf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).dquant as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(dquant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).panscan_flag as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(panscan_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).refdist_flag as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(refdist_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).quantizer as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(quantizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).extended_mv as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(extended_mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).extended_dmv as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(extended_dmv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).overlap as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(overlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).vstransform as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(vstransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).loopfilter as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(loopfilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).fastuvmc as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(fastuvmc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapy_flag as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapy_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapy as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapuv_flag as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapuv_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapuv as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapuv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).multires as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(multires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).syncmarker as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(syncmarker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).rangered as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(rangered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).maxbframes as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(maxbframes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).deblockEnable as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(deblockEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).pquant as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(pquant)
        )
    );
}
#[doc = " \\brief Picture parameter information for an MPEG-4 Part 2 picture."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoMPEG4Part2 {
    #[doc = " Reference used by B and P frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub forward_reference: VdpVideoSurface,
    #[doc = " Reference used by B frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub backward_reference: VdpVideoSurface,
    #[doc = " \\name MPEG 4 part 2 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the MPEG 4 part 2 bitstream fields."]
    #[doc = " @{"]
    pub trd: [i32; 2usize],
    pub trb: [i32; 2usize],
    pub vop_time_increment_resolution: u16,
    pub vop_coding_type: u8,
    pub vop_fcode_forward: u8,
    pub vop_fcode_backward: u8,
    pub resync_marker_disable: u8,
    pub interlaced: u8,
    pub quant_type: u8,
    pub quarter_sample: u8,
    pub short_video_header: u8,
    #[doc = " Derived from vop_rounding_type bitstream field."]
    pub rounding_control: u8,
    pub alternate_vertical_scan_flag: u8,
    pub top_field_first: u8,
    pub intra_quantizer_matrix: [u8; 64usize],
    pub non_intra_quantizer_matrix: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoMPEG4Part2() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoMPEG4Part2>(),
        168usize,
        concat!("Size of: ", stringify!(VdpPictureInfoMPEG4Part2))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoMPEG4Part2>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoMPEG4Part2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).forward_reference as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(forward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).backward_reference as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(backward_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).trd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(trd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).trb as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(trb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_time_increment_resolution
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_time_increment_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_coding_type as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_coding_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_fcode_forward as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_fcode_forward)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_fcode_backward as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_fcode_backward)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).resync_marker_disable as *const _
                as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(resync_marker_disable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).interlaced as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).quant_type as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(quant_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).quarter_sample as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(quarter_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).short_video_header as *const _
                as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(short_video_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).rounding_control as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(rounding_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).alternate_vertical_scan_flag
                as *const _ as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(alternate_vertical_scan_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).top_field_first as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).intra_quantizer_matrix as *const _
                as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(intra_quantizer_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).non_intra_quantizer_matrix
                as *const _ as usize
        },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(non_intra_quantizer_matrix)
        )
    );
}
impl ::std::fmt::Debug for VdpPictureInfoMPEG4Part2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "VdpPictureInfoMPEG4Part2 {{ forward_reference: {:?}, backward_reference: {:?}, trd: {:?}, trb: {:?}, vop_time_increment_resolution: {:?}, vop_coding_type: {:?}, vop_fcode_forward: {:?}, vop_fcode_backward: {:?}, resync_marker_disable: {:?}, interlaced: {:?}, quant_type: {:?}, quarter_sample: {:?}, short_video_header: {:?}, rounding_control: {:?}, alternate_vertical_scan_flag: {:?}, top_field_first: {:?}, intra_quantizer_matrix: [{}], non_intra_quantizer_matrix: [{}] }}" , self . forward_reference , self . backward_reference , self . trd , self . trb , self . vop_time_increment_resolution , self . vop_coding_type , self . vop_fcode_forward , self . vop_fcode_backward , self . resync_marker_disable , self . interlaced , self . quant_type , self . quarter_sample , self . short_video_header , self . rounding_control , self . alternate_vertical_scan_flag , self . top_field_first , self . intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . non_intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
#[doc = " \\brief Picture parameter information for a DivX 4 picture."]
#[doc = ""]
#[doc = " Due to similarites between MPEG-4 Part 2 and DivX 4, the picture"]
#[doc = " parameter structure is re-used."]
pub type VdpPictureInfoDivX4 = VdpPictureInfoMPEG4Part2;
#[doc = " \\brief Picture parameter information for a DivX 5 picture."]
#[doc = ""]
#[doc = " Due to similarites between MPEG-4 Part 2 and DivX 5, the picture"]
#[doc = " parameter structure is re-used."]
pub type VdpPictureInfoDivX5 = VdpPictureInfoMPEG4Part2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpPictureInfoVP9 {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub lastReference: VdpVideoSurface,
    pub goldenReference: VdpVideoSurface,
    pub altReference: VdpVideoSurface,
    pub colorSpace: ::std::os::raw::c_uchar,
    pub profile: ::std::os::raw::c_ushort,
    pub frameContextIdx: ::std::os::raw::c_ushort,
    pub keyFrame: ::std::os::raw::c_ushort,
    pub showFrame: ::std::os::raw::c_ushort,
    pub errorResilient: ::std::os::raw::c_ushort,
    pub frameParallelDecoding: ::std::os::raw::c_ushort,
    pub subSamplingX: ::std::os::raw::c_ushort,
    pub subSamplingY: ::std::os::raw::c_ushort,
    pub intraOnly: ::std::os::raw::c_ushort,
    pub allowHighPrecisionMv: ::std::os::raw::c_ushort,
    pub refreshEntropyProbs: ::std::os::raw::c_ushort,
    pub refFrameSignBias: [::std::os::raw::c_uchar; 4usize],
    pub bitDepthMinus8Luma: ::std::os::raw::c_uchar,
    pub bitDepthMinus8Chroma: ::std::os::raw::c_uchar,
    pub loopFilterLevel: ::std::os::raw::c_uchar,
    pub loopFilterSharpness: ::std::os::raw::c_uchar,
    pub modeRefLfEnabled: ::std::os::raw::c_uchar,
    pub log2TileColumns: ::std::os::raw::c_uchar,
    pub log2TileRows: ::std::os::raw::c_uchar,
    pub segmentEnabled: ::std::os::raw::c_uchar,
    pub segmentMapUpdate: ::std::os::raw::c_uchar,
    pub segmentMapTemporalUpdate: ::std::os::raw::c_uchar,
    pub segmentFeatureMode: ::std::os::raw::c_uchar,
    pub segmentFeatureEnable: [[::std::os::raw::c_uchar; 4usize]; 8usize],
    pub segmentFeatureData: [[::std::os::raw::c_short; 4usize]; 8usize],
    pub mbSegmentTreeProbs: [::std::os::raw::c_uchar; 7usize],
    pub segmentPredProbs: [::std::os::raw::c_uchar; 3usize],
    pub reservedSegment16Bits: [::std::os::raw::c_uchar; 2usize],
    pub qpYAc: ::std::os::raw::c_int,
    pub qpYDc: ::std::os::raw::c_int,
    pub qpChDc: ::std::os::raw::c_int,
    pub qpChAc: ::std::os::raw::c_int,
    pub activeRefIdx: [::std::os::raw::c_uint; 3usize],
    pub resetFrameContext: ::std::os::raw::c_uint,
    pub mcompFilterType: ::std::os::raw::c_uint,
    pub mbRefLfDelta: [::std::os::raw::c_uint; 4usize],
    pub mbModeLfDelta: [::std::os::raw::c_uint; 2usize],
    pub uncompressedHeaderSize: ::std::os::raw::c_uint,
    pub compressedHeaderSize: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VdpPictureInfoVP9() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoVP9>(),
        236usize,
        concat!("Size of: ", stringify!(VdpPictureInfoVP9))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoVP9>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoVP9))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).lastReference as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(lastReference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).goldenReference as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(goldenReference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).altReference as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(altReference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).colorSpace as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(colorSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).profile as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).frameContextIdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(frameContextIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).keyFrame as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(keyFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).showFrame as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(showFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).errorResilient as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(errorResilient)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).frameParallelDecoding as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(frameParallelDecoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).subSamplingX as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(subSamplingX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).subSamplingY as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(subSamplingY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).intraOnly as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(intraOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).allowHighPrecisionMv as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(allowHighPrecisionMv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).refreshEntropyProbs as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(refreshEntropyProbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).refFrameSignBias as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(refFrameSignBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).bitDepthMinus8Luma as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(bitDepthMinus8Luma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).bitDepthMinus8Chroma as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(bitDepthMinus8Chroma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).loopFilterLevel as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(loopFilterLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).loopFilterSharpness as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(loopFilterSharpness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).modeRefLfEnabled as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(modeRefLfEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).log2TileColumns as *const _ as usize
        },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(log2TileColumns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).log2TileRows as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(log2TileRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentEnabled as *const _ as usize
        },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentMapUpdate as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentMapUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentMapTemporalUpdate as *const _
                as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentMapTemporalUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentFeatureMode as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentFeatureMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentFeatureEnable as *const _ as usize
        },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentFeatureEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentFeatureData as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentFeatureData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mbSegmentTreeProbs as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mbSegmentTreeProbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentPredProbs as *const _ as usize
        },
        163usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentPredProbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).reservedSegment16Bits as *const _ as usize
        },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(reservedSegment16Bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpYAc as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpYAc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpYDc as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpYDc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpChDc as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpChDc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpChAc as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpChAc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).activeRefIdx as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(activeRefIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).resetFrameContext as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(resetFrameContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mcompFilterType as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mcompFilterType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mbRefLfDelta as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mbRefLfDelta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mbModeLfDelta as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mbModeLfDelta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).uncompressedHeaderSize as *const _
                as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(uncompressedHeaderSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).compressedHeaderSize as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(compressedHeaderSize)
        )
    );
}
#[doc = " \\brief Picture parameter information for an H.265/HEVC picture."]
#[doc = ""]
#[doc = " References to bitsream fields below may refer to data literally parsed from"]
#[doc = " the bitstream, or derived from the bitstream using a mechanism described in"]
#[doc = " Rec. ITU-T H.265 (04/2013), hereafter referred to as \"the H.265/HEVC"]
#[doc = " Specification\"."]
#[doc = ""]
#[doc = " VDPAU H.265/HEVC implementations implement the portion of the decoding"]
#[doc = " process described by clauses 8.4, 8.5, 8.6 and 8.7 of the the"]
#[doc = " H.265/HEVC Specification. VdpPictureInfoHEVC provides enough data"]
#[doc = " to complete this portion of the decoding process, plus additional"]
#[doc = " information not defined in the H.265/HEVC Specification that may be"]
#[doc = " useful to particular implementations."]
#[doc = ""]
#[doc = " Client applications must supply every field in this struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoHEVC {
    #[doc = " \\name HEVC Sequence Parameter Set"]
    #[doc = ""]
    #[doc = " Copies of the HEVC Sequence Parameter Set bitstream fields."]
    #[doc = " @{"]
    pub chroma_format_idc: u8,
    #[doc = " Only valid if chroma_format_idc == 3. Ignored otherwise."]
    pub separate_colour_plane_flag: u8,
    pub pic_width_in_luma_samples: u32,
    pub pic_height_in_luma_samples: u32,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
    #[doc = " Provides the value corresponding to the nuh_temporal_id of the frame"]
    #[doc = "to be decoded."]
    pub sps_max_dec_pic_buffering_minus1: u8,
    pub log2_min_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_luma_coding_block_size: u8,
    pub log2_min_transform_block_size_minus2: u8,
    pub log2_diff_max_min_transform_block_size: u8,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
    pub scaling_list_enabled_flag: u8,
    #[doc = " Scaling lists, in diagonal order, to be used for this frame. */"]
    #[doc = "indexed as ScalingList4x4[matrixId][i]."]
    pub ScalingList4x4: [[u8; 16usize]; 6usize],
    #[doc = " Scaling List for 8x8 quantization matrix,"]
    #[doc = "indexed as ScalingList8x8[matrixId][i]."]
    pub ScalingList8x8: [[u8; 64usize]; 6usize],
    #[doc = " Scaling List for 16x16 quantization matrix,"]
    #[doc = "indexed as ScalingList16x16[matrixId][i]."]
    pub ScalingList16x16: [[u8; 64usize]; 6usize],
    #[doc = " Scaling List for 32x32 quantization matrix,"]
    #[doc = "indexed as ScalingList32x32[matrixId][i]."]
    pub ScalingList32x32: [[u8; 64usize]; 2usize],
    #[doc = " Scaling List DC Coefficients for 16x16,"]
    #[doc = "indexed as ScalingListDCCoeff16x16[matrixId]."]
    pub ScalingListDCCoeff16x16: [u8; 6usize],
    #[doc = " Scaling List DC Coefficients for 32x32,"]
    #[doc = "indexed as ScalingListDCCoeff32x32[matrixId]."]
    pub ScalingListDCCoeff32x32: [u8; 2usize],
    pub amp_enabled_flag: u8,
    pub sample_adaptive_offset_enabled_flag: u8,
    pub pcm_enabled_flag: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub pcm_sample_bit_depth_luma_minus1: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub pcm_sample_bit_depth_chroma_minus1: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub log2_min_pcm_luma_coding_block_size_minus3: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub log2_diff_max_min_pcm_luma_coding_block_size: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub pcm_loop_filter_disabled_flag: u8,
    #[doc = " Per spec, when zero, assume short_term_ref_pic_set_sps_flag"]
    #[doc = "is also zero."]
    pub num_short_term_ref_pic_sets: u8,
    pub long_term_ref_pics_present_flag: u8,
    #[doc = " Only needed if long_term_ref_pics_present_flag is set. Ignored"]
    #[doc = "otherwise."]
    pub num_long_term_ref_pics_sps: u8,
    pub sps_temporal_mvp_enabled_flag: u8,
    pub strong_intra_smoothing_enabled_flag: u8,
    #[doc = " \\name HEVC Picture Parameter Set"]
    #[doc = ""]
    #[doc = " Copies of the HEVC Picture Parameter Set bitstream fields."]
    #[doc = " @{"]
    pub dependent_slice_segments_enabled_flag: u8,
    pub output_flag_present_flag: u8,
    pub num_extra_slice_header_bits: u8,
    pub sign_data_hiding_enabled_flag: u8,
    pub cabac_init_present_flag: u8,
    pub num_ref_idx_l0_default_active_minus1: u8,
    pub num_ref_idx_l1_default_active_minus1: u8,
    pub init_qp_minus26: i8,
    pub constrained_intra_pred_flag: u8,
    pub transform_skip_enabled_flag: u8,
    pub cu_qp_delta_enabled_flag: u8,
    #[doc = " Only needed if cu_qp_delta_enabled_flag is set. Ignored otherwise."]
    pub diff_cu_qp_delta_depth: u8,
    pub pps_cb_qp_offset: i8,
    pub pps_cr_qp_offset: i8,
    pub pps_slice_chroma_qp_offsets_present_flag: u8,
    pub weighted_pred_flag: u8,
    pub weighted_bipred_flag: u8,
    pub transquant_bypass_enabled_flag: u8,
    pub tiles_enabled_flag: u8,
    pub entropy_coding_sync_enabled_flag: u8,
    #[doc = " Only valid if tiles_enabled_flag is set. Ignored otherwise."]
    pub num_tile_columns_minus1: u8,
    #[doc = " Only valid if tiles_enabled_flag is set. Ignored otherwise."]
    pub num_tile_rows_minus1: u8,
    #[doc = " Only valid if tiles_enabled_flag is set. Ignored otherwise."]
    pub uniform_spacing_flag: u8,
    #[doc = " Only need to set 0..num_tile_columns_minus1. The struct"]
    #[doc = "definition reserves up to the maximum of 20. Invalid values are"]
    #[doc = "ignored."]
    pub column_width_minus1: [u16; 20usize],
    #[doc = " Only need to set 0..num_tile_rows_minus1. The struct"]
    #[doc = "definition reserves up to the maximum of 22. Invalid values are"]
    #[doc = "ignored."]
    pub row_height_minus1: [u16; 22usize],
    #[doc = " Only needed if tiles_enabled_flag is set. Invalid values are"]
    #[doc = "ignored."]
    pub loop_filter_across_tiles_enabled_flag: u8,
    pub pps_loop_filter_across_slices_enabled_flag: u8,
    pub deblocking_filter_control_present_flag: u8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set. Ignored"]
    #[doc = "otherwise."]
    pub deblocking_filter_override_enabled_flag: u8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set. Ignored"]
    #[doc = "otherwise."]
    pub pps_deblocking_filter_disabled_flag: u8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set and"]
    #[doc = "pps_deblocking_filter_disabled_flag is not set. Ignored otherwise."]
    pub pps_beta_offset_div2: i8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set and"]
    #[doc = "pps_deblocking_filter_disabled_flag is not set. Ignored otherwise."]
    pub pps_tc_offset_div2: i8,
    pub lists_modification_present_flag: u8,
    pub log2_parallel_merge_level_minus2: u8,
    pub slice_segment_header_extension_present_flag: u8,
    #[doc = " \\name HEVC Slice Segment Header"]
    #[doc = ""]
    #[doc = " Copies of the HEVC Slice Segment Header bitstream fields and calculated"]
    #[doc = " values detailed in the specification."]
    #[doc = " @{ */"]
    #[doc = "Set to zero otherwise."]
    pub IDRPicFlag: u8,
    #[doc = " Set to 1 if nal_unit_type in the range of BLA_W_LP to"]
    #[doc = "RSV_IRAP_VCL23, inclusive. Set to zero otherwise."]
    pub RAPPicFlag: u8,
    #[doc = " See section 7.4.7.1 of the specification."]
    pub CurrRpsIdx: u8,
    #[doc = " See section 7.4.7.2 of the specification."]
    pub NumPocTotalCurr: u32,
    #[doc = " Corresponds to specification field, NumDeltaPocs[RefRpsIdx]."]
    #[doc = "Only applicable when short_term_ref_pic_set_sps_flag == 0."]
    #[doc = "Implementations will ignore this value in other cases. See 7.4.8."]
    pub NumDeltaPocsOfRefRpsIdx: u32,
    #[doc = " Section 7.6.3.1 of the H.265/HEVC Specification defines the syntax of"]
    #[doc = "the slice_segment_header. This header contains information that"]
    #[doc = "some VDPAU implementations may choose to skip. The VDPAU API"]
    #[doc = "requires client applications to track the number of bits used in the"]
    #[doc = "slice header for structures associated with short term and long term"]
    #[doc = "reference pictures. First, VDPAU requires the number of bits used by"]
    #[doc = "the short_term_ref_pic_set array in the slice_segment_header."]
    pub NumShortTermPictureSliceHeaderBits: u32,
    #[doc = " Second, VDPAU requires the number of bits used for long term reference"]
    #[doc = "pictures in the slice_segment_header. This is equal to the number"]
    #[doc = "of bits used for the contents of the block beginning with"]
    #[doc = "\"if(long_term_ref_pics_present_flag)\"."]
    pub NumLongTermPictureSliceHeaderBits: u32,
    #[doc = " Slice Decoding Process - Picture Order Count */"]
    #[doc = "containing the SEI message. The picture being decoded."]
    pub CurrPicOrderCntVal: i32,
    #[doc = " Slice Decoding Process - Reference Picture Sets */"]
    #[doc = "Set any unused positions to VDP_INVALID_HANDLE."]
    pub RefPics: [VdpVideoSurface; 16usize],
    #[doc = " Array of picture order counts. These correspond to positions"]
    #[doc = "in the RefPics array."]
    pub PicOrderCntVal: [i32; 16usize],
    #[doc = " Array used to specify whether a particular RefPic is"]
    #[doc = "a long term reference. A value of \"1\" indicates a long-term"]
    #[doc = "reference."]
    pub IsLongTerm: [u8; 16usize],
    #[doc = " Copy of specification field, see Section 8.3.2 of the"]
    #[doc = "H.265/HEVC Specification."]
    pub NumPocStCurrBefore: u8,
    #[doc = " Copy of specification field, see Section 8.3.2 of the"]
    #[doc = "H.265/HEVC Specification."]
    pub NumPocStCurrAfter: u8,
    #[doc = " Copy of specification field, see Section 8.3.2 of the"]
    #[doc = "H.265/HEVC Specification."]
    pub NumPocLtCurr: u8,
    #[doc = " Reference Picture Set list, one of the short-term RPS. These"]
    #[doc = "correspond to positions in the RefPics array."]
    pub RefPicSetStCurrBefore: [u8; 8usize],
    #[doc = " Reference Picture Set list, one of the short-term RPS. These"]
    #[doc = "correspond to positions in the RefPics array."]
    pub RefPicSetStCurrAfter: [u8; 8usize],
    #[doc = " Reference Picture Set list, one of the long-term RPS. These"]
    #[doc = "correspond to positions in the RefPics array."]
    pub RefPicSetLtCurr: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoHEVC() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoHEVC>(),
        1352usize,
        concat!("Size of: ", stringify!(VdpPictureInfoHEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoHEVC>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoHEVC))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).chroma_format_idc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(chroma_format_idc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).separate_colour_plane_flag as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(separate_colour_plane_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pic_width_in_luma_samples as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pic_width_in_luma_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pic_height_in_luma_samples as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pic_height_in_luma_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).bit_depth_luma_minus8 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(bit_depth_luma_minus8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).bit_depth_chroma_minus8 as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(bit_depth_chroma_minus8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_max_pic_order_cnt_lsb_minus4
                as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_max_pic_order_cnt_lsb_minus4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sps_max_dec_pic_buffering_minus1
                as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sps_max_dec_pic_buffering_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_min_luma_coding_block_size_minus3
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_min_luma_coding_block_size_minus3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_diff_max_min_luma_coding_block_size
                as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_diff_max_min_luma_coding_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_min_transform_block_size_minus2
                as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_min_transform_block_size_minus2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_diff_max_min_transform_block_size
                as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_diff_max_min_transform_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).max_transform_hierarchy_depth_inter
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(max_transform_hierarchy_depth_inter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).max_transform_hierarchy_depth_intra
                as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(max_transform_hierarchy_depth_intra)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).scaling_list_enabled_flag as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(scaling_list_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList4x4 as *const _ as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList4x4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList8x8 as *const _ as usize
        },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList8x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList16x16 as *const _ as usize
        },
        503usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList16x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList32x32 as *const _ as usize
        },
        887usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList32x32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingListDCCoeff16x16 as *const _
                as usize
        },
        1015usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingListDCCoeff16x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingListDCCoeff32x32 as *const _
                as usize
        },
        1021usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingListDCCoeff32x32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).amp_enabled_flag as *const _ as usize
        },
        1023usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(amp_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sample_adaptive_offset_enabled_flag
                as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sample_adaptive_offset_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_enabled_flag as *const _ as usize
        },
        1025usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_sample_bit_depth_luma_minus1
                as *const _ as usize
        },
        1026usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_sample_bit_depth_luma_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_sample_bit_depth_chroma_minus1
                as *const _ as usize
        },
        1027usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_sample_bit_depth_chroma_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .log2_min_pcm_luma_coding_block_size_minus3 as *const _ as usize
        },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_min_pcm_luma_coding_block_size_minus3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .log2_diff_max_min_pcm_luma_coding_block_size as *const _ as usize
        },
        1029usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_diff_max_min_pcm_luma_coding_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_loop_filter_disabled_flag as *const _
                as usize
        },
        1030usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_loop_filter_disabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_short_term_ref_pic_sets as *const _
                as usize
        },
        1031usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_short_term_ref_pic_sets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).long_term_ref_pics_present_flag
                as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(long_term_ref_pics_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_long_term_ref_pics_sps as *const _
                as usize
        },
        1033usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_long_term_ref_pics_sps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sps_temporal_mvp_enabled_flag as *const _
                as usize
        },
        1034usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sps_temporal_mvp_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).strong_intra_smoothing_enabled_flag
                as *const _ as usize
        },
        1035usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(strong_intra_smoothing_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).dependent_slice_segments_enabled_flag
                as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(dependent_slice_segments_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).output_flag_present_flag as *const _
                as usize
        },
        1037usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(output_flag_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_extra_slice_header_bits as *const _
                as usize
        },
        1038usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_extra_slice_header_bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sign_data_hiding_enabled_flag as *const _
                as usize
        },
        1039usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sign_data_hiding_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).cabac_init_present_flag as *const _
                as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(cabac_init_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_ref_idx_l0_default_active_minus1
                as *const _ as usize
        },
        1041usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_ref_idx_l0_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_ref_idx_l1_default_active_minus1
                as *const _ as usize
        },
        1042usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_ref_idx_l1_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).init_qp_minus26 as *const _ as usize
        },
        1043usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(init_qp_minus26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).constrained_intra_pred_flag as *const _
                as usize
        },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(constrained_intra_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).transform_skip_enabled_flag as *const _
                as usize
        },
        1045usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(transform_skip_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).cu_qp_delta_enabled_flag as *const _
                as usize
        },
        1046usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(cu_qp_delta_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).diff_cu_qp_delta_depth as *const _
                as usize
        },
        1047usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(diff_cu_qp_delta_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_cb_qp_offset as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_cb_qp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_cr_qp_offset as *const _ as usize
        },
        1049usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_cr_qp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_slice_chroma_qp_offsets_present_flag
                as *const _ as usize
        },
        1050usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_slice_chroma_qp_offsets_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).weighted_pred_flag as *const _ as usize
        },
        1051usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(weighted_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).weighted_bipred_flag as *const _ as usize
        },
        1052usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(weighted_bipred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).transquant_bypass_enabled_flag
                as *const _ as usize
        },
        1053usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(transquant_bypass_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).tiles_enabled_flag as *const _ as usize
        },
        1054usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(tiles_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).entropy_coding_sync_enabled_flag
                as *const _ as usize
        },
        1055usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(entropy_coding_sync_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_tile_columns_minus1 as *const _
                as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_tile_columns_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_tile_rows_minus1 as *const _ as usize
        },
        1057usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_tile_rows_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).uniform_spacing_flag as *const _ as usize
        },
        1058usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(uniform_spacing_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).column_width_minus1 as *const _ as usize
        },
        1060usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(column_width_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).row_height_minus1 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(row_height_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).loop_filter_across_tiles_enabled_flag
                as *const _ as usize
        },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(loop_filter_across_tiles_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .pps_loop_filter_across_slices_enabled_flag as *const _ as usize
        },
        1145usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_loop_filter_across_slices_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).deblocking_filter_control_present_flag
                as *const _ as usize
        },
        1146usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(deblocking_filter_control_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).deblocking_filter_override_enabled_flag
                as *const _ as usize
        },
        1147usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(deblocking_filter_override_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_deblocking_filter_disabled_flag
                as *const _ as usize
        },
        1148usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_deblocking_filter_disabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_beta_offset_div2 as *const _ as usize
        },
        1149usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_beta_offset_div2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_tc_offset_div2 as *const _ as usize
        },
        1150usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_tc_offset_div2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).lists_modification_present_flag
                as *const _ as usize
        },
        1151usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(lists_modification_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_parallel_merge_level_minus2
                as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_parallel_merge_level_minus2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .slice_segment_header_extension_present_flag as *const _ as usize
        },
        1153usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(slice_segment_header_extension_present_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).IDRPicFlag as *const _ as usize },
        1154usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(IDRPicFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RAPPicFlag as *const _ as usize },
        1155usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RAPPicFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).CurrRpsIdx as *const _ as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(CurrRpsIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocTotalCurr as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocTotalCurr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumDeltaPocsOfRefRpsIdx as *const _
                as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumDeltaPocsOfRefRpsIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumShortTermPictureSliceHeaderBits
                as *const _ as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumShortTermPictureSliceHeaderBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumLongTermPictureSliceHeaderBits
                as *const _ as usize
        },
        1172usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumLongTermPictureSliceHeaderBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).CurrPicOrderCntVal as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(CurrPicOrderCntVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPics as *const _ as usize },
        1180usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).PicOrderCntVal as *const _ as usize
        },
        1244usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(PicOrderCntVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).IsLongTerm as *const _ as usize },
        1308usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(IsLongTerm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocStCurrBefore as *const _ as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocStCurrBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocStCurrAfter as *const _ as usize
        },
        1325usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocStCurrAfter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocLtCurr as *const _ as usize },
        1326usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocLtCurr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPicSetStCurrBefore as *const _
                as usize
        },
        1327usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPicSetStCurrBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPicSetStCurrAfter as *const _ as usize
        },
        1335usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPicSetStCurrAfter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPicSetLtCurr as *const _ as usize
        },
        1343usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPicSetLtCurr)
        )
    );
}
#[doc = " \\brief Picture parameter information for an HEVC 444 picture."]
#[doc = ""]
#[doc = " Note: VDPAU clients must use VdpPictureInfoHEVC444 to describe the"]
#[doc = " attributes of a frame being decoded with"]
#[doc = " VDP_DECODER_PROFILE_HEVC_MAIN_444."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoHEVC444 {
    #[doc = " \\ref VdpPictureInfoHEVC struct."]
    pub pictureInfo: VdpPictureInfoHEVC,
    pub sps_range_extension_flag: u8,
    pub transformSkipRotationEnableFlag: u8,
    pub transformSkipContextEnableFlag: u8,
    pub implicitRdpcmEnableFlag: u8,
    pub explicitRdpcmEnableFlag: u8,
    pub extendedPrecisionProcessingFlag: u8,
    pub intraSmoothingDisabledFlag: u8,
    pub highPrecisionOffsetsEnableFlag: u8,
    pub persistentRiceAdaptationEnableFlag: u8,
    pub cabacBypassAlignmentEnableFlag: u8,
    pub intraBlockCopyEnableFlag: u8,
    pub pps_range_extension_flag: u8,
    pub log2MaxTransformSkipSize: u8,
    pub crossComponentPredictionEnableFlag: u8,
    pub chromaQpAdjustmentEnableFlag: u8,
    pub diffCuChromaQpAdjustmentDepth: u8,
    pub chromaQpAdjustmentTableSize: u8,
    pub log2SaoOffsetScaleLuma: u8,
    pub log2SaoOffsetScaleChroma: u8,
    pub cb_qp_adjustment: [i8; 6usize],
    pub cr_qp_adjustment: [i8; 6usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoHEVC444() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoHEVC444>(),
        1384usize,
        concat!("Size of: ", stringify!(VdpPictureInfoHEVC444))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoHEVC444>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoHEVC444))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).pictureInfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(pictureInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).sps_range_extension_flag as *const _
                as usize
        },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(sps_range_extension_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).transformSkipRotationEnableFlag
                as *const _ as usize
        },
        1353usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(transformSkipRotationEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).transformSkipContextEnableFlag
                as *const _ as usize
        },
        1354usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(transformSkipContextEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).implicitRdpcmEnableFlag as *const _
                as usize
        },
        1355usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(implicitRdpcmEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).explicitRdpcmEnableFlag as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(explicitRdpcmEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).extendedPrecisionProcessingFlag
                as *const _ as usize
        },
        1357usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(extendedPrecisionProcessingFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).intraSmoothingDisabledFlag as *const _
                as usize
        },
        1358usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(intraSmoothingDisabledFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).highPrecisionOffsetsEnableFlag
                as *const _ as usize
        },
        1359usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(highPrecisionOffsetsEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).persistentRiceAdaptationEnableFlag
                as *const _ as usize
        },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(persistentRiceAdaptationEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).cabacBypassAlignmentEnableFlag
                as *const _ as usize
        },
        1361usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(cabacBypassAlignmentEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).intraBlockCopyEnableFlag as *const _
                as usize
        },
        1362usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(intraBlockCopyEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).pps_range_extension_flag as *const _
                as usize
        },
        1363usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(pps_range_extension_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).log2MaxTransformSkipSize as *const _
                as usize
        },
        1364usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(log2MaxTransformSkipSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).crossComponentPredictionEnableFlag
                as *const _ as usize
        },
        1365usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(crossComponentPredictionEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).chromaQpAdjustmentEnableFlag
                as *const _ as usize
        },
        1366usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(chromaQpAdjustmentEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).diffCuChromaQpAdjustmentDepth
                as *const _ as usize
        },
        1367usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(diffCuChromaQpAdjustmentDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).chromaQpAdjustmentTableSize
                as *const _ as usize
        },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(chromaQpAdjustmentTableSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).log2SaoOffsetScaleLuma as *const _
                as usize
        },
        1369usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(log2SaoOffsetScaleLuma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).log2SaoOffsetScaleChroma as *const _
                as usize
        },
        1370usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(log2SaoOffsetScaleChroma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).cb_qp_adjustment as *const _ as usize
        },
        1371usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(cb_qp_adjustment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).cr_qp_adjustment as *const _ as usize
        },
        1377usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(cr_qp_adjustment)
        )
    );
}
#[doc = " \\brief Picture parameter information for HEVC FormatRangeExtensions picture."]
#[doc = ""]
#[doc = " HEVC Main 444 Profile is part of Format Range Extensions profiles,"]
#[doc = " Due to similarities between Format Range Extensions profiles, the picture"]
#[doc = " parameter structure is re-used for Format Range Extensions profiles"]
#[doc = " supported."]
pub type VdpPictureInfoHEVCRangeExt = VdpPictureInfoHEVC444;
#[doc = " \\brief Decode a compressed field/frame and render the result"]
#[doc = "        into a \\ref VdpVideoSurface \"VdpVideoSurface\"."]
#[doc = " \\param[in] decoder The decoder object that will perform the"]
#[doc = "       decode operation."]
#[doc = " \\param[in] target The video surface to render to."]
#[doc = " \\param[in] picture_info A (pointer to a) structure containing"]
#[doc = "       information about the picture to be decoded. Note that"]
#[doc = "       the appropriate type of VdpPictureInfo* structure must"]
#[doc = "       be provided to match to profile that the decoder was"]
#[doc = "       created for."]
#[doc = " \\param[in] bitstream_buffer_count The number of bitstream"]
#[doc = "       buffers containing compressed data for this picture."]
#[doc = " \\param[in] bitstream_buffers An array of bitstream buffers."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " See \\ref video_mixer_usage for additional information."]
pub type VdpDecoderRender = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: VdpDecoder,
        target: VdpVideoSurface,
        picture_info: *const VdpPictureInfo,
        bitstream_buffer_count: u32,
        bitstream_buffers: *const VdpBitstreamBuffer,
    ) -> VdpStatus,
>;
#[doc = " \\brief A VdpVideoMixer feature that must be requested at"]
#[doc = "        creation time to be used."]
#[doc = ""]
#[doc = " Certain advanced VdpVideoMixer features are optional, and the"]
#[doc = " ability to use those features at all must be requested when"]
#[doc = " the VdpVideoMixer object is created. Each feature is named via"]
#[doc = " a specific VdpVideoMixerFeature value."]
#[doc = ""]
#[doc = " Once requested, these features are permanently available"]
#[doc = " within that specific VdpVideoMixer object. All features that"]
#[doc = " are not explicitly requested at creation time default to"]
#[doc = " being permanently unavailable."]
#[doc = ""]
#[doc = " Even when requested, all features default to being initially"]
#[doc = " disabled. However, applications can subsequently enable and"]
#[doc = " disable features at any time. See \\ref"]
#[doc = " VdpVideoMixerSetFeatureEnables."]
#[doc = ""]
#[doc = " Some features allow configuration of their operation. Each"]
#[doc = " configurable item is an \\ref VdpVideoMixerAttribute. These"]
#[doc = " attributes may be manipulated at any time using \\ref"]
#[doc = " VdpVideoMixerSetAttributeValues."]
pub type VdpVideoMixerFeature = u32;
#[doc = " \\brief A VdpVideoMixer creation parameter."]
#[doc = ""]
#[doc = " When a VdpVideoMixer is created, certain parameters may be"]
#[doc = " supplied. Each parameter is named via a specific"]
#[doc = " VdpVideoMixerParameter value."]
#[doc = ""]
#[doc = " Each parameter has a specific type, and specific default"]
#[doc = " value if not specified at VdpVideoMixer creation time. The"]
#[doc = " application may query the legal supported range for some"]
#[doc = " parameters."]
pub type VdpVideoMixerParameter = u32;
#[doc = " \\brief An adjustable attribute of VdpVideoMixer operation."]
#[doc = ""]
#[doc = " Various attributes of VdpVideoMixer operation may be adjusted"]
#[doc = " at any time. Each attribute is named via a specific"]
#[doc = " VdpVideoMixerAttribute value."]
#[doc = ""]
#[doc = " Each attribute has a specific type, and specific default"]
#[doc = " value if not specified at VdpVideoMixer creation time. The"]
#[doc = " application may query the legal supported range for some"]
#[doc = " attributes."]
pub type VdpVideoMixerAttribute = u32;
#[doc = " \\brief Query the implementation's support for a specific"]
#[doc = "        feature."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] feature The feature for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] is_supported Is the specified feature supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryFeatureSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        feature: VdpVideoMixerFeature,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's support for a specific"]
#[doc = "        parameter."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] parameter The parameter for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] is_supported Is the specified parameter"]
#[doc = "       supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryParameterSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        parameter: VdpVideoMixerParameter,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's support for a specific"]
#[doc = "        attribute."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] feature The feature for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] is_supported Is the specified feature supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryAttributeSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        attribute: VdpVideoMixerAttribute,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's supported for a specific"]
#[doc = "        parameter."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] parameter The parameter for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] min_value The minimum supported value."]
#[doc = " \\param[out] max_value The maximum supported value."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryParameterValueRange = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        parameter: VdpVideoMixerParameter,
        min_value: *mut ::std::os::raw::c_void,
        max_value: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's supported for a specific"]
#[doc = "        attribute."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] attribute The attribute for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] min_value The minimum supported value."]
#[doc = " \\param[out] max_value The maximum supported value."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryAttributeValueRange = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        attribute: VdpVideoMixerAttribute,
        min_value: *mut ::std::os::raw::c_void,
        max_value: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpVideoMixer object."]
pub type VdpVideoMixer = u32;
#[doc = " \\brief Create a VdpVideoMixer."]
#[doc = " \\param[in] device The device that will contain the mixer."]
#[doc = " \\param[in] feature_count The number of features to request."]
#[doc = " \\param[in] features The list of features to request."]
#[doc = " \\param[in] parameter_count The number of parameters to set."]
#[doc = " \\param[in] parameters The list of parameters to set."]
#[doc = " \\param[in] parameter_values The values for the parameters. Note that each"]
#[doc = "     entry in the value array is a pointer to the actual value. In other"]
#[doc = "     words, the values themselves are not cast to \"void *\" and passed"]
#[doc = "     \"inside\" the array."]
#[doc = " \\param[out] mixer The new mixer's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Initially, all requested features will be disabled. They can"]
#[doc = " be enabled using \\ref VdpVideoMixerSetFeatureEnables."]
#[doc = ""]
#[doc = " Initially, all attributes will have default values. Values"]
#[doc = " can be changed using \\ref VdpVideoMixerSetAttributeValues."]
pub type VdpVideoMixerCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        parameter_count: u32,
        parameters: *const VdpVideoMixerParameter,
        parameter_values: *const *const ::std::os::raw::c_void,
        mixer: *mut VdpVideoMixer,
    ) -> VdpStatus,
>;
#[doc = " \\brief Enable or disable features."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] feature_count The number of features to"]
#[doc = "       enable/disable."]
#[doc = " \\param[in] features The list of features to enable/disable."]
#[doc = " \\param[in] feature_enables The list of new feature enable"]
#[doc = "       values."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerSetFeatureEnables = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        feature_enables: *const VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Set attribute values"]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] attribute_count The number of attributes to set."]
#[doc = " \\param[in] attributes The list of attributes to set."]
#[doc = " \\param[in] attribute_values The values for the attributes. Note that each"]
#[doc = "     entry in the value array is a pointer to the actual value. In other"]
#[doc = "     words, the values themselves are not cast to \"void *\" and passed"]
#[doc = "     \"inside\" the array. A NULL pointer requests that the default value be"]
#[doc = "     set for that attribute."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerSetAttributeValues = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        attribute_count: u32,
        attributes: *const VdpVideoMixerAttribute,
        attribute_values: *const *const ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve whether features were requested at creation"]
#[doc = "        time."]
#[doc = " \\param[in] mixer The mixer to query."]
#[doc = " \\param[in] feature_count The number of features to query."]
#[doc = " \\param[in] features The list of features to query."]
#[doc = " \\param[out] feature_supported A list of values indicating"]
#[doc = "       whether the feature was requested, and hence is"]
#[doc = "       available."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetFeatureSupport = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        feature_supports: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve whether features are enabled."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] feature_count The number of features to query."]
#[doc = " \\param[in] features The list of features to query."]
#[doc = " \\param[out] feature_enabled A list of values indicating"]
#[doc = "       whether the feature is enabled."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetFeatureEnables = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        feature_enables: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve parameter values given at creation time."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] parameter_count The number of parameters to query."]
#[doc = " \\param[in] parameters The list of parameters to query."]
#[doc = " \\param[out] parameter_values The list of current values for"]
#[doc = "     the parameters. Note that each entry in the value array is a pointer to"]
#[doc = "     storage that will receive the actual value. If the attribute's type is"]
#[doc = "     a pointer itself, please closely read the documentation for that"]
#[doc = "     attribute type for any other data passing requirements."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetParameterValues = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        parameter_count: u32,
        parameters: *const VdpVideoMixerParameter,
        parameter_values: *const *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve current attribute values."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] attribute_count The number of attributes to query."]
#[doc = " \\param[in] attributes The list of attributes to query."]
#[doc = " \\param[out] attribute_values The list of current values for"]
#[doc = "     the attributes. Note that each entry in the value array is a pointer to"]
#[doc = "     storage that will receive the actual value. If the attribute's type is"]
#[doc = "     a pointer itself, please closely read the documentation for that"]
#[doc = "     attribute type for any other data passing requirements."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetAttributeValues = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        attribute_count: u32,
        attributes: *const VdpVideoMixerAttribute,
        attribute_values: *const *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpVideoMixer."]
#[doc = " \\param[in] device The device to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerDestroy =
    ::std::option::Option<unsafe extern "C" fn(mixer: VdpVideoMixer) -> VdpStatus>;
#[doc = " The picture is a field, and is the top field of the surface."]
pub const VdpVideoMixerPictureStructure_VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD:
    VdpVideoMixerPictureStructure = 0;
#[doc = " The picture is a field, and is the bottom field of the"]
#[doc = " surface."]
pub const VdpVideoMixerPictureStructure_VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD:
    VdpVideoMixerPictureStructure = 1;
#[doc = " The picture is a frame, and hence is the entire surface."]
pub const VdpVideoMixerPictureStructure_VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME:
    VdpVideoMixerPictureStructure = 2;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The structure of the picture present in a \\ref"]
#[doc = "        VdpVideoSurface \"VdpVideoSurface\"."]
pub type VdpVideoMixerPictureStructure = u32;
#[doc = " \\brief Definition of an additional \\ref VdpOutputSurface"]
#[doc = "        \"VdpOutputSurface\" layer in the composting model."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpLayer {
    #[doc = " This field must be filled with VDP_LAYER_VERSION"]
    pub struct_version: u32,
    #[doc = " The surface to composite from."]
    pub source_surface: VdpOutputSurface,
    #[doc = " The sub-rectangle of the source surface to use. If NULL, the"]
    #[doc = " entire source surface will be used."]
    pub source_rect: *const VdpRect,
    #[doc = " The sub-rectangle of the destination surface to map"]
    #[doc = " this layer into. This rectangle is relative to the entire"]
    #[doc = " destination surface. This rectangle will be clipped by \\ref"]
    #[doc = " VdpVideoMixerRender's \\b destination_rect. If NULL, the"]
    #[doc = " destination rectangle will be sized to match the source"]
    #[doc = " rectangle, and will be located at the origin."]
    pub destination_rect: *const VdpRect,
}
#[test]
fn bindgen_test_layout_VdpLayer() {
    assert_eq!(
        ::std::mem::size_of::<VdpLayer>(),
        24usize,
        concat!("Size of: ", stringify!(VdpLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(VdpLayer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).struct_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).source_surface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(source_surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).source_rect as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(source_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).destination_rect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(destination_rect)
        )
    );
}
#[doc = " \\brief Perform a video post-processing and compositing"]
#[doc = "        operation."]
#[doc = " \\param[in] mixer The mixer object that will perform the"]
#[doc = "       mixing/rendering operation."]
#[doc = " \\param[in] background_surface A background image. If set to any value other"]
#[doc = "       than VDP_INVALID_HANDLE, the specific surface will be used instead of"]
#[doc = "       the background color as the first layer in the mixer's compositing"]
#[doc = "       process."]
#[doc = " \\param[in] background_source_rect When background_surface is specified,"]
#[doc = "       this parameter indicates the portion of background_surface that will"]
#[doc = "       be used as the background layer. The specified region will be"]
#[doc = "       extracted and scaled to match the size of destination_rect. If NULL,"]
#[doc = "       the entire background_surface will be used."]
#[doc = " \\param[in] current_picture_structure The picture structure of"]
#[doc = "       the field/frame to be processed. This field/frame is"]
#[doc = "       presented in the \\b video_surface_current parameter. If"]
#[doc = "       frame, then all \\b video_surface_* parameters are"]
#[doc = "       assumed to be frames. If field, then all"]
#[doc = "       video_surface_* parameters are assumed to be fields,"]
#[doc = "       with alternating top/bottom-ness derived from"]
#[doc = "       video_surface_current."]
#[doc = " \\param[in] video_surfaces_past_count The number of provided"]
#[doc = "       fields/frames prior to the current picture."]
#[doc = " \\param[in] video_surfaces_past The fields/frames prior to the"]
#[doc = "       current field/frame. Note that array index 0 is the"]
#[doc = "       field/frame temporally nearest to the current"]
#[doc = "       field/frame, with increasing array indices used for"]
#[doc = "       older frames. Unavailable entries may be set to"]
#[doc = "       \\ref VDP_INVALID_HANDLE."]
#[doc = " \\param[in] video_surface_current The field/frame to be"]
#[doc = "       processed."]
#[doc = " \\param[in] video_surfaces_future_count The number of provided"]
#[doc = "       fields/frames following the current picture."]
#[doc = " \\param[in] video_surfaces_future The fields/frames that"]
#[doc = "       follow the current field/frame. Note that array index 0"]
#[doc = "       is the field/frame temporally nearest to the current"]
#[doc = "       field/frame, with increasing array indices used for"]
#[doc = "       newer frames. Unavailable entries may be set to \\ref"]
#[doc = "       VDP_INVALID_HANDLE."]
#[doc = " \\param[in] video_source_rect The sub-rectangle of the source"]
#[doc = "       video surface to extract and process. If NULL, the"]
#[doc = "       entire surface will be used. Left/right and/or top/bottom"]
#[doc = "       co-ordinates may be swapped to flip the source. Values"]
#[doc = "       from outside the video surface are valid and samples"]
#[doc = "       at those locations will be taken from the nearest edge."]
#[doc = " \\param[in] destination_surface"]
#[doc = " \\param[in] destination_rect The sub-rectangle of the"]
#[doc = "       destination surface to modify. Note that rectangle clips"]
#[doc = "       all other actions."]
#[doc = " \\param[in] destination_video_rect The sub-rectangle of the"]
#[doc = "       destination surface that will contain the processed"]
#[doc = "       video. This rectangle is relative to the entire"]
#[doc = "       destination surface. This rectangle is clipped by \\b"]
#[doc = "       destination_rect. If NULL, the destination rectangle"]
#[doc = "       will be sized to match the source rectangle, and will"]
#[doc = "       be located at the origin."]
#[doc = " \\param[in] layer_count The number of additional layers to"]
#[doc = "       composite above the video."]
#[doc = " \\param[in] layers The array of additional layers to composite"]
#[doc = "       above the video."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " For a complete discussion of how to use this API, please see"]
#[doc = " \\ref video_mixer_usage."]
pub type VdpVideoMixerRender = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        background_surface: VdpOutputSurface,
        background_source_rect: *const VdpRect,
        current_picture_structure: VdpVideoMixerPictureStructure,
        video_surface_past_count: u32,
        video_surface_past: *const VdpVideoSurface,
        video_surface_current: VdpVideoSurface,
        video_surface_future_count: u32,
        video_surface_future: *const VdpVideoSurface,
        video_source_rect: *const VdpRect,
        destination_surface: VdpOutputSurface,
        destination_rect: *const VdpRect,
        destination_video_rect: *const VdpRect,
        layer_count: u32,
        layers: *const VdpLayer,
    ) -> VdpStatus,
>;
#[doc = " \\brief The representation of a point in time."]
#[doc = ""]
#[doc = " VdpTime timestamps are intended to be a high-precision timing"]
#[doc = " system, potentially independent from any other time domain in"]
#[doc = " the system."]
#[doc = ""]
#[doc = " Time is represented in units of nanoseconds. The origin"]
#[doc = " (i.e. the time represented by a value of 0) is implementation"]
#[doc = " dependent."]
pub type VdpTime = u64;
#[doc = " \\brief An opaque handle representing the location where"]
#[doc = "        video will be presented."]
#[doc = ""]
#[doc = " VdpPresentationQueueTarget are created using a \\ref api_winsys"]
#[doc = " specific API, such as \\ref"]
#[doc = " VdpPresentationQueueTargetCreateX11."]
pub type VdpPresentationQueueTarget = u32;
#[doc = " \\brief Destroy a VdpPresentationQueueTarget."]
#[doc = " \\param[in] presentation_queue_target The target to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueTargetDestroy = ::std::option::Option<
    unsafe extern "C" fn(presentation_queue_target: VdpPresentationQueueTarget) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a presentation queue"]
#[doc = "        object."]
pub type VdpPresentationQueue = u32;
#[doc = " \\brief Create a VdpPresentationQueue."]
#[doc = " \\param[in] device The device that will contain the queue."]
#[doc = " \\param[in] presentation_queue_target The location to display"]
#[doc = "       the content."]
#[doc = " \\param[out] presentation_queue The new queue's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Note: The initial value for the background color will be set to"]
#[doc = " an implementation-defined value."]
pub type VdpPresentationQueueCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        presentation_queue_target: VdpPresentationQueueTarget,
        presentation_queue: *mut VdpPresentationQueue,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpPresentationQueue."]
#[doc = " \\param[in] presentation_queue The queue to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueDestroy = ::std::option::Option<
    unsafe extern "C" fn(presentation_queue: VdpPresentationQueue) -> VdpStatus,
>;
#[doc = " \\brief Configure the background color setting."]
#[doc = " \\param[in] presentation_queue The queue to manipulate."]
#[doc = " \\param[in] background_color The new background color."]
#[doc = ""]
#[doc = " Note: Implementations may choose whether to apply the"]
#[doc = " new background color value immediately, or defer it until"]
#[doc = " the next surface is presented."]
pub type VdpPresentationQueueSetBackgroundColor = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        background_color: *mut VdpColor,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve the current background color setting."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[out] background_color The current background color."]
pub type VdpPresentationQueueGetBackgroundColor = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        background_color: *mut VdpColor,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve the presentation queue's \"current\" time."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[out] current_time The current time, which may"]
#[doc = "       represent a point between display VSYNC events."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueGetTime = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        current_time: *mut VdpTime,
    ) -> VdpStatus,
>;
#[doc = " \\brief Enter a surface into the presentation queue."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[in] surface The surface to enter into the queue."]
#[doc = " \\param[in] clip_width If set to a non-zero value, the presentation queue"]
#[doc = "       will display only clip_width pixels of the surface (anchored to the"]
#[doc = "       top-left corner of the surface."]
#[doc = " \\param[in] clip_height If set to a non-zero value, the presentation queue"]
#[doc = "       will display only clip_height lines of the surface (anchored to the"]
#[doc = "       top-left corner of the surface."]
#[doc = " \\param[in] earliest_presentation_time The timestamp"]
#[doc = "       associated with the surface. The presentation queue"]
#[doc = "       will not display the surface until the presentation"]
#[doc = "       queue's current time is at least this value."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Applications may choose to allow resizing of the presentation queue target"]
#[doc = " (which may be e.g. a regular Window when using an X11-based"]
#[doc = " implementation)."]
#[doc = ""]
#[doc = " \\b clip_width and \\b clip_height may be used to limit the size of the"]
#[doc = " displayed region of a surface, in order to match the specific region that"]
#[doc = " was rendered to."]
#[doc = ""]
#[doc = " In turn, this allows the application to allocate over-sized (e.g."]
#[doc = " screen-sized) surfaces, but render to a region that matches the current"]
#[doc = " size of the video window."]
#[doc = ""]
#[doc = " Using this technique, an application's response to window resizing may"]
#[doc = " simply be to render to, and display, a different region of the surface,"]
#[doc = " rather than de-/re-allocation of surfaces to match the updated window size."]
#[doc = ""]
#[doc = " Implementations may impose an upper bound on the number of entries"]
#[doc = " contained by the presentation queue at a given time. This limit is likely"]
#[doc = " different to the number of \\ref VdpOutputSurface \"VdpOutputSurface\"s that"]
#[doc = " may be allocated at a given time. This limit applies to entries in the"]
#[doc = " QUEUED or VISIBLE state only. In other words, entries that have"]
#[doc = " transitioned from a QUEUED or VISIBLE state to an IDLE state do not count"]
#[doc = " toward this limit."]
pub type VdpPresentationQueueDisplay = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        surface: VdpOutputSurface,
        clip_width: u32,
        clip_height: u32,
        earliest_presentation_time: VdpTime,
    ) -> VdpStatus,
>;
#[doc = " \\brief Wait for a surface to finish being displayed."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[in] surface The surface to wait for."]
#[doc = " \\param[out] first_presentation_time The timestamp of the"]
#[doc = "       VSYNC at which this surface was first displayed. Note"]
#[doc = "       that 0 means the surface was never displayed."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Note that this API would block forever if queried about the surface most"]
#[doc = " recently added to a presentation queue. That is because there would be no"]
#[doc = " other surface that could possibly replace that surface as the currently"]
#[doc = " displayed surface, and hence that surface would never become idle. For"]
#[doc = " that reason, this function will return an error in that case."]
pub type VdpPresentationQueueBlockUntilSurfaceIdle = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        surface: VdpOutputSurface,
        first_presentation_time: *mut VdpTime,
    ) -> VdpStatus,
>;
#[doc = " The surface is not queued or currently visible."]
pub const VdpPresentationQueueStatus_VDP_PRESENTATION_QUEUE_STATUS_IDLE:
    VdpPresentationQueueStatus = 0;
#[doc = " The surface is in the queue, and not currently visible."]
pub const VdpPresentationQueueStatus_VDP_PRESENTATION_QUEUE_STATUS_QUEUED:
    VdpPresentationQueueStatus = 1;
#[doc = " The surface is the currently visible surface."]
pub const VdpPresentationQueueStatus_VDP_PRESENTATION_QUEUE_STATUS_VISIBLE:
    VdpPresentationQueueStatus = 2;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The status of a surface within a presentation queue."]
pub type VdpPresentationQueueStatus = u32;
#[doc = " \\brief Poll the current queue status of a surface."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[in] surface The surface to query."]
#[doc = " \\param[out] status The current status of the surface within"]
#[doc = "       the queue."]
#[doc = " \\param[out] first_presentation_time The timestamp of the"]
#[doc = "       VSYNC at which this surface was first displayed. Note"]
#[doc = "       that 0 means the surface was never displayed."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueQuerySurfaceStatus = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        surface: VdpOutputSurface,
        status: *mut VdpPresentationQueueStatus,
        first_presentation_time: *mut VdpTime,
    ) -> VdpStatus,
>;
#[doc = " \\brief A callback to notify the client application that a"]
#[doc = "        device's display has been preempted."]
#[doc = " \\param[in] device The device that had its display preempted."]
#[doc = " \\param[in] context The client-supplied callback context"]
#[doc = "       information."]
#[doc = " \\return void No return value"]
pub type VdpPreemptionCallback = ::std::option::Option<
    unsafe extern "C" fn(device: VdpDevice, context: *mut ::std::os::raw::c_void),
>;
#[doc = " \\brief Configure the display preemption callback."]
#[doc = " \\param[in] device The device to be monitored for preemption."]
#[doc = " \\param[in] callback The client application's callback"]
#[doc = "       function. If NULL, the callback is unregistered."]
#[doc = " \\param[in] context The client-supplied callback context"]
#[doc = "       information. This information will be passed to the"]
#[doc = "       callback function if/when invoked."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPreemptionCallbackRegister = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        callback: VdpPreemptionCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief A type suitable for \\ref VdpGetProcAddress"]
#[doc = "        \"VdpGetProcAddress\"'s \\b function_id parameter."]
pub type VdpFuncId = u32;
#[doc = " \\brief Retrieve a VDPAU function pointer."]
#[doc = " \\param[in] device The device that the function will operate"]
#[doc = "       against."]
#[doc = " \\param[in] function_id The specific function to retrieve."]
#[doc = " \\param[out] function_pointer The actual pointer for the"]
#[doc = "       application to call."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpGetProcAddress = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        function_id: VdpFuncId,
        function_pointer: *mut *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
