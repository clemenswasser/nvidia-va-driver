/* automatically generated by rust-bindgen 0.54.1 */

#![allow(warnings)]

pub const XlibSpecificationRelease: u32 = 6;
pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const None: u32 = 0;
pub const ParentRelative: u32 = 1;
pub const CopyFromParent: u32 = 0;
pub const PointerWindow: u32 = 0;
pub const InputFocus: u32 = 1;
pub const PointerRoot: u32 = 1;
pub const AnyPropertyType: u32 = 0;
pub const AnyKey: u32 = 0;
pub const AnyButton: u32 = 0;
pub const AllTemporary: u32 = 0;
pub const CurrentTime: u32 = 0;
pub const NoSymbol: u32 = 0;
pub const NoEventMask: u32 = 0;
pub const KeyPressMask: u32 = 1;
pub const KeyReleaseMask: u32 = 2;
pub const ButtonPressMask: u32 = 4;
pub const ButtonReleaseMask: u32 = 8;
pub const EnterWindowMask: u32 = 16;
pub const LeaveWindowMask: u32 = 32;
pub const PointerMotionMask: u32 = 64;
pub const PointerMotionHintMask: u32 = 128;
pub const Button1MotionMask: u32 = 256;
pub const Button2MotionMask: u32 = 512;
pub const Button3MotionMask: u32 = 1024;
pub const Button4MotionMask: u32 = 2048;
pub const Button5MotionMask: u32 = 4096;
pub const ButtonMotionMask: u32 = 8192;
pub const KeymapStateMask: u32 = 16384;
pub const ExposureMask: u32 = 32768;
pub const VisibilityChangeMask: u32 = 65536;
pub const StructureNotifyMask: u32 = 131072;
pub const ResizeRedirectMask: u32 = 262144;
pub const SubstructureNotifyMask: u32 = 524288;
pub const SubstructureRedirectMask: u32 = 1048576;
pub const FocusChangeMask: u32 = 2097152;
pub const PropertyChangeMask: u32 = 4194304;
pub const ColormapChangeMask: u32 = 8388608;
pub const OwnerGrabButtonMask: u32 = 16777216;
pub const KeyPress: u32 = 2;
pub const KeyRelease: u32 = 3;
pub const ButtonPress: u32 = 4;
pub const ButtonRelease: u32 = 5;
pub const MotionNotify: u32 = 6;
pub const EnterNotify: u32 = 7;
pub const LeaveNotify: u32 = 8;
pub const FocusIn: u32 = 9;
pub const FocusOut: u32 = 10;
pub const KeymapNotify: u32 = 11;
pub const Expose: u32 = 12;
pub const GraphicsExpose: u32 = 13;
pub const NoExpose: u32 = 14;
pub const VisibilityNotify: u32 = 15;
pub const CreateNotify: u32 = 16;
pub const DestroyNotify: u32 = 17;
pub const UnmapNotify: u32 = 18;
pub const MapNotify: u32 = 19;
pub const MapRequest: u32 = 20;
pub const ReparentNotify: u32 = 21;
pub const ConfigureNotify: u32 = 22;
pub const ConfigureRequest: u32 = 23;
pub const GravityNotify: u32 = 24;
pub const ResizeRequest: u32 = 25;
pub const CirculateNotify: u32 = 26;
pub const CirculateRequest: u32 = 27;
pub const PropertyNotify: u32 = 28;
pub const SelectionClear: u32 = 29;
pub const SelectionRequest: u32 = 30;
pub const SelectionNotify: u32 = 31;
pub const ColormapNotify: u32 = 32;
pub const ClientMessage: u32 = 33;
pub const MappingNotify: u32 = 34;
pub const GenericEvent: u32 = 35;
pub const LASTEvent: u32 = 36;
pub const ShiftMask: u32 = 1;
pub const LockMask: u32 = 2;
pub const ControlMask: u32 = 4;
pub const Mod1Mask: u32 = 8;
pub const Mod2Mask: u32 = 16;
pub const Mod3Mask: u32 = 32;
pub const Mod4Mask: u32 = 64;
pub const Mod5Mask: u32 = 128;
pub const ShiftMapIndex: u32 = 0;
pub const LockMapIndex: u32 = 1;
pub const ControlMapIndex: u32 = 2;
pub const Mod1MapIndex: u32 = 3;
pub const Mod2MapIndex: u32 = 4;
pub const Mod3MapIndex: u32 = 5;
pub const Mod4MapIndex: u32 = 6;
pub const Mod5MapIndex: u32 = 7;
pub const Button1Mask: u32 = 256;
pub const Button2Mask: u32 = 512;
pub const Button3Mask: u32 = 1024;
pub const Button4Mask: u32 = 2048;
pub const Button5Mask: u32 = 4096;
pub const AnyModifier: u32 = 32768;
pub const Button1: u32 = 1;
pub const Button2: u32 = 2;
pub const Button3: u32 = 3;
pub const Button4: u32 = 4;
pub const Button5: u32 = 5;
pub const NotifyNormal: u32 = 0;
pub const NotifyGrab: u32 = 1;
pub const NotifyUngrab: u32 = 2;
pub const NotifyWhileGrabbed: u32 = 3;
pub const NotifyHint: u32 = 1;
pub const NotifyAncestor: u32 = 0;
pub const NotifyVirtual: u32 = 1;
pub const NotifyInferior: u32 = 2;
pub const NotifyNonlinear: u32 = 3;
pub const NotifyNonlinearVirtual: u32 = 4;
pub const NotifyPointer: u32 = 5;
pub const NotifyPointerRoot: u32 = 6;
pub const NotifyDetailNone: u32 = 7;
pub const VisibilityUnobscured: u32 = 0;
pub const VisibilityPartiallyObscured: u32 = 1;
pub const VisibilityFullyObscured: u32 = 2;
pub const PlaceOnTop: u32 = 0;
pub const PlaceOnBottom: u32 = 1;
pub const FamilyInternet: u32 = 0;
pub const FamilyDECnet: u32 = 1;
pub const FamilyChaos: u32 = 2;
pub const FamilyInternet6: u32 = 6;
pub const FamilyServerInterpreted: u32 = 5;
pub const PropertyNewValue: u32 = 0;
pub const PropertyDelete: u32 = 1;
pub const ColormapUninstalled: u32 = 0;
pub const ColormapInstalled: u32 = 1;
pub const GrabModeSync: u32 = 0;
pub const GrabModeAsync: u32 = 1;
pub const GrabSuccess: u32 = 0;
pub const AlreadyGrabbed: u32 = 1;
pub const GrabInvalidTime: u32 = 2;
pub const GrabNotViewable: u32 = 3;
pub const GrabFrozen: u32 = 4;
pub const AsyncPointer: u32 = 0;
pub const SyncPointer: u32 = 1;
pub const ReplayPointer: u32 = 2;
pub const AsyncKeyboard: u32 = 3;
pub const SyncKeyboard: u32 = 4;
pub const ReplayKeyboard: u32 = 5;
pub const AsyncBoth: u32 = 6;
pub const SyncBoth: u32 = 7;
pub const RevertToParent: u32 = 2;
pub const Success: u32 = 0;
pub const BadRequest: u32 = 1;
pub const BadValue: u32 = 2;
pub const BadWindow: u32 = 3;
pub const BadPixmap: u32 = 4;
pub const BadAtom: u32 = 5;
pub const BadCursor: u32 = 6;
pub const BadFont: u32 = 7;
pub const BadMatch: u32 = 8;
pub const BadDrawable: u32 = 9;
pub const BadAccess: u32 = 10;
pub const BadAlloc: u32 = 11;
pub const BadColor: u32 = 12;
pub const BadGC: u32 = 13;
pub const BadIDChoice: u32 = 14;
pub const BadName: u32 = 15;
pub const BadLength: u32 = 16;
pub const BadImplementation: u32 = 17;
pub const FirstExtensionError: u32 = 128;
pub const LastExtensionError: u32 = 255;
pub const InputOutput: u32 = 1;
pub const InputOnly: u32 = 2;
pub const CWBackPixmap: u32 = 1;
pub const CWBackPixel: u32 = 2;
pub const CWBorderPixmap: u32 = 4;
pub const CWBorderPixel: u32 = 8;
pub const CWBitGravity: u32 = 16;
pub const CWWinGravity: u32 = 32;
pub const CWBackingStore: u32 = 64;
pub const CWBackingPlanes: u32 = 128;
pub const CWBackingPixel: u32 = 256;
pub const CWOverrideRedirect: u32 = 512;
pub const CWSaveUnder: u32 = 1024;
pub const CWEventMask: u32 = 2048;
pub const CWDontPropagate: u32 = 4096;
pub const CWColormap: u32 = 8192;
pub const CWCursor: u32 = 16384;
pub const CWX: u32 = 1;
pub const CWY: u32 = 2;
pub const CWWidth: u32 = 4;
pub const CWHeight: u32 = 8;
pub const CWBorderWidth: u32 = 16;
pub const CWSibling: u32 = 32;
pub const CWStackMode: u32 = 64;
pub const ForgetGravity: u32 = 0;
pub const NorthWestGravity: u32 = 1;
pub const NorthGravity: u32 = 2;
pub const NorthEastGravity: u32 = 3;
pub const WestGravity: u32 = 4;
pub const CenterGravity: u32 = 5;
pub const EastGravity: u32 = 6;
pub const SouthWestGravity: u32 = 7;
pub const SouthGravity: u32 = 8;
pub const SouthEastGravity: u32 = 9;
pub const StaticGravity: u32 = 10;
pub const UnmapGravity: u32 = 0;
pub const NotUseful: u32 = 0;
pub const WhenMapped: u32 = 1;
pub const Always: u32 = 2;
pub const IsUnmapped: u32 = 0;
pub const IsUnviewable: u32 = 1;
pub const IsViewable: u32 = 2;
pub const SetModeInsert: u32 = 0;
pub const SetModeDelete: u32 = 1;
pub const DestroyAll: u32 = 0;
pub const RetainPermanent: u32 = 1;
pub const RetainTemporary: u32 = 2;
pub const Above: u32 = 0;
pub const Below: u32 = 1;
pub const TopIf: u32 = 2;
pub const BottomIf: u32 = 3;
pub const Opposite: u32 = 4;
pub const RaiseLowest: u32 = 0;
pub const LowerHighest: u32 = 1;
pub const PropModeReplace: u32 = 0;
pub const PropModePrepend: u32 = 1;
pub const PropModeAppend: u32 = 2;
pub const GXclear: u32 = 0;
pub const GXand: u32 = 1;
pub const GXandReverse: u32 = 2;
pub const GXcopy: u32 = 3;
pub const GXandInverted: u32 = 4;
pub const GXnoop: u32 = 5;
pub const GXxor: u32 = 6;
pub const GXor: u32 = 7;
pub const GXnor: u32 = 8;
pub const GXequiv: u32 = 9;
pub const GXinvert: u32 = 10;
pub const GXorReverse: u32 = 11;
pub const GXcopyInverted: u32 = 12;
pub const GXorInverted: u32 = 13;
pub const GXnand: u32 = 14;
pub const GXset: u32 = 15;
pub const LineSolid: u32 = 0;
pub const LineOnOffDash: u32 = 1;
pub const LineDoubleDash: u32 = 2;
pub const CapNotLast: u32 = 0;
pub const CapButt: u32 = 1;
pub const CapRound: u32 = 2;
pub const CapProjecting: u32 = 3;
pub const JoinMiter: u32 = 0;
pub const JoinRound: u32 = 1;
pub const JoinBevel: u32 = 2;
pub const FillSolid: u32 = 0;
pub const FillTiled: u32 = 1;
pub const FillStippled: u32 = 2;
pub const FillOpaqueStippled: u32 = 3;
pub const EvenOddRule: u32 = 0;
pub const WindingRule: u32 = 1;
pub const ClipByChildren: u32 = 0;
pub const IncludeInferiors: u32 = 1;
pub const Unsorted: u32 = 0;
pub const YSorted: u32 = 1;
pub const YXSorted: u32 = 2;
pub const YXBanded: u32 = 3;
pub const CoordModeOrigin: u32 = 0;
pub const CoordModePrevious: u32 = 1;
pub const Complex: u32 = 0;
pub const Nonconvex: u32 = 1;
pub const Convex: u32 = 2;
pub const ArcChord: u32 = 0;
pub const ArcPieSlice: u32 = 1;
pub const GCFunction: u32 = 1;
pub const GCPlaneMask: u32 = 2;
pub const GCForeground: u32 = 4;
pub const GCBackground: u32 = 8;
pub const GCLineWidth: u32 = 16;
pub const GCLineStyle: u32 = 32;
pub const GCCapStyle: u32 = 64;
pub const GCJoinStyle: u32 = 128;
pub const GCFillStyle: u32 = 256;
pub const GCFillRule: u32 = 512;
pub const GCTile: u32 = 1024;
pub const GCStipple: u32 = 2048;
pub const GCTileStipXOrigin: u32 = 4096;
pub const GCTileStipYOrigin: u32 = 8192;
pub const GCFont: u32 = 16384;
pub const GCSubwindowMode: u32 = 32768;
pub const GCGraphicsExposures: u32 = 65536;
pub const GCClipXOrigin: u32 = 131072;
pub const GCClipYOrigin: u32 = 262144;
pub const GCClipMask: u32 = 524288;
pub const GCDashOffset: u32 = 1048576;
pub const GCDashList: u32 = 2097152;
pub const GCArcMode: u32 = 4194304;
pub const GCLastBit: u32 = 22;
pub const FontLeftToRight: u32 = 0;
pub const FontRightToLeft: u32 = 1;
pub const FontChange: u32 = 255;
pub const XYBitmap: u32 = 0;
pub const XYPixmap: u32 = 1;
pub const ZPixmap: u32 = 2;
pub const AllocNone: u32 = 0;
pub const AllocAll: u32 = 1;
pub const DoRed: u32 = 1;
pub const DoGreen: u32 = 2;
pub const DoBlue: u32 = 4;
pub const CursorShape: u32 = 0;
pub const TileShape: u32 = 1;
pub const StippleShape: u32 = 2;
pub const AutoRepeatModeOff: u32 = 0;
pub const AutoRepeatModeOn: u32 = 1;
pub const AutoRepeatModeDefault: u32 = 2;
pub const LedModeOff: u32 = 0;
pub const LedModeOn: u32 = 1;
pub const KBKeyClickPercent: u32 = 1;
pub const KBBellPercent: u32 = 2;
pub const KBBellPitch: u32 = 4;
pub const KBBellDuration: u32 = 8;
pub const KBLed: u32 = 16;
pub const KBLedMode: u32 = 32;
pub const KBKey: u32 = 64;
pub const KBAutoRepeatMode: u32 = 128;
pub const MappingSuccess: u32 = 0;
pub const MappingBusy: u32 = 1;
pub const MappingFailed: u32 = 2;
pub const MappingModifier: u32 = 0;
pub const MappingKeyboard: u32 = 1;
pub const MappingPointer: u32 = 2;
pub const DontPreferBlanking: u32 = 0;
pub const PreferBlanking: u32 = 1;
pub const DefaultBlanking: u32 = 2;
pub const DisableScreenSaver: u32 = 0;
pub const DisableScreenInterval: u32 = 0;
pub const DontAllowExposures: u32 = 0;
pub const AllowExposures: u32 = 1;
pub const DefaultExposures: u32 = 2;
pub const ScreenSaverReset: u32 = 0;
pub const ScreenSaverActive: u32 = 1;
pub const HostInsert: u32 = 0;
pub const HostDelete: u32 = 1;
pub const EnableAccess: u32 = 1;
pub const DisableAccess: u32 = 0;
pub const StaticGray: u32 = 0;
pub const GrayScale: u32 = 1;
pub const StaticColor: u32 = 2;
pub const PseudoColor: u32 = 3;
pub const TrueColor: u32 = 4;
pub const DirectColor: u32 = 5;
pub const LSBFirst: u32 = 0;
pub const MSBFirst: u32 = 1;
pub const NeedFunctionPrototypes: u32 = 1;
pub const NeedVarargsPrototypes: u32 = 1;
pub const NeedNestedPrototypes: u32 = 1;
pub const FUNCPROTO: u32 = 15;
pub const NeedWidePrototypes: u32 = 0;
pub const X_HAVE_UTF8_STRING: u32 = 1;
pub const True: u32 = 1;
pub const False: u32 = 0;
pub const QueuedAlready: u32 = 0;
pub const QueuedAfterReading: u32 = 1;
pub const QueuedAfterFlush: u32 = 2;
pub const XNRequiredCharSet: &'static [u8; 16usize] = b"requiredCharSet\0";
pub const XNQueryOrientation: &'static [u8; 17usize] = b"queryOrientation\0";
pub const XNBaseFontName: &'static [u8; 13usize] = b"baseFontName\0";
pub const XNOMAutomatic: &'static [u8; 12usize] = b"omAutomatic\0";
pub const XNMissingCharSet: &'static [u8; 15usize] = b"missingCharSet\0";
pub const XNDefaultString: &'static [u8; 14usize] = b"defaultString\0";
pub const XNOrientation: &'static [u8; 12usize] = b"orientation\0";
pub const XNDirectionalDependentDrawing: &'static [u8; 28usize] = b"directionalDependentDrawing\0";
pub const XNContextualDrawing: &'static [u8; 18usize] = b"contextualDrawing\0";
pub const XNFontInfo: &'static [u8; 9usize] = b"fontInfo\0";
pub const XIMPreeditArea: u32 = 1;
pub const XIMPreeditCallbacks: u32 = 2;
pub const XIMPreeditPosition: u32 = 4;
pub const XIMPreeditNothing: u32 = 8;
pub const XIMPreeditNone: u32 = 16;
pub const XIMStatusArea: u32 = 256;
pub const XIMStatusCallbacks: u32 = 512;
pub const XIMStatusNothing: u32 = 1024;
pub const XIMStatusNone: u32 = 2048;
pub const XNVaNestedList: &'static [u8; 15usize] = b"XNVaNestedList\0";
pub const XNQueryInputStyle: &'static [u8; 16usize] = b"queryInputStyle\0";
pub const XNClientWindow: &'static [u8; 13usize] = b"clientWindow\0";
pub const XNInputStyle: &'static [u8; 11usize] = b"inputStyle\0";
pub const XNFocusWindow: &'static [u8; 12usize] = b"focusWindow\0";
pub const XNResourceName: &'static [u8; 13usize] = b"resourceName\0";
pub const XNResourceClass: &'static [u8; 14usize] = b"resourceClass\0";
pub const XNGeometryCallback: &'static [u8; 17usize] = b"geometryCallback\0";
pub const XNDestroyCallback: &'static [u8; 16usize] = b"destroyCallback\0";
pub const XNFilterEvents: &'static [u8; 13usize] = b"filterEvents\0";
pub const XNPreeditStartCallback: &'static [u8; 21usize] = b"preeditStartCallback\0";
pub const XNPreeditDoneCallback: &'static [u8; 20usize] = b"preeditDoneCallback\0";
pub const XNPreeditDrawCallback: &'static [u8; 20usize] = b"preeditDrawCallback\0";
pub const XNPreeditCaretCallback: &'static [u8; 21usize] = b"preeditCaretCallback\0";
pub const XNPreeditStateNotifyCallback: &'static [u8; 27usize] = b"preeditStateNotifyCallback\0";
pub const XNPreeditAttributes: &'static [u8; 18usize] = b"preeditAttributes\0";
pub const XNStatusStartCallback: &'static [u8; 20usize] = b"statusStartCallback\0";
pub const XNStatusDoneCallback: &'static [u8; 19usize] = b"statusDoneCallback\0";
pub const XNStatusDrawCallback: &'static [u8; 19usize] = b"statusDrawCallback\0";
pub const XNStatusAttributes: &'static [u8; 17usize] = b"statusAttributes\0";
pub const XNArea: &'static [u8; 5usize] = b"area\0";
pub const XNAreaNeeded: &'static [u8; 11usize] = b"areaNeeded\0";
pub const XNSpotLocation: &'static [u8; 13usize] = b"spotLocation\0";
pub const XNColormap: &'static [u8; 9usize] = b"colorMap\0";
pub const XNStdColormap: &'static [u8; 12usize] = b"stdColorMap\0";
pub const XNForeground: &'static [u8; 11usize] = b"foreground\0";
pub const XNBackground: &'static [u8; 11usize] = b"background\0";
pub const XNBackgroundPixmap: &'static [u8; 17usize] = b"backgroundPixmap\0";
pub const XNFontSet: &'static [u8; 8usize] = b"fontSet\0";
pub const XNLineSpace: &'static [u8; 10usize] = b"lineSpace\0";
pub const XNCursor: &'static [u8; 7usize] = b"cursor\0";
pub const XNQueryIMValuesList: &'static [u8; 18usize] = b"queryIMValuesList\0";
pub const XNQueryICValuesList: &'static [u8; 18usize] = b"queryICValuesList\0";
pub const XNVisiblePosition: &'static [u8; 16usize] = b"visiblePosition\0";
pub const XNR6PreeditCallback: &'static [u8; 18usize] = b"r6PreeditCallback\0";
pub const XNStringConversionCallback: &'static [u8; 25usize] = b"stringConversionCallback\0";
pub const XNStringConversion: &'static [u8; 17usize] = b"stringConversion\0";
pub const XNResetState: &'static [u8; 11usize] = b"resetState\0";
pub const XNHotKey: &'static [u8; 7usize] = b"hotKey\0";
pub const XNHotKeyState: &'static [u8; 12usize] = b"hotKeyState\0";
pub const XNPreeditState: &'static [u8; 13usize] = b"preeditState\0";
pub const XNSeparatorofNestedList: &'static [u8; 22usize] = b"separatorofNestedList\0";
pub const XBufferOverflow: i32 = -1;
pub const XLookupNone: u32 = 1;
pub const XLookupChars: u32 = 2;
pub const XLookupKeySym: u32 = 3;
pub const XLookupBoth: u32 = 4;
pub const XIMReverse: u32 = 1;
pub const XIMUnderline: u32 = 2;
pub const XIMHighlight: u32 = 4;
pub const XIMPrimary: u32 = 32;
pub const XIMSecondary: u32 = 64;
pub const XIMTertiary: u32 = 128;
pub const XIMVisibleToForward: u32 = 256;
pub const XIMVisibleToBackword: u32 = 512;
pub const XIMVisibleToCenter: u32 = 1024;
pub const XIMPreeditUnKnown: u32 = 0;
pub const XIMPreeditEnable: u32 = 1;
pub const XIMPreeditDisable: u32 = 2;
pub const XIMInitialState: u32 = 1;
pub const XIMPreserveState: u32 = 2;
pub const XIMStringConversionLeftEdge: u32 = 1;
pub const XIMStringConversionRightEdge: u32 = 2;
pub const XIMStringConversionTopEdge: u32 = 4;
pub const XIMStringConversionBottomEdge: u32 = 8;
pub const XIMStringConversionConcealed: u32 = 16;
pub const XIMStringConversionWrapped: u32 = 32;
pub const XIMStringConversionBuffer: u32 = 1;
pub const XIMStringConversionLine: u32 = 2;
pub const XIMStringConversionWord: u32 = 3;
pub const XIMStringConversionChar: u32 = 4;
pub const XIMStringConversionSubstitution: u32 = 1;
pub const XIMStringConversionRetrieval: u32 = 2;
pub const XIMHotKeyStateON: u32 = 1;
pub const XIMHotKeyStateOFF: u32 = 2;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VDP_TRUE: u32 = 1;
pub const VDP_FALSE: u32 = 0;
pub const VDP_INVALID_HANDLE: u32 = 4294967295;
pub const VDPAU_INTERFACE_VERSION: u32 = 1;
pub const VDPAU_VERSION: u32 = 1;
pub const VDP_PROCAMP_VERSION: u32 = 0;
pub const VDP_OUTPUT_SURFACE_RENDER_BLEND_STATE_VERSION: u32 = 0;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_0: u32 = 0;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_90: u32 = 1;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_180: u32 = 2;
pub const VDP_OUTPUT_SURFACE_RENDER_ROTATE_270: u32 = 3;
pub const VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX: u32 = 4;
pub const VDP_DECODER_LEVEL_MPEG1_NA: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG2_LL: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG2_ML: u32 = 1;
pub const VDP_DECODER_LEVEL_MPEG2_HL14: u32 = 2;
pub const VDP_DECODER_LEVEL_MPEG2_HL: u32 = 3;
pub const VDP_DECODER_LEVEL_H264_1: u32 = 10;
pub const VDP_DECODER_LEVEL_H264_1b: u32 = 9;
pub const VDP_DECODER_LEVEL_H264_1_1: u32 = 11;
pub const VDP_DECODER_LEVEL_H264_1_2: u32 = 12;
pub const VDP_DECODER_LEVEL_H264_1_3: u32 = 13;
pub const VDP_DECODER_LEVEL_H264_2: u32 = 20;
pub const VDP_DECODER_LEVEL_H264_2_1: u32 = 21;
pub const VDP_DECODER_LEVEL_H264_2_2: u32 = 22;
pub const VDP_DECODER_LEVEL_H264_3: u32 = 30;
pub const VDP_DECODER_LEVEL_H264_3_1: u32 = 31;
pub const VDP_DECODER_LEVEL_H264_3_2: u32 = 32;
pub const VDP_DECODER_LEVEL_H264_4: u32 = 40;
pub const VDP_DECODER_LEVEL_H264_4_1: u32 = 41;
pub const VDP_DECODER_LEVEL_H264_4_2: u32 = 42;
pub const VDP_DECODER_LEVEL_H264_5: u32 = 50;
pub const VDP_DECODER_LEVEL_H264_5_1: u32 = 51;
pub const VDP_DECODER_LEVEL_VC1_SIMPLE_LOW: u32 = 0;
pub const VDP_DECODER_LEVEL_VC1_SIMPLE_MEDIUM: u32 = 1;
pub const VDP_DECODER_LEVEL_VC1_MAIN_LOW: u32 = 0;
pub const VDP_DECODER_LEVEL_VC1_MAIN_MEDIUM: u32 = 1;
pub const VDP_DECODER_LEVEL_VC1_MAIN_HIGH: u32 = 2;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L0: u32 = 0;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L2: u32 = 2;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L3: u32 = 3;
pub const VDP_DECODER_LEVEL_VC1_ADVANCED_L4: u32 = 4;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L0: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L2: u32 = 2;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_SP_L3: u32 = 3;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L0: u32 = 0;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L2: u32 = 2;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L3: u32 = 3;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L4: u32 = 4;
pub const VDP_DECODER_LEVEL_MPEG4_PART2_ASP_L5: u32 = 5;
pub const VDP_DECODER_LEVEL_DIVX_NA: u32 = 0;
pub const VDP_DECODER_LEVEL_VP9_L1: u32 = 1;
pub const VDP_DECODER_LEVEL_HEVC_1: u32 = 30;
pub const VDP_DECODER_LEVEL_HEVC_2: u32 = 60;
pub const VDP_DECODER_LEVEL_HEVC_2_1: u32 = 63;
pub const VDP_DECODER_LEVEL_HEVC_3: u32 = 90;
pub const VDP_DECODER_LEVEL_HEVC_3_1: u32 = 93;
pub const VDP_DECODER_LEVEL_HEVC_4: u32 = 120;
pub const VDP_DECODER_LEVEL_HEVC_4_1: u32 = 123;
pub const VDP_DECODER_LEVEL_HEVC_5: u32 = 150;
pub const VDP_DECODER_LEVEL_HEVC_5_1: u32 = 153;
pub const VDP_DECODER_LEVEL_HEVC_5_2: u32 = 156;
pub const VDP_DECODER_LEVEL_HEVC_6: u32 = 180;
pub const VDP_DECODER_LEVEL_HEVC_6_1: u32 = 183;
pub const VDP_DECODER_LEVEL_HEVC_6_2: u32 = 186;
pub const VDP_BITSTREAM_BUFFER_VERSION: u32 = 0;
pub const VDP_LAYER_VERSION: u32 = 0;
pub const VDP_FUNC_ID_BASE_WINSYS: u32 = 4096;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl ::std::fmt::Debug for __pthread_cond_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__pthread_cond_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl ::std::fmt::Debug for __pthread_cond_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__pthread_cond_s__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl ::std::fmt::Debug for __pthread_cond_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "__pthread_cond_s {{ __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __bindgen_anon_1 , self . __bindgen_anon_2 , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals )
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutexattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutexattr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_condattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_condattr_t {{ union }}")
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_attr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_attr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_rwlock_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_rwlock_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_rwlockattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_rwlockattr_t {{ union }}")
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_barrier_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_barrier_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_barrierattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_barrierattr_t {{ union }}")
    }
}
pub type XID = ::std::os::raw::c_ulong;
pub type Mask = ::std::os::raw::c_ulong;
pub type Atom = ::std::os::raw::c_ulong;
pub type VisualID = ::std::os::raw::c_ulong;
pub type Time = ::std::os::raw::c_ulong;
pub type Window = XID;
pub type Drawable = XID;
pub type Font = XID;
pub type Pixmap = XID;
pub type Cursor = XID;
pub type Colormap = XID;
pub type GContext = XID;
pub type KeySym = XID;
pub type KeyCode = ::std::os::raw::c_uchar;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn _Xmblen(
        str_: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type XPointer = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XExtData {
    pub number: ::std::os::raw::c_int,
    pub next: *mut _XExtData,
    pub free_private: ::std::option::Option<
        unsafe extern "C" fn(extension: *mut _XExtData) -> ::std::os::raw::c_int,
    >,
    pub private_data: XPointer,
}
#[test]
fn bindgen_test_layout__XExtData() {
    assert_eq!(
        ::std::mem::size_of::<_XExtData>(),
        32usize,
        concat!("Size of: ", stringify!(_XExtData))
    );
    assert_eq!(
        ::std::mem::align_of::<_XExtData>(),
        8usize,
        concat!("Alignment of ", stringify!(_XExtData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).free_private as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(free_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).private_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(private_data)
        )
    );
}
pub type XExtData = _XExtData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XExtCodes {
    pub extension: ::std::os::raw::c_int,
    pub major_opcode: ::std::os::raw::c_int,
    pub first_event: ::std::os::raw::c_int,
    pub first_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XExtCodes() {
    assert_eq!(
        ::std::mem::size_of::<XExtCodes>(),
        16usize,
        concat!("Size of: ", stringify!(XExtCodes))
    );
    assert_eq!(
        ::std::mem::align_of::<XExtCodes>(),
        4usize,
        concat!("Alignment of ", stringify!(XExtCodes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExtCodes>())).extension as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExtCodes>())).major_opcode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExtCodes>())).first_event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(first_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExtCodes>())).first_error as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(first_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPixmapFormatValues {
    pub depth: ::std::os::raw::c_int,
    pub bits_per_pixel: ::std::os::raw::c_int,
    pub scanline_pad: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XPixmapFormatValues() {
    assert_eq!(
        ::std::mem::size_of::<XPixmapFormatValues>(),
        12usize,
        concat!("Size of: ", stringify!(XPixmapFormatValues))
    );
    assert_eq!(
        ::std::mem::align_of::<XPixmapFormatValues>(),
        4usize,
        concat!("Alignment of ", stringify!(XPixmapFormatValues))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPixmapFormatValues>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XPixmapFormatValues>())).bits_per_pixel as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XPixmapFormatValues>())).scanline_pad as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(scanline_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XGCValues {
    pub function: ::std::os::raw::c_int,
    pub plane_mask: ::std::os::raw::c_ulong,
    pub foreground: ::std::os::raw::c_ulong,
    pub background: ::std::os::raw::c_ulong,
    pub line_width: ::std::os::raw::c_int,
    pub line_style: ::std::os::raw::c_int,
    pub cap_style: ::std::os::raw::c_int,
    pub join_style: ::std::os::raw::c_int,
    pub fill_style: ::std::os::raw::c_int,
    pub fill_rule: ::std::os::raw::c_int,
    pub arc_mode: ::std::os::raw::c_int,
    pub tile: Pixmap,
    pub stipple: Pixmap,
    pub ts_x_origin: ::std::os::raw::c_int,
    pub ts_y_origin: ::std::os::raw::c_int,
    pub font: Font,
    pub subwindow_mode: ::std::os::raw::c_int,
    pub graphics_exposures: ::std::os::raw::c_int,
    pub clip_x_origin: ::std::os::raw::c_int,
    pub clip_y_origin: ::std::os::raw::c_int,
    pub clip_mask: Pixmap,
    pub dash_offset: ::std::os::raw::c_int,
    pub dashes: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XGCValues() {
    assert_eq!(
        ::std::mem::size_of::<XGCValues>(),
        128usize,
        concat!("Size of: ", stringify!(XGCValues))
    );
    assert_eq!(
        ::std::mem::align_of::<XGCValues>(),
        8usize,
        concat!("Alignment of ", stringify!(XGCValues))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).plane_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).foreground as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).background as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).line_width as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).line_style as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).cap_style as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).join_style as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).fill_style as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).fill_rule as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).arc_mode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(arc_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).tile as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).stipple as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).ts_x_origin as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(ts_x_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).ts_y_origin as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(ts_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).font as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).subwindow_mode as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).graphics_exposures as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).clip_x_origin as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).clip_y_origin as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).clip_mask as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).dash_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGCValues>())).dashes as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(dashes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XGC {
    _unused: [u8; 0],
}
pub type GC = *mut _XGC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Visual {
    pub ext_data: *mut XExtData,
    pub visualid: VisualID,
    pub class: ::std::os::raw::c_int,
    pub red_mask: ::std::os::raw::c_ulong,
    pub green_mask: ::std::os::raw::c_ulong,
    pub blue_mask: ::std::os::raw::c_ulong,
    pub bits_per_rgb: ::std::os::raw::c_int,
    pub map_entries: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Visual() {
    assert_eq!(
        ::std::mem::size_of::<Visual>(),
        56usize,
        concat!("Size of: ", stringify!(Visual))
    );
    assert_eq!(
        ::std::mem::align_of::<Visual>(),
        8usize,
        concat!("Alignment of ", stringify!(Visual))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).visualid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(visualid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).class as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).red_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).green_mask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).blue_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).bits_per_rgb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(bits_per_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).map_entries as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(map_entries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Depth {
    pub depth: ::std::os::raw::c_int,
    pub nvisuals: ::std::os::raw::c_int,
    pub visuals: *mut Visual,
}
#[test]
fn bindgen_test_layout_Depth() {
    assert_eq!(
        ::std::mem::size_of::<Depth>(),
        16usize,
        concat!("Size of: ", stringify!(Depth))
    );
    assert_eq!(
        ::std::mem::align_of::<Depth>(),
        8usize,
        concat!("Alignment of ", stringify!(Depth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Depth>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Depth>())).nvisuals as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(nvisuals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Depth>())).visuals as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(visuals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XDisplay {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Screen {
    pub ext_data: *mut XExtData,
    pub display: *mut _XDisplay,
    pub root: Window,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mwidth: ::std::os::raw::c_int,
    pub mheight: ::std::os::raw::c_int,
    pub ndepths: ::std::os::raw::c_int,
    pub depths: *mut Depth,
    pub root_depth: ::std::os::raw::c_int,
    pub root_visual: *mut Visual,
    pub default_gc: GC,
    pub cmap: Colormap,
    pub white_pixel: ::std::os::raw::c_ulong,
    pub black_pixel: ::std::os::raw::c_ulong,
    pub max_maps: ::std::os::raw::c_int,
    pub min_maps: ::std::os::raw::c_int,
    pub backing_store: ::std::os::raw::c_int,
    pub save_unders: ::std::os::raw::c_int,
    pub root_input_mask: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Screen() {
    assert_eq!(
        ::std::mem::size_of::<Screen>(),
        128usize,
        concat!("Size of: ", stringify!(Screen))
    );
    assert_eq!(
        ::std::mem::align_of::<Screen>(),
        8usize,
        concat!("Alignment of ", stringify!(Screen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).mwidth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).mheight as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).ndepths as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ndepths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).depths as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(depths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root_depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root_visual as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).default_gc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(default_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).cmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).white_pixel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).black_pixel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).max_maps as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(max_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).min_maps as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(min_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).backing_store as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).save_unders as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root_input_mask as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_input_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScreenFormat {
    pub ext_data: *mut XExtData,
    pub depth: ::std::os::raw::c_int,
    pub bits_per_pixel: ::std::os::raw::c_int,
    pub scanline_pad: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ScreenFormat() {
    assert_eq!(
        ::std::mem::size_of::<ScreenFormat>(),
        24usize,
        concat!("Size of: ", stringify!(ScreenFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<ScreenFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(ScreenFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScreenFormat>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScreenFormat>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScreenFormat>())).bits_per_pixel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScreenFormat>())).scanline_pad as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(scanline_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XSetWindowAttributes {
    pub background_pixmap: Pixmap,
    pub background_pixel: ::std::os::raw::c_ulong,
    pub border_pixmap: Pixmap,
    pub border_pixel: ::std::os::raw::c_ulong,
    pub bit_gravity: ::std::os::raw::c_int,
    pub win_gravity: ::std::os::raw::c_int,
    pub backing_store: ::std::os::raw::c_int,
    pub backing_planes: ::std::os::raw::c_ulong,
    pub backing_pixel: ::std::os::raw::c_ulong,
    pub save_under: ::std::os::raw::c_int,
    pub event_mask: ::std::os::raw::c_long,
    pub do_not_propagate_mask: ::std::os::raw::c_long,
    pub override_redirect: ::std::os::raw::c_int,
    pub colormap: Colormap,
    pub cursor: Cursor,
}
#[test]
fn bindgen_test_layout_XSetWindowAttributes() {
    assert_eq!(
        ::std::mem::size_of::<XSetWindowAttributes>(),
        112usize,
        concat!("Size of: ", stringify!(XSetWindowAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<XSetWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XSetWindowAttributes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).background_pixmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).background_pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).border_pixmap as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).border_pixel as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).bit_gravity as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).win_gravity as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).backing_store as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).backing_planes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).backing_pixel as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSetWindowAttributes>())).save_under as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSetWindowAttributes>())).event_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).do_not_propagate_mask as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSetWindowAttributes>())).override_redirect as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSetWindowAttributes>())).colormap as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSetWindowAttributes>())).cursor as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XWindowAttributes {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub visual: *mut Visual,
    pub root: Window,
    pub class: ::std::os::raw::c_int,
    pub bit_gravity: ::std::os::raw::c_int,
    pub win_gravity: ::std::os::raw::c_int,
    pub backing_store: ::std::os::raw::c_int,
    pub backing_planes: ::std::os::raw::c_ulong,
    pub backing_pixel: ::std::os::raw::c_ulong,
    pub save_under: ::std::os::raw::c_int,
    pub colormap: Colormap,
    pub map_installed: ::std::os::raw::c_int,
    pub map_state: ::std::os::raw::c_int,
    pub all_event_masks: ::std::os::raw::c_long,
    pub your_event_mask: ::std::os::raw::c_long,
    pub do_not_propagate_mask: ::std::os::raw::c_long,
    pub override_redirect: ::std::os::raw::c_int,
    pub screen: *mut Screen,
}
#[test]
fn bindgen_test_layout_XWindowAttributes() {
    assert_eq!(
        ::std::mem::size_of::<XWindowAttributes>(),
        136usize,
        concat!("Size of: ", stringify!(XWindowAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<XWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowAttributes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).border_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).visual as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).root as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).class as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).bit_gravity as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).win_gravity as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).backing_store as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XWindowAttributes>())).backing_planes as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).backing_pixel as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).save_under as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).colormap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).map_installed as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(map_installed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).map_state as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(map_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XWindowAttributes>())).all_event_masks as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(all_event_masks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XWindowAttributes>())).your_event_mask as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(your_event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XWindowAttributes>())).do_not_propagate_mask as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XWindowAttributes>())).override_redirect as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowAttributes>())).screen as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(screen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XHostAddress {
    pub family: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub address: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XHostAddress() {
    assert_eq!(
        ::std::mem::size_of::<XHostAddress>(),
        16usize,
        concat!("Size of: ", stringify!(XHostAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<XHostAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XHostAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XHostAddress>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XHostAddress>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XHostAddress>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XServerInterpretedAddress {
    pub typelength: ::std::os::raw::c_int,
    pub valuelength: ::std::os::raw::c_int,
    pub type_: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XServerInterpretedAddress() {
    assert_eq!(
        ::std::mem::size_of::<XServerInterpretedAddress>(),
        24usize,
        concat!("Size of: ", stringify!(XServerInterpretedAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<XServerInterpretedAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XServerInterpretedAddress))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XServerInterpretedAddress>())).typelength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(typelength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XServerInterpretedAddress>())).valuelength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(valuelength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XServerInterpretedAddress>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XServerInterpretedAddress>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XImage {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub xoffset: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
    pub byte_order: ::std::os::raw::c_int,
    pub bitmap_unit: ::std::os::raw::c_int,
    pub bitmap_bit_order: ::std::os::raw::c_int,
    pub bitmap_pad: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub bytes_per_line: ::std::os::raw::c_int,
    pub bits_per_pixel: ::std::os::raw::c_int,
    pub red_mask: ::std::os::raw::c_ulong,
    pub green_mask: ::std::os::raw::c_ulong,
    pub blue_mask: ::std::os::raw::c_ulong,
    pub obdata: XPointer,
    pub f: _XImage_funcs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XImage_funcs {
    pub create_image: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XDisplay,
            arg2: *mut Visual,
            arg3: ::std::os::raw::c_uint,
            arg4: ::std::os::raw::c_int,
            arg5: ::std::os::raw::c_int,
            arg6: *mut ::std::os::raw::c_char,
            arg7: ::std::os::raw::c_uint,
            arg8: ::std::os::raw::c_uint,
            arg9: ::std::os::raw::c_int,
            arg10: ::std::os::raw::c_int,
        ) -> *mut _XImage,
    >,
    pub destroy_image:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _XImage) -> ::std::os::raw::c_int>,
    pub get_pixel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub put_pixel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    pub sub_image: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_uint,
            arg5: ::std::os::raw::c_uint,
        ) -> *mut _XImage,
    >,
    pub add_pixel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__XImage_funcs() {
    assert_eq!(
        ::std::mem::size_of::<_XImage_funcs>(),
        48usize,
        concat!("Size of: ", stringify!(_XImage_funcs))
    );
    assert_eq!(
        ::std::mem::align_of::<_XImage_funcs>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage_funcs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage_funcs>())).create_image as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(create_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage_funcs>())).destroy_image as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(destroy_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage_funcs>())).get_pixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(get_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage_funcs>())).put_pixel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(put_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage_funcs>())).sub_image as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(sub_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage_funcs>())).add_pixel as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(add_pixel)
        )
    );
}
#[test]
fn bindgen_test_layout__XImage() {
    assert_eq!(
        ::std::mem::size_of::<_XImage>(),
        136usize,
        concat!("Size of: ", stringify!(_XImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_XImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).xoffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(xoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).byte_order as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).bitmap_unit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).bitmap_bit_order as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_bit_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).bitmap_pad as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).depth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).bytes_per_line as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bytes_per_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).bits_per_pixel as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).red_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).green_mask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).blue_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).obdata as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(obdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XImage>())).f as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(f)
        )
    );
}
pub type XImage = _XImage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XWindowChanges {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub sibling: Window,
    pub stack_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XWindowChanges() {
    assert_eq!(
        ::std::mem::size_of::<XWindowChanges>(),
        40usize,
        concat!("Size of: ", stringify!(XWindowChanges))
    );
    assert_eq!(
        ::std::mem::align_of::<XWindowChanges>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowChanges))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowChanges>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowChanges>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowChanges>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowChanges>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowChanges>())).border_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowChanges>())).sibling as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XWindowChanges>())).stack_mode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(stack_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XColor {
    pub pixel: ::std::os::raw::c_ulong,
    pub red: ::std::os::raw::c_ushort,
    pub green: ::std::os::raw::c_ushort,
    pub blue: ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_char,
    pub pad: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XColor() {
    assert_eq!(
        ::std::mem::size_of::<XColor>(),
        16usize,
        concat!("Size of: ", stringify!(XColor))
    );
    assert_eq!(
        ::std::mem::align_of::<XColor>(),
        8usize,
        concat!("Alignment of ", stringify!(XColor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColor>())).pixel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColor>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColor>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColor>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColor>())).flags as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColor>())).pad as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XSegment {
    pub x1: ::std::os::raw::c_short,
    pub y1: ::std::os::raw::c_short,
    pub x2: ::std::os::raw::c_short,
    pub y2: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XSegment() {
    assert_eq!(
        ::std::mem::size_of::<XSegment>(),
        8usize,
        concat!("Size of: ", stringify!(XSegment))
    );
    assert_eq!(
        ::std::mem::align_of::<XSegment>(),
        2usize,
        concat!("Alignment of ", stringify!(XSegment))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSegment>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSegment>())).y1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSegment>())).x2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSegment>())).y2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPoint {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XPoint() {
    assert_eq!(
        ::std::mem::size_of::<XPoint>(),
        4usize,
        concat!("Size of: ", stringify!(XPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<XPoint>(),
        2usize,
        concat!("Alignment of ", stringify!(XPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPoint>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(XPoint), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPoint>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(XPoint), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XRectangle {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub width: ::std::os::raw::c_ushort,
    pub height: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_XRectangle() {
    assert_eq!(
        ::std::mem::size_of::<XRectangle>(),
        8usize,
        concat!("Size of: ", stringify!(XRectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<XRectangle>(),
        2usize,
        concat!("Alignment of ", stringify!(XRectangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XArc {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub width: ::std::os::raw::c_ushort,
    pub height: ::std::os::raw::c_ushort,
    pub angle1: ::std::os::raw::c_short,
    pub angle2: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XArc() {
    assert_eq!(
        ::std::mem::size_of::<XArc>(),
        12usize,
        concat!("Size of: ", stringify!(XArc))
    );
    assert_eq!(
        ::std::mem::align_of::<XArc>(),
        2usize,
        concat!("Alignment of ", stringify!(XArc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XArc>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(XArc), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XArc>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(XArc), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XArc>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XArc>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XArc>())).angle1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(angle1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XArc>())).angle2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(angle2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XKeyboardControl {
    pub key_click_percent: ::std::os::raw::c_int,
    pub bell_percent: ::std::os::raw::c_int,
    pub bell_pitch: ::std::os::raw::c_int,
    pub bell_duration: ::std::os::raw::c_int,
    pub led: ::std::os::raw::c_int,
    pub led_mode: ::std::os::raw::c_int,
    pub key: ::std::os::raw::c_int,
    pub auto_repeat_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XKeyboardControl() {
    assert_eq!(
        ::std::mem::size_of::<XKeyboardControl>(),
        32usize,
        concat!("Size of: ", stringify!(XKeyboardControl))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeyboardControl>(),
        4usize,
        concat!("Alignment of ", stringify!(XKeyboardControl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XKeyboardControl>())).key_click_percent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardControl>())).bell_percent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardControl>())).bell_pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardControl>())).bell_duration as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardControl>())).led as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardControl>())).led_mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(led_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardControl>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XKeyboardControl>())).auto_repeat_mode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(auto_repeat_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XKeyboardState {
    pub key_click_percent: ::std::os::raw::c_int,
    pub bell_percent: ::std::os::raw::c_int,
    pub bell_pitch: ::std::os::raw::c_uint,
    pub bell_duration: ::std::os::raw::c_uint,
    pub led_mask: ::std::os::raw::c_ulong,
    pub global_auto_repeat: ::std::os::raw::c_int,
    pub auto_repeats: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeyboardState() {
    assert_eq!(
        ::std::mem::size_of::<XKeyboardState>(),
        64usize,
        concat!("Size of: ", stringify!(XKeyboardState))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeyboardState>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyboardState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XKeyboardState>())).key_click_percent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardState>())).bell_percent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardState>())).bell_pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardState>())).bell_duration as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardState>())).led_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(led_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XKeyboardState>())).global_auto_repeat as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(global_auto_repeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyboardState>())).auto_repeats as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(auto_repeats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XTimeCoord {
    pub time: Time,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_XTimeCoord() {
    assert_eq!(
        ::std::mem::size_of::<XTimeCoord>(),
        16usize,
        concat!("Size of: ", stringify!(XTimeCoord))
    );
    assert_eq!(
        ::std::mem::align_of::<XTimeCoord>(),
        8usize,
        concat!("Alignment of ", stringify!(XTimeCoord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTimeCoord>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTimeCoord>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTimeCoord>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XModifierKeymap {
    pub max_keypermod: ::std::os::raw::c_int,
    pub modifiermap: *mut KeyCode,
}
#[test]
fn bindgen_test_layout_XModifierKeymap() {
    assert_eq!(
        ::std::mem::size_of::<XModifierKeymap>(),
        16usize,
        concat!("Size of: ", stringify!(XModifierKeymap))
    );
    assert_eq!(
        ::std::mem::align_of::<XModifierKeymap>(),
        8usize,
        concat!("Alignment of ", stringify!(XModifierKeymap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XModifierKeymap>())).max_keypermod as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XModifierKeymap),
            "::",
            stringify!(max_keypermod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XModifierKeymap>())).modifiermap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XModifierKeymap),
            "::",
            stringify!(modifiermap)
        )
    );
}
pub type Display = _XDisplay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XrmHashBucketRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub ext_data: *mut XExtData,
    pub private1: *mut _XPrivate,
    pub fd: ::std::os::raw::c_int,
    pub private2: ::std::os::raw::c_int,
    pub proto_major_version: ::std::os::raw::c_int,
    pub proto_minor_version: ::std::os::raw::c_int,
    pub vendor: *mut ::std::os::raw::c_char,
    pub private3: XID,
    pub private4: XID,
    pub private5: XID,
    pub private6: ::std::os::raw::c_int,
    pub resource_alloc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> XID>,
    pub byte_order: ::std::os::raw::c_int,
    pub bitmap_unit: ::std::os::raw::c_int,
    pub bitmap_pad: ::std::os::raw::c_int,
    pub bitmap_bit_order: ::std::os::raw::c_int,
    pub nformats: ::std::os::raw::c_int,
    pub pixmap_format: *mut ScreenFormat,
    pub private8: ::std::os::raw::c_int,
    pub release: ::std::os::raw::c_int,
    pub private9: *mut _XPrivate,
    pub private10: *mut _XPrivate,
    pub qlen: ::std::os::raw::c_int,
    pub last_request_read: ::std::os::raw::c_ulong,
    pub request: ::std::os::raw::c_ulong,
    pub private11: XPointer,
    pub private12: XPointer,
    pub private13: XPointer,
    pub private14: XPointer,
    pub max_request_size: ::std::os::raw::c_uint,
    pub db: *mut _XrmHashBucketRec,
    pub private15:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> ::std::os::raw::c_int>,
    pub display_name: *mut ::std::os::raw::c_char,
    pub default_screen: ::std::os::raw::c_int,
    pub nscreens: ::std::os::raw::c_int,
    pub screens: *mut Screen,
    pub motion_buffer: ::std::os::raw::c_ulong,
    pub private16: ::std::os::raw::c_ulong,
    pub min_keycode: ::std::os::raw::c_int,
    pub max_keycode: ::std::os::raw::c_int,
    pub private17: XPointer,
    pub private18: XPointer,
    pub private19: ::std::os::raw::c_int,
    pub xdefaults: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_1>(),
        296usize,
        concat!("Size of: ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).fd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_bindgen_ty_1>())).proto_major_version as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(proto_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_bindgen_ty_1>())).proto_minor_version as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(proto_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).vendor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private3 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private4 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private5 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private6 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).resource_alloc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(resource_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).byte_order as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).bitmap_unit as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).bitmap_pad as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).bitmap_bit_order as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_bit_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).nformats as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(nformats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).pixmap_format as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(pixmap_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private8 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).release as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private9 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private10 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).qlen as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).last_request_read as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(last_request_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).request as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private11 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private12 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private13 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private14 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).max_request_size as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(max_request_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).db as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(db)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private15 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).display_name as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).default_screen as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(default_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).nscreens as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(nscreens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).screens as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(screens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).motion_buffer as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(motion_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private16 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).min_keycode as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(min_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).max_keycode as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(max_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private17 as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private17)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private18 as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private18)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).private19 as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private19)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).xdefaults as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(xdefaults)
        )
    );
}
pub type _XPrivDisplay = *mut _bindgen_ty_1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XKeyEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
    pub keycode: ::std::os::raw::c_uint,
    pub same_screen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XKeyEvent() {
    assert_eq!(
        ::std::mem::size_of::<XKeyEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XKeyEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).keycode as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeyEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XKeyPressedEvent = XKeyEvent;
pub type XKeyReleasedEvent = XKeyEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XButtonEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
    pub button: ::std::os::raw::c_uint,
    pub same_screen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XButtonEvent() {
    assert_eq!(
        ::std::mem::size_of::<XButtonEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XButtonEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).button as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XButtonEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XButtonPressedEvent = XButtonEvent;
pub type XButtonReleasedEvent = XButtonEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMotionEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
    pub is_hint: ::std::os::raw::c_char,
    pub same_screen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XMotionEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMotionEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XMotionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMotionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMotionEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).is_hint as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(is_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMotionEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XPointerMovedEvent = XMotionEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XCrossingEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x_root: ::std::os::raw::c_int,
    pub y_root: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_int,
    pub detail: ::std::os::raw::c_int,
    pub same_screen: ::std::os::raw::c_int,
    pub focus: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_XCrossingEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCrossingEvent>(),
        104usize,
        concat!("Size of: ", stringify!(XCrossingEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCrossingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCrossingEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).mode as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).detail as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).focus as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCrossingEvent>())).state as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(state)
        )
    );
}
pub type XEnterWindowEvent = XCrossingEvent;
pub type XLeaveWindowEvent = XCrossingEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XFocusChangeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub mode: ::std::os::raw::c_int,
    pub detail: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XFocusChangeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XFocusChangeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XFocusChangeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XFocusChangeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XFocusChangeEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFocusChangeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFocusChangeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFocusChangeEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFocusChangeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFocusChangeEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFocusChangeEvent>())).mode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFocusChangeEvent>())).detail as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(detail)
        )
    );
}
pub type XFocusInEvent = XFocusChangeEvent;
pub type XFocusOutEvent = XFocusChangeEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XKeymapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub key_vector: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeymapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XKeymapEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XKeymapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XKeymapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeymapEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeymapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeymapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeymapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeymapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeymapEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XKeymapEvent>())).key_vector as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(key_vector)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XExposeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XExposeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XExposeEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XExposeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XExposeEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).x as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).y as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).height as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XExposeEvent>())).count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XGraphicsExposeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub major_code: ::std::os::raw::c_int,
    pub minor_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XGraphicsExposeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XGraphicsExposeEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XGraphicsExposeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XGraphicsExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGraphicsExposeEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).drawable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).x as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).y as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).height as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).major_code as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGraphicsExposeEvent>())).minor_code as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XNoExposeEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub major_code: ::std::os::raw::c_int,
    pub minor_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XNoExposeEvent() {
    assert_eq!(
        ::std::mem::size_of::<XNoExposeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XNoExposeEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XNoExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XNoExposeEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XNoExposeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XNoExposeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XNoExposeEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XNoExposeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XNoExposeEvent>())).drawable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XNoExposeEvent>())).major_code as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XNoExposeEvent>())).minor_code as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XVisibilityEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XVisibilityEvent() {
    assert_eq!(
        ::std::mem::size_of::<XVisibilityEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XVisibilityEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XVisibilityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XVisibilityEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XVisibilityEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XVisibilityEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XVisibilityEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XVisibilityEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XVisibilityEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XVisibilityEvent>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XCreateWindowEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XCreateWindowEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCreateWindowEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XCreateWindowEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCreateWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCreateWindowEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCreateWindowEvent>())).border_width as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XCreateWindowEvent>())).override_redirect as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XDestroyWindowEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XDestroyWindowEvent() {
    assert_eq!(
        ::std::mem::size_of::<XDestroyWindowEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XDestroyWindowEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XDestroyWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XDestroyWindowEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XDestroyWindowEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XDestroyWindowEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XDestroyWindowEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XDestroyWindowEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XDestroyWindowEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XDestroyWindowEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XUnmapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub from_configure: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XUnmapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XUnmapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XUnmapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XUnmapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XUnmapEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUnmapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUnmapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUnmapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUnmapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUnmapEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUnmapEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XUnmapEvent>())).from_configure as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(from_configure)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XMapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapEvent>())).override_redirect as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMapRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XMapRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMapRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XMapRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMapRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapRequestEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapRequestEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMapRequestEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XReparentEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub parent: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XReparentEvent() {
    assert_eq!(
        ::std::mem::size_of::<XReparentEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XReparentEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XReparentEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XReparentEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).parent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).x as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XReparentEvent>())).y as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XReparentEvent>())).override_redirect as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XConfigureEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub above: Window,
    pub override_redirect: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XConfigureEvent() {
    assert_eq!(
        ::std::mem::size_of::<XConfigureEvent>(),
        88usize,
        concat!("Size of: ", stringify!(XConfigureEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XConfigureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).border_width as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureEvent>())).above as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(above)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XConfigureEvent>())).override_redirect as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XGravityEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XGravityEvent() {
    assert_eq!(
        ::std::mem::size_of::<XGravityEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XGravityEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XGravityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGravityEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGravityEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XResizeRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XResizeRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XResizeRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XResizeRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XResizeRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XResizeRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XResizeRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XResizeRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XResizeRequestEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XResizeRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XResizeRequestEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XResizeRequestEvent>())).width as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XResizeRequestEvent>())).height as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XConfigureRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub border_width: ::std::os::raw::c_int,
    pub above: Window,
    pub detail: ::std::os::raw::c_int,
    pub value_mask: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_XConfigureRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XConfigureRequestEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XConfigureRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XConfigureRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XConfigureRequestEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XConfigureRequestEvent>())).border_width as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).above as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(above)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XConfigureRequestEvent>())).detail as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XConfigureRequestEvent>())).value_mask as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XCirculateEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub place: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCirculateEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCirculateEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateEvent>())).place as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(place)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XCirculateRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub place: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XCirculateRequestEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XCirculateRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XCirculateRequestEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateRequestEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateRequestEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCirculateRequestEvent>())).place as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(place)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPropertyEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub atom: Atom,
    pub time: Time,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XPropertyEvent() {
    assert_eq!(
        ::std::mem::size_of::<XPropertyEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XPropertyEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XPropertyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XPropertyEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).atom as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).time as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XPropertyEvent>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XSelectionClearEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub selection: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionClearEvent() {
    assert_eq!(
        ::std::mem::size_of::<XSelectionClearEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XSelectionClearEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XSelectionClearEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionClearEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionClearEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionClearEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionClearEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionClearEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionClearEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionClearEvent>())).selection as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionClearEvent>())).time as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XSelectionRequestEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub owner: Window,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionRequestEvent() {
    assert_eq!(
        ::std::mem::size_of::<XSelectionRequestEvent>(),
        80usize,
        concat!("Size of: ", stringify!(XSelectionRequestEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XSelectionRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSelectionRequestEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionRequestEvent>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSelectionRequestEvent>())).requestor as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XSelectionRequestEvent>())).selection as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionRequestEvent>())).target as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionRequestEvent>())).property as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionRequestEvent>())).time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XSelectionEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionEvent() {
    assert_eq!(
        ::std::mem::size_of::<XSelectionEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XSelectionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XSelectionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).requestor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).selection as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).target as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).property as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XSelectionEvent>())).time as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XColormapEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub colormap: Colormap,
    pub new: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XColormapEvent() {
    assert_eq!(
        ::std::mem::size_of::<XColormapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XColormapEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XColormapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XColormapEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).colormap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).new as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XColormapEvent>())).state as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XClientMessageEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub message_type: Atom,
    pub format: ::std::os::raw::c_int,
    pub data: XClientMessageEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XClientMessageEvent__bindgen_ty_1 {
    pub b: [::std::os::raw::c_char; 20usize],
    pub s: [::std::os::raw::c_short; 10usize],
    pub l: [::std::os::raw::c_long; 5usize],
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_XClientMessageEvent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<XClientMessageEvent__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(XClientMessageEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<XClientMessageEvent__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(XClientMessageEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).b as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).s as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
}
impl ::std::fmt::Debug for XClientMessageEvent__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "XClientMessageEvent__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_XClientMessageEvent() {
    assert_eq!(
        ::std::mem::size_of::<XClientMessageEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XClientMessageEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XClientMessageEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XClientMessageEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XClientMessageEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XClientMessageEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XClientMessageEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XClientMessageEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XClientMessageEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XClientMessageEvent>())).message_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(message_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XClientMessageEvent>())).format as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XClientMessageEvent>())).data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(data)
        )
    );
}
impl ::std::fmt::Debug for XClientMessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "XClientMessageEvent {{ type: {:?}, serial: {:?}, send_event: {:?}, display: {:?}, window: {:?}, message_type: {:?}, format: {:?}, data: {:?} }}" , self . type_ , self . serial , self . send_event , self . display , self . window , self . message_type , self . format , self . data )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMappingEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub request: ::std::os::raw::c_int,
    pub first_keycode: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XMappingEvent() {
    assert_eq!(
        ::std::mem::size_of::<XMappingEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMappingEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XMappingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMappingEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).request as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).first_keycode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XMappingEvent>())).count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XErrorEvent {
    pub type_: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub resourceid: XID,
    pub serial: ::std::os::raw::c_ulong,
    pub error_code: ::std::os::raw::c_uchar,
    pub request_code: ::std::os::raw::c_uchar,
    pub minor_code: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_XErrorEvent() {
    assert_eq!(
        ::std::mem::size_of::<XErrorEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XErrorEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XErrorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XErrorEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XErrorEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XErrorEvent>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XErrorEvent>())).resourceid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(resourceid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XErrorEvent>())).serial as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XErrorEvent>())).error_code as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XErrorEvent>())).request_code as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(request_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XErrorEvent>())).minor_code as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XAnyEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XAnyEvent() {
    assert_eq!(
        ::std::mem::size_of::<XAnyEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XAnyEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XAnyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XAnyEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XAnyEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XAnyEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XAnyEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XAnyEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XAnyEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XGenericEvent {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub extension: ::std::os::raw::c_int,
    pub evtype: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XGenericEvent() {
    assert_eq!(
        ::std::mem::size_of::<XGenericEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XGenericEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<XGenericEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEvent>())).extension as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEvent>())).evtype as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(evtype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XGenericEventCookie {
    pub type_: ::std::os::raw::c_int,
    pub serial: ::std::os::raw::c_ulong,
    pub send_event: ::std::os::raw::c_int,
    pub display: *mut Display,
    pub extension: ::std::os::raw::c_int,
    pub evtype: ::std::os::raw::c_int,
    pub cookie: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_XGenericEventCookie() {
    assert_eq!(
        ::std::mem::size_of::<XGenericEventCookie>(),
        56usize,
        concat!("Size of: ", stringify!(XGenericEventCookie))
    );
    assert_eq!(
        ::std::mem::align_of::<XGenericEventCookie>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEventCookie))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).extension as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).evtype as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(evtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).cookie as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XGenericEventCookie>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XEvent {
    pub type_: ::std::os::raw::c_int,
    pub xany: XAnyEvent,
    pub xkey: XKeyEvent,
    pub xbutton: XButtonEvent,
    pub xmotion: XMotionEvent,
    pub xcrossing: XCrossingEvent,
    pub xfocus: XFocusChangeEvent,
    pub xexpose: XExposeEvent,
    pub xgraphicsexpose: XGraphicsExposeEvent,
    pub xnoexpose: XNoExposeEvent,
    pub xvisibility: XVisibilityEvent,
    pub xcreatewindow: XCreateWindowEvent,
    pub xdestroywindow: XDestroyWindowEvent,
    pub xunmap: XUnmapEvent,
    pub xmap: XMapEvent,
    pub xmaprequest: XMapRequestEvent,
    pub xreparent: XReparentEvent,
    pub xconfigure: XConfigureEvent,
    pub xgravity: XGravityEvent,
    pub xresizerequest: XResizeRequestEvent,
    pub xconfigurerequest: XConfigureRequestEvent,
    pub xcirculate: XCirculateEvent,
    pub xcirculaterequest: XCirculateRequestEvent,
    pub xproperty: XPropertyEvent,
    pub xselectionclear: XSelectionClearEvent,
    pub xselectionrequest: XSelectionRequestEvent,
    pub xselection: XSelectionEvent,
    pub xcolormap: XColormapEvent,
    pub xclient: XClientMessageEvent,
    pub xmapping: XMappingEvent,
    pub xerror: XErrorEvent,
    pub xkeymap: XKeymapEvent,
    pub xgeneric: XGenericEvent,
    pub xcookie: XGenericEventCookie,
    pub pad: [::std::os::raw::c_long; 24usize],
    _bindgen_union_align: [u64; 24usize],
}
#[test]
fn bindgen_test_layout__XEvent() {
    assert_eq!(
        ::std::mem::size_of::<_XEvent>(),
        192usize,
        concat!("Size of: ", stringify!(_XEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<_XEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(_XEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xany as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xany)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xbutton as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xbutton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xmotion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmotion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xcrossing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcrossing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xfocus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xfocus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xexpose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xexpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xgraphicsexpose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgraphicsexpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xnoexpose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xnoexpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xvisibility as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xvisibility)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xcreatewindow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcreatewindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xdestroywindow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xdestroywindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xunmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xunmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xmaprequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmaprequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xreparent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xreparent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xconfigure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xconfigure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xgravity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgravity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xresizerequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xresizerequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xconfigurerequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xconfigurerequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xcirculate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcirculate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xcirculaterequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcirculaterequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xproperty as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xproperty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xselectionclear as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselectionclear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xselectionrequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselectionrequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xselection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xcolormap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcolormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xclient as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xclient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xmapping as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xerror as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xerror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xkeymap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xkeymap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xgeneric as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgeneric)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).xcookie as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XEvent>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(pad)
        )
    );
}
impl ::std::fmt::Debug for _XEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_XEvent {{ union }}")
    }
}
pub type XEvent = _XEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XCharStruct {
    pub lbearing: ::std::os::raw::c_short,
    pub rbearing: ::std::os::raw::c_short,
    pub width: ::std::os::raw::c_short,
    pub ascent: ::std::os::raw::c_short,
    pub descent: ::std::os::raw::c_short,
    pub attributes: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_XCharStruct() {
    assert_eq!(
        ::std::mem::size_of::<XCharStruct>(),
        12usize,
        concat!("Size of: ", stringify!(XCharStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<XCharStruct>(),
        2usize,
        concat!("Alignment of ", stringify!(XCharStruct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCharStruct>())).lbearing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(lbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCharStruct>())).rbearing as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(rbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCharStruct>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCharStruct>())).ascent as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCharStruct>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XCharStruct>())).attributes as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XFontProp {
    pub name: Atom,
    pub card32: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_XFontProp() {
    assert_eq!(
        ::std::mem::size_of::<XFontProp>(),
        16usize,
        concat!("Size of: ", stringify!(XFontProp))
    );
    assert_eq!(
        ::std::mem::align_of::<XFontProp>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontProp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontProp>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontProp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontProp>())).card32 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontProp),
            "::",
            stringify!(card32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XFontStruct {
    pub ext_data: *mut XExtData,
    pub fid: Font,
    pub direction: ::std::os::raw::c_uint,
    pub min_char_or_byte2: ::std::os::raw::c_uint,
    pub max_char_or_byte2: ::std::os::raw::c_uint,
    pub min_byte1: ::std::os::raw::c_uint,
    pub max_byte1: ::std::os::raw::c_uint,
    pub all_chars_exist: ::std::os::raw::c_int,
    pub default_char: ::std::os::raw::c_uint,
    pub n_properties: ::std::os::raw::c_int,
    pub properties: *mut XFontProp,
    pub min_bounds: XCharStruct,
    pub max_bounds: XCharStruct,
    pub per_char: *mut XCharStruct,
    pub ascent: ::std::os::raw::c_int,
    pub descent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XFontStruct() {
    assert_eq!(
        ::std::mem::size_of::<XFontStruct>(),
        96usize,
        concat!("Size of: ", stringify!(XFontStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<XFontStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontStruct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).fid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(fid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).direction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).min_char_or_byte2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).max_char_or_byte2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).min_byte1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).max_byte1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).all_chars_exist as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).default_char as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).n_properties as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(n_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).properties as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).min_bounds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).max_bounds as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).per_char as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(per_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).ascent as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontStruct>())).descent as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(descent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XTextItem {
    pub chars: *mut ::std::os::raw::c_char,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem() {
    assert_eq!(
        ::std::mem::size_of::<XTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem))
    );
    assert_eq!(
        ::std::mem::align_of::<XTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem>())).font as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XChar2b {
    pub byte1: ::std::os::raw::c_uchar,
    pub byte2: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_XChar2b() {
    assert_eq!(
        ::std::mem::size_of::<XChar2b>(),
        2usize,
        concat!("Size of: ", stringify!(XChar2b))
    );
    assert_eq!(
        ::std::mem::align_of::<XChar2b>(),
        1usize,
        concat!("Alignment of ", stringify!(XChar2b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XChar2b>())).byte1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XChar2b),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XChar2b>())).byte2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(XChar2b),
            "::",
            stringify!(byte2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XTextItem16 {
    pub chars: *mut XChar2b,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem16() {
    assert_eq!(
        ::std::mem::size_of::<XTextItem16>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem16))
    );
    assert_eq!(
        ::std::mem::align_of::<XTextItem16>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem16>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem16>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem16>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XTextItem16>())).font as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XEDataObject {
    pub display: *mut Display,
    pub gc: GC,
    pub visual: *mut Visual,
    pub screen: *mut Screen,
    pub pixmap_format: *mut ScreenFormat,
    pub font: *mut XFontStruct,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_XEDataObject() {
    assert_eq!(
        ::std::mem::size_of::<XEDataObject>(),
        8usize,
        concat!("Size of: ", stringify!(XEDataObject))
    );
    assert_eq!(
        ::std::mem::align_of::<XEDataObject>(),
        8usize,
        concat!("Alignment of ", stringify!(XEDataObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XEDataObject>())).display as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XEDataObject>())).gc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XEDataObject>())).visual as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XEDataObject>())).screen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XEDataObject>())).pixmap_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(pixmap_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XEDataObject>())).font as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(font)
        )
    );
}
impl ::std::fmt::Debug for XEDataObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "XEDataObject {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XFontSetExtents {
    pub max_ink_extent: XRectangle,
    pub max_logical_extent: XRectangle,
}
#[test]
fn bindgen_test_layout_XFontSetExtents() {
    assert_eq!(
        ::std::mem::size_of::<XFontSetExtents>(),
        16usize,
        concat!("Size of: ", stringify!(XFontSetExtents))
    );
    assert_eq!(
        ::std::mem::align_of::<XFontSetExtents>(),
        2usize,
        concat!("Alignment of ", stringify!(XFontSetExtents))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XFontSetExtents>())).max_ink_extent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontSetExtents),
            "::",
            stringify!(max_ink_extent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<XFontSetExtents>())).max_logical_extent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontSetExtents),
            "::",
            stringify!(max_logical_extent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XOM {
    _unused: [u8; 0],
}
pub type XOM = *mut _XOM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XOC {
    _unused: [u8; 0],
}
pub type XOC = *mut _XOC;
pub type XFontSet = *mut _XOC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmbTextItem {
    pub chars: *mut ::std::os::raw::c_char,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XmbTextItem() {
    assert_eq!(
        ::std::mem::size_of::<XmbTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XmbTextItem))
    );
    assert_eq!(
        ::std::mem::align_of::<XmbTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XmbTextItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmbTextItem>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmbTextItem>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmbTextItem>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmbTextItem>())).font_set as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(font_set)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XwcTextItem {
    pub chars: *mut wchar_t,
    pub nchars: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XwcTextItem() {
    assert_eq!(
        ::std::mem::size_of::<XwcTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XwcTextItem))
    );
    assert_eq!(
        ::std::mem::align_of::<XwcTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XwcTextItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XwcTextItem>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XwcTextItem>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XwcTextItem>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XwcTextItem>())).font_set as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(font_set)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XOMCharSetList {
    pub charset_count: ::std::os::raw::c_int,
    pub charset_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XOMCharSetList() {
    assert_eq!(
        ::std::mem::size_of::<XOMCharSetList>(),
        16usize,
        concat!("Size of: ", stringify!(XOMCharSetList))
    );
    assert_eq!(
        ::std::mem::align_of::<XOMCharSetList>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMCharSetList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XOMCharSetList>())).charset_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMCharSetList),
            "::",
            stringify!(charset_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XOMCharSetList>())).charset_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMCharSetList),
            "::",
            stringify!(charset_list)
        )
    );
}
pub const XOrientation_XOMOrientation_LTR_TTB: XOrientation = 0;
pub const XOrientation_XOMOrientation_RTL_TTB: XOrientation = 1;
pub const XOrientation_XOMOrientation_TTB_LTR: XOrientation = 2;
pub const XOrientation_XOMOrientation_TTB_RTL: XOrientation = 3;
pub const XOrientation_XOMOrientation_Context: XOrientation = 4;
pub type XOrientation = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XOMOrientation {
    pub num_orientation: ::std::os::raw::c_int,
    pub orientation: *mut XOrientation,
}
#[test]
fn bindgen_test_layout_XOMOrientation() {
    assert_eq!(
        ::std::mem::size_of::<XOMOrientation>(),
        16usize,
        concat!("Size of: ", stringify!(XOMOrientation))
    );
    assert_eq!(
        ::std::mem::align_of::<XOMOrientation>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMOrientation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XOMOrientation>())).num_orientation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMOrientation),
            "::",
            stringify!(num_orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XOMOrientation>())).orientation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMOrientation),
            "::",
            stringify!(orientation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XOMFontInfo {
    pub num_font: ::std::os::raw::c_int,
    pub font_struct_list: *mut *mut XFontStruct,
    pub font_name_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XOMFontInfo() {
    assert_eq!(
        ::std::mem::size_of::<XOMFontInfo>(),
        24usize,
        concat!("Size of: ", stringify!(XOMFontInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<XOMFontInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMFontInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XOMFontInfo>())).num_font as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(num_font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XOMFontInfo>())).font_struct_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(font_struct_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XOMFontInfo>())).font_name_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(font_name_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIM {
    _unused: [u8; 0],
}
pub type XIM = *mut _XIM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIC {
    _unused: [u8; 0],
}
pub type XIC = *mut _XIC;
pub type XIMProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: XIM, arg2: XPointer, arg3: XPointer)>;
pub type XICProc = ::std::option::Option<
    unsafe extern "C" fn(arg1: XIC, arg2: XPointer, arg3: XPointer) -> ::std::os::raw::c_int,
>;
pub type XIDProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display, arg2: XPointer, arg3: XPointer)>;
pub type XIMStyle = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XIMStyles {
    pub count_styles: ::std::os::raw::c_ushort,
    pub supported_styles: *mut XIMStyle,
}
#[test]
fn bindgen_test_layout_XIMStyles() {
    assert_eq!(
        ::std::mem::size_of::<XIMStyles>(),
        16usize,
        concat!("Size of: ", stringify!(XIMStyles))
    );
    assert_eq!(
        ::std::mem::align_of::<XIMStyles>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMStyles))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XIMStyles>())).count_styles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMStyles),
            "::",
            stringify!(count_styles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XIMStyles>())).supported_styles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMStyles),
            "::",
            stringify!(supported_styles)
        )
    );
}
pub type XVaNestedList = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XIMCallback {
    pub client_data: XPointer,
    pub callback: XIMProc,
}
#[test]
fn bindgen_test_layout_XIMCallback() {
    assert_eq!(
        ::std::mem::size_of::<XIMCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XIMCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<XIMCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMCallback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XIMCallback>())).client_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMCallback),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XIMCallback>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMCallback),
            "::",
            stringify!(callback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XICCallback {
    pub client_data: XPointer,
    pub callback: XICProc,
}
#[test]
fn bindgen_test_layout_XICCallback() {
    assert_eq!(
        ::std::mem::size_of::<XICCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XICCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<XICCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XICCallback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XICCallback>())).client_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XICCallback),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XICCallback>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XICCallback),
            "::",
            stringify!(callback)
        )
    );
}
pub type XIMFeedback = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMText {
    pub length: ::std::os::raw::c_ushort,
    pub feedback: *mut XIMFeedback,
    pub encoding_is_wchar: ::std::os::raw::c_int,
    pub string: _XIMText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMText__bindgen_ty_1 {
    pub multi_byte: *mut ::std::os::raw::c_char,
    pub wide_char: *mut wchar_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMText__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_XIMText__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMText__bindgen_ty_1>())).multi_byte as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText__bindgen_ty_1),
            "::",
            stringify!(multi_byte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMText__bindgen_ty_1>())).wide_char as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText__bindgen_ty_1),
            "::",
            stringify!(wide_char)
        )
    );
}
impl ::std::fmt::Debug for _XIMText__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_XIMText__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__XIMText() {
    assert_eq!(
        ::std::mem::size_of::<_XIMText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMText))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMText>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMText>())).feedback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(feedback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMText>())).encoding_is_wchar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(encoding_is_wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMText>())).string as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(string)
        )
    );
}
impl ::std::fmt::Debug for _XIMText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_XIMText {{ length: {:?}, feedback: {:?}, encoding_is_wchar: {:?}, string: {:?} }}",
            self.length, self.feedback, self.encoding_is_wchar, self.string
        )
    }
}
pub type XIMText = _XIMText;
pub type XIMPreeditState = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIMPreeditStateNotifyCallbackStruct {
    pub state: XIMPreeditState,
}
#[test]
fn bindgen_test_layout__XIMPreeditStateNotifyCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditStateNotifyCallbackStruct>())).state as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct),
            "::",
            stringify!(state)
        )
    );
}
pub type XIMPreeditStateNotifyCallbackStruct = _XIMPreeditStateNotifyCallbackStruct;
pub type XIMResetState = ::std::os::raw::c_ulong;
pub type XIMStringConversionFeedback = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStringConversionText {
    pub length: ::std::os::raw::c_ushort,
    pub feedback: *mut XIMStringConversionFeedback,
    pub encoding_is_wchar: ::std::os::raw::c_int,
    pub string: _XIMStringConversionText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStringConversionText__bindgen_ty_1 {
    pub mbs: *mut ::std::os::raw::c_char,
    pub wcs: *mut wchar_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMStringConversionText__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionText__bindgen_ty_1>())).mbs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1),
            "::",
            stringify!(mbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionText__bindgen_ty_1>())).wcs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1),
            "::",
            stringify!(wcs)
        )
    );
}
impl ::std::fmt::Debug for _XIMStringConversionText__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_XIMStringConversionText__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__XIMStringConversionText() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStringConversionText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMStringConversionText))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStringConversionText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStringConversionText))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMStringConversionText>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionText>())).feedback as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(feedback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionText>())).encoding_is_wchar as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(encoding_is_wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMStringConversionText>())).string as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(string)
        )
    );
}
impl ::std::fmt::Debug for _XIMStringConversionText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "_XIMStringConversionText {{ length: {:?}, feedback: {:?}, encoding_is_wchar: {:?}, string: {:?} }}" , self . length , self . feedback , self . encoding_is_wchar , self . string )
    }
}
pub type XIMStringConversionText = _XIMStringConversionText;
pub type XIMStringConversionPosition = ::std::os::raw::c_ushort;
pub type XIMStringConversionType = ::std::os::raw::c_ushort;
pub type XIMStringConversionOperation = ::std::os::raw::c_ushort;
pub const XIMCaretDirection_XIMForwardChar: XIMCaretDirection = 0;
pub const XIMCaretDirection_XIMBackwardChar: XIMCaretDirection = 1;
pub const XIMCaretDirection_XIMForwardWord: XIMCaretDirection = 2;
pub const XIMCaretDirection_XIMBackwardWord: XIMCaretDirection = 3;
pub const XIMCaretDirection_XIMCaretUp: XIMCaretDirection = 4;
pub const XIMCaretDirection_XIMCaretDown: XIMCaretDirection = 5;
pub const XIMCaretDirection_XIMNextLine: XIMCaretDirection = 6;
pub const XIMCaretDirection_XIMPreviousLine: XIMCaretDirection = 7;
pub const XIMCaretDirection_XIMLineStart: XIMCaretDirection = 8;
pub const XIMCaretDirection_XIMLineEnd: XIMCaretDirection = 9;
pub const XIMCaretDirection_XIMAbsolutePosition: XIMCaretDirection = 10;
pub const XIMCaretDirection_XIMDontChange: XIMCaretDirection = 11;
pub type XIMCaretDirection = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIMStringConversionCallbackStruct {
    pub position: XIMStringConversionPosition,
    pub direction: XIMCaretDirection,
    pub operation: XIMStringConversionOperation,
    pub factor: ::std::os::raw::c_ushort,
    pub text: *mut XIMStringConversionText,
}
#[test]
fn bindgen_test_layout__XIMStringConversionCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStringConversionCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMStringConversionCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStringConversionCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionCallbackStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionCallbackStruct>())).position as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionCallbackStruct>())).direction as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionCallbackStruct>())).operation as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionCallbackStruct>())).factor as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStringConversionCallbackStruct>())).text as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(text)
        )
    );
}
pub type XIMStringConversionCallbackStruct = _XIMStringConversionCallbackStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIMPreeditDrawCallbackStruct {
    pub caret: ::std::os::raw::c_int,
    pub chg_first: ::std::os::raw::c_int,
    pub chg_length: ::std::os::raw::c_int,
    pub text: *mut XIMText,
}
#[test]
fn bindgen_test_layout__XIMPreeditDrawCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMPreeditDrawCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMPreeditDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditDrawCallbackStruct>())).caret as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(caret)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditDrawCallbackStruct>())).chg_first as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(chg_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditDrawCallbackStruct>())).chg_length as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(chg_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditDrawCallbackStruct>())).text as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(text)
        )
    );
}
pub type XIMPreeditDrawCallbackStruct = _XIMPreeditDrawCallbackStruct;
pub const XIMCaretStyle_XIMIsInvisible: XIMCaretStyle = 0;
pub const XIMCaretStyle_XIMIsPrimary: XIMCaretStyle = 1;
pub const XIMCaretStyle_XIMIsSecondary: XIMCaretStyle = 2;
pub type XIMCaretStyle = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIMPreeditCaretCallbackStruct {
    pub position: ::std::os::raw::c_int,
    pub direction: XIMCaretDirection,
    pub style: XIMCaretStyle,
}
#[test]
fn bindgen_test_layout__XIMPreeditCaretCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMPreeditCaretCallbackStruct>(),
        12usize,
        concat!("Size of: ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMPreeditCaretCallbackStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditCaretCallbackStruct>())).position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditCaretCallbackStruct>())).direction as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMPreeditCaretCallbackStruct>())).style as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(style)
        )
    );
}
pub type XIMPreeditCaretCallbackStruct = _XIMPreeditCaretCallbackStruct;
pub const XIMStatusDataType_XIMTextType: XIMStatusDataType = 0;
pub const XIMStatusDataType_XIMBitmapType: XIMStatusDataType = 1;
pub type XIMStatusDataType = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStatusDrawCallbackStruct {
    pub type_: XIMStatusDataType,
    pub data: _XIMStatusDrawCallbackStruct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStatusDrawCallbackStruct__bindgen_ty_1 {
    pub text: *mut XIMText,
    pub bitmap: Pixmap,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>())).text as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>())).bitmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1),
            "::",
            stringify!(bitmap)
        )
    );
}
impl ::std::fmt::Debug for _XIMStatusDrawCallbackStruct__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_XIMStatusDrawCallbackStruct__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct() {
    assert_eq!(
        ::std::mem::size_of::<_XIMStatusDrawCallbackStruct>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMStatusDrawCallbackStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMStatusDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStatusDrawCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStatusDrawCallbackStruct>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XIMStatusDrawCallbackStruct>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct),
            "::",
            stringify!(data)
        )
    );
}
impl ::std::fmt::Debug for _XIMStatusDrawCallbackStruct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_XIMStatusDrawCallbackStruct {{ type: {:?}, data: {:?} }}",
            self.type_, self.data
        )
    }
}
pub type XIMStatusDrawCallbackStruct = _XIMStatusDrawCallbackStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIMHotKeyTrigger {
    pub keysym: KeySym,
    pub modifier: ::std::os::raw::c_int,
    pub modifier_mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTrigger() {
    assert_eq!(
        ::std::mem::size_of::<_XIMHotKeyTrigger>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTrigger))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMHotKeyTrigger>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTrigger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMHotKeyTrigger>())).keysym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(keysym)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMHotKeyTrigger>())).modifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMHotKeyTrigger>())).modifier_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(modifier_mask)
        )
    );
}
pub type XIMHotKeyTrigger = _XIMHotKeyTrigger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XIMHotKeyTriggers {
    pub num_hot_key: ::std::os::raw::c_int,
    pub key: *mut XIMHotKeyTrigger,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTriggers() {
    assert_eq!(
        ::std::mem::size_of::<_XIMHotKeyTriggers>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTriggers))
    );
    assert_eq!(
        ::std::mem::align_of::<_XIMHotKeyTriggers>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTriggers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMHotKeyTriggers>())).num_hot_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTriggers),
            "::",
            stringify!(num_hot_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XIMHotKeyTriggers>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTriggers),
            "::",
            stringify!(key)
        )
    );
}
pub type XIMHotKeyTriggers = _XIMHotKeyTriggers;
pub type XIMHotKeyState = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XIMValuesList {
    pub count_values: ::std::os::raw::c_ushort,
    pub supported_values: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XIMValuesList() {
    assert_eq!(
        ::std::mem::size_of::<XIMValuesList>(),
        16usize,
        concat!("Size of: ", stringify!(XIMValuesList))
    );
    assert_eq!(
        ::std::mem::align_of::<XIMValuesList>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMValuesList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XIMValuesList>())).count_values as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMValuesList),
            "::",
            stringify!(count_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XIMValuesList>())).supported_values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMValuesList),
            "::",
            stringify!(supported_values)
        )
    );
}
extern "C" {
    pub static mut _Xdebug: ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLoadQueryFont(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut XFontStruct;
}
extern "C" {
    pub fn XQueryFont(arg1: *mut Display, arg2: XID) -> *mut XFontStruct;
}
extern "C" {
    pub fn XGetMotionEvents(
        arg1: *mut Display,
        arg2: Window,
        arg3: Time,
        arg4: Time,
        arg5: *mut ::std::os::raw::c_int,
    ) -> *mut XTimeCoord;
}
extern "C" {
    pub fn XDeleteModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XGetModifierMapping(arg1: *mut Display) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XInsertModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XNewModifiermap(arg1: ::std::os::raw::c_int) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XCreateImage(
        arg1: *mut Display,
        arg2: *mut Visual,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_char,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XInitImage(arg1: *mut XImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_ulong,
        arg8: ::std::os::raw::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XGetSubImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_ulong,
        arg8: ::std::os::raw::c_int,
        arg9: *mut XImage,
        arg10: ::std::os::raw::c_int,
        arg11: ::std::os::raw::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XOpenDisplay(arg1: *const ::std::os::raw::c_char) -> *mut Display;
}
extern "C" {
    pub fn XrmInitialize();
}
extern "C" {
    pub fn XFetchBytes(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XFetchBuffer(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetAtomName(arg1: *mut Display, arg2: Atom) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetAtomNames(
        arg1: *mut Display,
        arg2: *mut Atom,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetDefault(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayName(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XKeysymToString(arg1: KeySym) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XSynchronize(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Display,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn XSetAfterFunction(
        arg1: *mut Display,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Display) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Display,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut Display) -> ::std::os::raw::c_int,
            >,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn XInternAtom(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> Atom;
}
extern "C" {
    pub fn XInternAtoms(
        arg1: *mut Display,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut Atom,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyColormapAndFree(arg1: *mut Display, arg2: Colormap) -> Colormap;
}
extern "C" {
    pub fn XCreateColormap(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Visual,
        arg4: ::std::os::raw::c_int,
    ) -> Colormap;
}
extern "C" {
    pub fn XCreatePixmapCursor(
        arg1: *mut Display,
        arg2: Pixmap,
        arg3: Pixmap,
        arg4: *mut XColor,
        arg5: *mut XColor,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateGlyphCursor(
        arg1: *mut Display,
        arg2: Font,
        arg3: Font,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *const XColor,
        arg7: *const XColor,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateFontCursor(arg1: *mut Display, arg2: ::std::os::raw::c_uint) -> Cursor;
}
extern "C" {
    pub fn XLoadFont(arg1: *mut Display, arg2: *const ::std::os::raw::c_char) -> Font;
}
extern "C" {
    pub fn XCreateGC(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XGCValues,
    ) -> GC;
}
extern "C" {
    pub fn XGContextFromGC(arg1: GC) -> GContext;
}
extern "C" {
    pub fn XFlushGC(arg1: *mut Display, arg2: GC);
}
extern "C" {
    pub fn XCreatePixmap(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateBitmapFromData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreatePixmapFromBitmapData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_ulong,
        arg7: ::std::os::raw::c_ulong,
        arg8: ::std::os::raw::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateSimpleWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_ulong,
        arg9: ::std::os::raw::c_ulong,
    ) -> Window;
}
extern "C" {
    pub fn XGetSelectionOwner(arg1: *mut Display, arg2: Atom) -> Window;
}
extern "C" {
    pub fn XCreateWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_uint,
        arg10: *mut Visual,
        arg11: ::std::os::raw::c_ulong,
        arg12: *mut XSetWindowAttributes,
    ) -> Window;
}
extern "C" {
    pub fn XListInstalledColormaps(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut Colormap;
}
extern "C" {
    pub fn XListFonts(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XListFontsWithInfo(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut *mut XFontStruct,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetFontPath(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XListExtensions(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XListProperties(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut Atom;
}
extern "C" {
    pub fn XListHosts(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut XHostAddress;
}
extern "C" {
    pub fn XKeycodeToKeysym(
        arg1: *mut Display,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
    ) -> KeySym;
}
extern "C" {
    pub fn XLookupKeysym(arg1: *mut XKeyEvent, arg2: ::std::os::raw::c_int) -> KeySym;
}
extern "C" {
    pub fn XGetKeyboardMapping(
        arg1: *mut Display,
        arg2: KeyCode,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut KeySym;
}
extern "C" {
    pub fn XStringToKeysym(arg1: *const ::std::os::raw::c_char) -> KeySym;
}
extern "C" {
    pub fn XMaxRequestSize(arg1: *mut Display) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn XExtendedMaxRequestSize(arg1: *mut Display) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn XResourceManagerString(arg1: *mut Display) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XScreenResourceString(arg1: *mut Screen) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayMotionBufferSize(arg1: *mut Display) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XVisualIDFromVisual(arg1: *mut Visual) -> VisualID;
}
extern "C" {
    pub fn XInitThreads() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XUnlockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XInitExtension(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut XExtCodes;
}
extern "C" {
    pub fn XAddExtension(arg1: *mut Display) -> *mut XExtCodes;
}
extern "C" {
    pub fn XFindOnExtensionList(
        arg1: *mut *mut XExtData,
        arg2: ::std::os::raw::c_int,
    ) -> *mut XExtData;
}
extern "C" {
    pub fn XEHeadOfExtensionList(arg1: XEDataObject) -> *mut *mut XExtData;
}
extern "C" {
    pub fn XRootWindow(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> Window;
}
extern "C" {
    pub fn XDefaultRootWindow(arg1: *mut Display) -> Window;
}
extern "C" {
    pub fn XRootWindowOfScreen(arg1: *mut Screen) -> Window;
}
extern "C" {
    pub fn XDefaultVisual(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultVisualOfScreen(arg1: *mut Screen) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultGC(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> GC;
}
extern "C" {
    pub fn XDefaultGCOfScreen(arg1: *mut Screen) -> GC;
}
extern "C" {
    pub fn XBlackPixel(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XWhitePixel(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XAllPlanes() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XBlackPixelOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XWhitePixelOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XNextRequest(arg1: *mut Display) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XLastKnownRequestProcessed(arg1: *mut Display) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn XServerVendor(arg1: *mut Display) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayString(arg1: *mut Display) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDefaultColormap(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> Colormap;
}
extern "C" {
    pub fn XDefaultColormapOfScreen(arg1: *mut Screen) -> Colormap;
}
extern "C" {
    pub fn XDisplayOfScreen(arg1: *mut Screen) -> *mut Display;
}
extern "C" {
    pub fn XScreenOfDisplay(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> *mut Screen;
}
extern "C" {
    pub fn XDefaultScreenOfDisplay(arg1: *mut Display) -> *mut Screen;
}
extern "C" {
    pub fn XEventMaskOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn XScreenNumberOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
pub type XErrorHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut Display, arg2: *mut XErrorEvent) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn XSetErrorHandler(arg1: XErrorHandler) -> XErrorHandler;
}
pub type XIOErrorHandler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn XSetIOErrorHandler(arg1: XIOErrorHandler) -> XIOErrorHandler;
}
extern "C" {
    pub fn XListPixmapFormats(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut XPixmapFormatValues;
}
extern "C" {
    pub fn XListDepths(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReconfigureWMWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut XWindowChanges,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Atom,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XIconifyWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWithdrawWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Window,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeStringList(arg1: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn XSetTransientForHint(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XActivateScreenSaver(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddHost(arg1: *mut Display, arg2: *mut XHostAddress) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddHosts(
        arg1: *mut Display,
        arg2: *mut XHostAddress,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddToExtensionList(
        arg1: *mut *mut _XExtData,
        arg2: *mut XExtData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAddToSaveSet(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocColorCells(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_ulong,
        arg7: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocColorPlanes(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: *mut ::std::os::raw::c_ulong,
        arg10: *mut ::std::os::raw::c_ulong,
        arg11: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllocNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAllowEvents(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAutoRepeatOff(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XAutoRepeatOn(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBell(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBitmapBitOrder(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBitmapPad(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBitmapUnit(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCellsOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeActivePointerGrab(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_uint,
        arg3: Cursor,
        arg4: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeGC(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XGCValues,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeKeyboardControl(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut XKeyboardControl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeKeyboardMapping(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut KeySym,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangePointerControl(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: Atom,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_uchar,
        arg8: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeSaveSet(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XChangeWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XSetWindowAttributes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckMaskEvent(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_long,
        arg3: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckTypedEvent(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckTypedWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCheckWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_long,
        arg4: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCirculateSubwindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsDown(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsUp(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XClearArea(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XClearWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCloseDisplay(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XConfigureWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_uint,
        arg4: *mut XWindowChanges,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XConnectionNumber(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XConvertSelection(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Atom,
        arg4: Atom,
        arg5: Window,
        arg6: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyArea(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyGC(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: GC,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XCopyPlane(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
        arg11: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefaultDepth(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefaultDepthOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefaultScreen(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDefineCursor(arg1: *mut Display, arg2: Window, arg3: Cursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDeleteProperty(arg1: *mut Display, arg2: Window, arg3: Atom) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDestroyWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDestroySubwindows(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDoesBackingStore(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDoesSaveUnders(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisableAccessControl(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayCells(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayHeight(arg1: *mut Display, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayHeightMM(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayKeycodes(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayPlanes(arg1: *mut Display, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayWidth(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDisplayWidthMM(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const ::std::os::raw::c_char,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawImageString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const XChar2b,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawLine(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawLines(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawPoint(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawPoints(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawSegments(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XSegment,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const ::std::os::raw::c_char,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *const XChar2b,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XTextItem,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDrawText16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XTextItem16,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XEnableAccessControl(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XEventsQueued(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFetchName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillPolygon(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFillRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFlush(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XForceScreenSaver(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFree(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeColormap(arg1: *mut Display, arg2: Colormap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeCursor(arg1: *mut Display, arg2: Cursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeExtensionList(arg1: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFont(arg1: *mut Display, arg2: *mut XFontStruct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFontInfo(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut XFontStruct,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFontNames(arg1: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeFontPath(arg1: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeGC(arg1: *mut Display, arg2: GC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeModifiermap(arg1: *mut XModifierKeymap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreePixmap(arg1: *mut Display, arg2: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGeometry(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
        arg10: *mut ::std::os::raw::c_int,
        arg11: *mut ::std::os::raw::c_int,
        arg12: *mut ::std::os::raw::c_int,
        arg13: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetErrorDatabaseText(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetErrorText(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetFontProperty(
        arg1: *mut XFontStruct,
        arg2: Atom,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetGCValues(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut XGCValues,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetGeometry(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut Window,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: *mut ::std::os::raw::c_uint,
        arg9: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetIconName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetInputFocus(
        arg1: *mut Display,
        arg2: *mut Window,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetKeyboardControl(
        arg1: *mut Display,
        arg2: *mut XKeyboardState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetPointerControl(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetPointerMapping(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetScreenSaver(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetTransientForHint(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWindowProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: ::std::os::raw::c_long,
        arg5: ::std::os::raw::c_long,
        arg6: ::std::os::raw::c_int,
        arg7: Atom,
        arg8: *mut Atom,
        arg9: *mut ::std::os::raw::c_int,
        arg10: *mut ::std::os::raw::c_ulong,
        arg11: *mut ::std::os::raw::c_ulong,
        arg12: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut XWindowAttributes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabButton(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: Window,
        arg10: Cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabKey(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabKeyboard(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: Window,
        arg8: Cursor,
        arg9: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGrabServer(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XHeightMMOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XHeightOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XImageByteOrder(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XInstallColormap(arg1: *mut Display, arg2: Colormap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XKeysymToKeycode(arg1: *mut Display, arg2: KeySym) -> KeyCode;
}
extern "C" {
    pub fn XKillClient(arg1: *mut Display, arg2: XID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLookupColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLowerWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMapRaised(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMapSubwindows(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMapWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMaskEvent(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_long,
        arg3: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMaxCmapsOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMinCmapsOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMoveResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XMoveWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XNextEvent(arg1: *mut Display, arg2: *mut XEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XNoOp(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XParseColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XParseGeometry(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPeekEvent(arg1: *mut Display, arg2: *mut XEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPeekIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPending(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPlanesOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XProtocolRevision(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XProtocolVersion(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPutBackEvent(arg1: *mut Display, arg2: *mut XEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XPutImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XImage,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_uint,
        arg10: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQLength(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestCursor(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestSize(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: Drawable,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestStipple(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryBestTile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryExtension(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryKeymap(
        arg1: *mut Display,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut ::std::os::raw::c_int,
        arg9: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryTextExtents(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryTextExtents16(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const XChar2b,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XQueryTree(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut *mut Window,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRaiseWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReadBitmapFile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut Pixmap,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReadBitmapFileData(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_uint,
        arg3: *mut ::std::os::raw::c_uint,
        arg4: *mut *mut ::std::os::raw::c_uchar,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRebindKeysym(
        arg1: *mut Display,
        arg2: KeySym,
        arg3: *mut KeySym,
        arg4: ::std::os::raw::c_int,
        arg5: *const ::std::os::raw::c_uchar,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRecolorCursor(
        arg1: *mut Display,
        arg2: Cursor,
        arg3: *mut XColor,
        arg4: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRefreshKeyboardMapping(arg1: *mut XMappingEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveFromSaveSet(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveHost(arg1: *mut Display, arg2: *mut XHostAddress) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveHosts(
        arg1: *mut Display,
        arg2: *mut XHostAddress,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XReparentWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XResetScreenSaver(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRestackWindows(
        arg1: *mut Display,
        arg2: *mut Window,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRotateBuffers(arg1: *mut Display, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRotateWindowProperties(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XScreenCount(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSelectInput(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSendEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_long,
        arg5: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetAccessControl(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetArcMode(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetBackground(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetClipMask(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetClipOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetClipRectangles(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetCloseDownMode(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetDashes(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFillRule(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFillStyle(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFont(arg1: *mut Display, arg2: GC, arg3: Font) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFontPath(
        arg1: *mut Display,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetForeground(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetFunction(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetGraphicsExposures(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetIconName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetInputFocus(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_int,
        arg4: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetLineAttributes(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_uint,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetModifierMapping(
        arg1: *mut Display,
        arg2: *mut XModifierKeymap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetPlaneMask(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetPointerMapping(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetScreenSaver(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetSelectionOwner(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Window,
        arg4: Time,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetState(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetStipple(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetSubwindowMode(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetTSOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetTile(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBackground(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBackgroundPixmap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Pixmap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBorder(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBorderPixmap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Pixmap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowBorderWidth(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetWindowColormap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Colormap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreBuffer(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreBytes(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XStoreNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSync(arg1: *mut Display, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextExtents(
        arg1: *mut XFontStruct,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextExtents16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut XCharStruct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextWidth(
        arg1: *mut XFontStruct,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTextWidth16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XTranslateCoordinates(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUndefineCursor(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabButton(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabKey(
        arg1: *mut Display,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
        arg4: Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabKeyboard(arg1: *mut Display, arg2: Time) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabPointer(arg1: *mut Display, arg2: Time) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUngrabServer(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUninstallColormap(arg1: *mut Display, arg2: Colormap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnloadFont(arg1: *mut Display, arg2: Font) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnmapSubwindows(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnmapWindow(arg1: *mut Display, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XVendorRelease(arg1: *mut Display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWarpPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWidthMMOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWidthOfScreen(arg1: *mut Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: ::std::os::raw::c_long,
        arg4: *mut XEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XWriteBitmapFile(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: Pixmap,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSupportsLocale() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetLocaleModifiers(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XOpenOM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> XOM;
}
extern "C" {
    pub fn XCloseOM(arg1: XOM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XSetOMValues(arg1: XOM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetOMValues(arg1: XOM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayOfOM(arg1: XOM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfOM(arg1: XOM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XCreateOC(arg1: XOM, ...) -> XOC;
}
extern "C" {
    pub fn XDestroyOC(arg1: XOC);
}
extern "C" {
    pub fn XOMOfOC(arg1: XOC) -> XOM;
}
extern "C" {
    pub fn XSetOCValues(arg1: XOC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetOCValues(arg1: XOC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XCreateFontSet(
        arg1: *mut Display,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut *mut ::std::os::raw::c_char,
    ) -> XFontSet;
}
extern "C" {
    pub fn XFreeFontSet(arg1: *mut Display, arg2: XFontSet);
}
extern "C" {
    pub fn XFontsOfFontSet(
        arg1: XFontSet,
        arg2: *mut *mut *mut XFontStruct,
        arg3: *mut *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XBaseFontNameListOfFontSet(arg1: XFontSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XLocaleOfFontSet(arg1: XFontSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XContextDependentDrawing(arg1: XFontSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XDirectionalDependentDrawing(arg1: XFontSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XContextualDrawing(arg1: XFontSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XExtentsOfFontSet(arg1: XFontSet) -> *mut XFontSetExtents;
}
extern "C" {
    pub fn XmbTextEscapement(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcTextEscapement(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8TextEscapement(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbTextExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcTextExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8TextExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8TextPerCharExtents(
        arg1: XFontSet,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: ::std::os::raw::c_int,
        arg7: *mut ::std::os::raw::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XmbTextItem,
        arg7: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XwcDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XwcTextItem,
        arg7: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut XmbTextItem,
        arg7: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XmbDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XwcDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const wchar_t,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XmbDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XwcDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const wchar_t,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
        arg7: *const ::std::os::raw::c_char,
        arg8: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn XOpenIM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> XIM;
}
extern "C" {
    pub fn XCloseIM(arg1: XIM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetIMValues(arg1: XIM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XSetIMValues(arg1: XIM, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XDisplayOfIM(arg1: XIM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfIM(arg1: XIM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XCreateIC(arg1: XIM, ...) -> XIC;
}
extern "C" {
    pub fn XDestroyIC(arg1: XIC);
}
extern "C" {
    pub fn XSetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XUnsetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XwcResetIC(arg1: XIC) -> *mut wchar_t;
}
extern "C" {
    pub fn XmbResetIC(arg1: XIC) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Xutf8ResetIC(arg1: XIC) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XSetICValues(arg1: XIC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XGetICValues(arg1: XIC, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XIMOfIC(arg1: XIC) -> XIM;
}
extern "C" {
    pub fn XFilterEvent(arg1: *mut XEvent, arg2: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XmbLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut KeySym,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XwcLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut wchar_t,
        arg4: ::std::os::raw::c_int,
        arg5: *mut KeySym,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Xutf8LookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut KeySym,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XVaCreateNestedList(arg1: ::std::os::raw::c_int, ...) -> XVaNestedList;
}
extern "C" {
    pub fn XRegisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XUnregisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> ::std::os::raw::c_int;
}
pub type XConnectionWatchProc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut Display,
        arg2: XPointer,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut XPointer,
    ),
>;
extern "C" {
    pub fn XInternalConnectionNumbers(
        arg1: *mut Display,
        arg2: *mut *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XProcessInternalConnection(arg1: *mut Display, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XAddConnectionWatch(
        arg1: *mut Display,
        arg2: XConnectionWatchProc,
        arg3: XPointer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XRemoveConnectionWatch(arg1: *mut Display, arg2: XConnectionWatchProc, arg3: XPointer);
}
extern "C" {
    pub fn XSetAuthorization(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _Xmbtowc(
        arg1: *mut wchar_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Xwctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XGetEventData(
        arg1: *mut Display,
        arg2: *mut XGenericEventCookie,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XFreeEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie);
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " \\brief A boolean value, holding \\ref VDP_TRUE or \\ref"]
#[doc = " VDP_FALSE."]
pub type VdpBool = ::std::os::raw::c_int;
#[doc = " \\brief The set of all chroma formats for \\ref VdpVideoSurface"]
#[doc = " \"VdpVideoSurface\"s."]
pub type VdpChromaType = u32;
#[doc = " \\brief The set of all known YCbCr surface formats."]
pub type VdpYCbCrFormat = u32;
#[doc = " \\brief  The set of all known RGB surface formats."]
pub type VdpRGBAFormat = u32;
#[doc = " \\brief  The set of all known indexed surface formats."]
pub type VdpIndexedFormat = u32;
#[doc = " \\brief A location within a surface."]
#[doc = ""]
#[doc = " The VDPAU co-ordinate system has its origin at the top-left"]
#[doc = " of a surface, with x and y components increasing right and"]
#[doc = " down."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpPoint {
    #[doc = " X co-ordinate."]
    pub x: u32,
    #[doc = " Y co-ordinate."]
    pub y: u32,
}
#[test]
fn bindgen_test_layout_VdpPoint() {
    assert_eq!(
        ::std::mem::size_of::<VdpPoint>(),
        8usize,
        concat!("Size of: ", stringify!(VdpPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPoint),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief A rectangular region of a surface."]
#[doc = ""]
#[doc = " The co-ordinates are top-left inclusive, bottom-right"]
#[doc = " exclusive."]
#[doc = ""]
#[doc = " The VDPAU co-ordinate system has its origin at the top-left"]
#[doc = " of a surface, with x and y components increasing right and"]
#[doc = " down."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpRect {
    #[doc = " Left X co-ordinate. Inclusive."]
    pub x0: u32,
    #[doc = " Top Y co-ordinate. Inclusive."]
    pub y0: u32,
    #[doc = " Right X co-ordinate. Exclusive."]
    pub x1: u32,
    #[doc = " Bottom Y co-ordinate. Exclusive."]
    pub y1: u32,
}
#[test]
fn bindgen_test_layout_VdpRect() {
    assert_eq!(
        ::std::mem::size_of::<VdpRect>(),
        16usize,
        concat!("Size of: ", stringify!(VdpRect))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpRect>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).y0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(y0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).x1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpRect>())).y1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpRect),
            "::",
            stringify!(y1)
        )
    );
}
#[doc = " A constant RGBA color."]
#[doc = ""]
#[doc = " Note that the components are stored as float values in the"]
#[doc = " range 0.0...1.0 rather than format-specific integer values."]
#[doc = " This allows VdpColor values to be independent from the exact"]
#[doc = " surface format(s) in use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpColor {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
#[test]
fn bindgen_test_layout_VdpColor() {
    assert_eq!(
        ::std::mem::size_of::<VdpColor>(),
        16usize,
        concat!("Size of: ", stringify!(VdpColor))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpColor>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpColor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).green as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpColor>())).alpha as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpColor),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " The operation completed successfully; no error."]
pub const VdpStatus_VDP_STATUS_OK: VdpStatus = 0;
#[doc = " No backend implementation could be loaded."]
pub const VdpStatus_VDP_STATUS_NO_IMPLEMENTATION: VdpStatus = 1;
#[doc = " The display was preempted, or a fatal error occurred."]
#[doc = ""]
#[doc = " The application must re-initialize VDPAU."]
pub const VdpStatus_VDP_STATUS_DISPLAY_PREEMPTED: VdpStatus = 2;
#[doc = " An invalid handle value was provided."]
#[doc = ""]
#[doc = " Either the handle does not exist at all, or refers to an object of an"]
#[doc = " incorrect type."]
pub const VdpStatus_VDP_STATUS_INVALID_HANDLE: VdpStatus = 3;
#[doc = " An invalid pointer was provided."]
#[doc = ""]
#[doc = " Typically, this means that a NULL pointer was provided for an \"output\""]
#[doc = " parameter."]
pub const VdpStatus_VDP_STATUS_INVALID_POINTER: VdpStatus = 4;
#[doc = " An invalid/unsupported \\ref VdpChromaType value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_CHROMA_TYPE: VdpStatus = 5;
#[doc = " An invalid/unsupported \\ref VdpYCbCrFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_Y_CB_CR_FORMAT: VdpStatus = 6;
#[doc = " An invalid/unsupported \\ref VdpRGBAFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_RGBA_FORMAT: VdpStatus = 7;
#[doc = " An invalid/unsupported \\ref VdpIndexedFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_INDEXED_FORMAT: VdpStatus = 8;
#[doc = " An invalid/unsupported \\ref VdpColorStandard value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_COLOR_STANDARD: VdpStatus = 9;
#[doc = " An invalid/unsupported \\ref VdpColorTableFormat value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_COLOR_TABLE_FORMAT: VdpStatus = 10;
#[doc = " An invalid/unsupported \\ref VdpOutputSurfaceRenderBlendFactor value was"]
#[doc = " supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_BLEND_FACTOR: VdpStatus = 11;
#[doc = " An invalid/unsupported \\ref VdpOutputSurfaceRenderBlendEquation value"]
#[doc = " was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_BLEND_EQUATION: VdpStatus = 12;
#[doc = " An invalid/unsupported flag value/combination was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_FLAG: VdpStatus = 13;
#[doc = " An invalid/unsupported \\ref VdpDecoderProfile value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_DECODER_PROFILE: VdpStatus = 14;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerFeature value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_FEATURE: VdpStatus = 15;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerParameter value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_PARAMETER: VdpStatus = 16;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerAttribute value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_ATTRIBUTE: VdpStatus = 17;
#[doc = " An invalid/unsupported \\ref VdpVideoMixerPictureStructure value was"]
#[doc = " supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_VIDEO_MIXER_PICTURE_STRUCTURE: VdpStatus = 18;
#[doc = " An invalid/unsupported \\ref VdpFuncId value was supplied."]
pub const VdpStatus_VDP_STATUS_INVALID_FUNC_ID: VdpStatus = 19;
#[doc = " The size of a supplied object does not match the object it is being"]
#[doc = " used with."]
#[doc = ""]
#[doc = " For example, a \\ref VdpVideoMixer \"VdpVideoMixer\" is configured to"]
#[doc = " process \\ref VdpVideoSurface \"VdpVideoSurface\" objects of a specific"]
#[doc = " size. If presented with a \\ref VdpVideoSurface \"VdpVideoSurface\" of a"]
#[doc = " different size, this error will be raised."]
pub const VdpStatus_VDP_STATUS_INVALID_SIZE: VdpStatus = 20;
#[doc = " An invalid/unsupported value was supplied."]
#[doc = ""]
#[doc = " This is a catch-all error code for values of type other than those"]
#[doc = " with a specific error code."]
pub const VdpStatus_VDP_STATUS_INVALID_VALUE: VdpStatus = 21;
#[doc = " An invalid/unsupported structure version was specified in a versioned"]
#[doc = " structure. This implies that the implementation is older than the"]
#[doc = " header file the application was built against."]
pub const VdpStatus_VDP_STATUS_INVALID_STRUCT_VERSION: VdpStatus = 22;
#[doc = " The system does not have enough resources to complete the requested"]
#[doc = " operation at this time."]
pub const VdpStatus_VDP_STATUS_RESOURCES: VdpStatus = 23;
#[doc = " The set of handles supplied are not all related to the same VdpDevice."]
#[doc = ""]
#[doc = " When performing operations that operate on multiple surfaces, such as"]
#[doc = " \\ref  VdpOutputSurfaceRenderOutputSurface or \\ref VdpVideoMixerRender,"]
#[doc = " all supplied surfaces must have been created within the context of the"]
#[doc = " same \\ref VdpDevice \"VdpDevice\" object. This error is raised if they were"]
#[doc = " not."]
pub const VdpStatus_VDP_STATUS_HANDLE_DEVICE_MISMATCH: VdpStatus = 24;
#[doc = " A catch-all error, used when no other error code applies."]
pub const VdpStatus_VDP_STATUS_ERROR: VdpStatus = 25;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The set of all possible error codes."]
pub type VdpStatus = u32;
#[doc = " \\brief Retrieve a string describing an error code."]
#[doc = " \\param[in] status The error code."]
#[doc = " \\return A pointer to the string. Note that this is a"]
#[doc = "       statically allocated read-only string. As such, the"]
#[doc = "       application must not free the returned pointer. The"]
#[doc = "       pointer is valid as long as the VDPAU implementation is"]
#[doc = "       present within the application's address space."]
pub type VdpGetErrorString =
    ::std::option::Option<unsafe extern "C" fn(status: VdpStatus) -> *const ::std::os::raw::c_char>;
#[doc = " \\brief Retrieve the VDPAU version implemented by the backend."]
#[doc = " \\param[out] api_version The API version."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpGetApiVersion =
    ::std::option::Option<unsafe extern "C" fn(api_version: *mut u32) -> VdpStatus>;
#[doc = " \\brief Retrieve an implementation-specific string description"]
#[doc = "        of the implementation. This typically includes detailed version"]
#[doc = "        information."]
#[doc = " \\param[out] information_string A pointer to the information"]
#[doc = "       string. Note that this is a statically allocated"]
#[doc = "       read-only string. As such, the application must not"]
#[doc = "       free the returned pointer. The pointer is valid as long"]
#[doc = "       as the implementation is present within the"]
#[doc = "       application's address space."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Note that the returned string is useful for information"]
#[doc = " reporting. It is not intended that the application should"]
#[doc = " parse this string in order to determine any information about"]
#[doc = " the implementation."]
pub type VdpGetInformationString = ::std::option::Option<
    unsafe extern "C" fn(information_string: *mut *const ::std::os::raw::c_char) -> VdpStatus,
>;
#[doc = " \\brief  An opaque handle representing a VdpDevice object."]
pub type VdpDevice = u32;
#[doc = " \\brief Destroy a VdpDevice."]
#[doc = " \\param[in] device The device to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDeviceDestroy =
    ::std::option::Option<unsafe extern "C" fn(device: VdpDevice) -> VdpStatus>;
#[doc = " \\brief Storage for a color space conversion matrix."]
#[doc = ""]
#[doc = " Note that the application may choose to construct the matrix"]
#[doc = " content by either:"]
#[doc = " - Directly filling in the fields of the CSC matrix"]
#[doc = " - Using the \\ref VdpGenerateCSCMatrix helper function."]
#[doc = ""]
#[doc = " The color space conversion equation is as follows:"]
#[doc = ""]
#[doc = " \\f["]
#[doc = " \\left( \\begin{array}{c} R \\\\ G \\\\ B \\end{array} \\right)"]
#[doc = " ="]
#[doc = " \\left( \\begin{array}{cccc}"]
#[doc = " m_{0,0} & m_{0,1} & m_{0,2} & m_{0,3} \\\\"]
#[doc = " m_{1,0} & m_{1,1} & m_{1,2} & m_{1,3} \\\\"]
#[doc = " m_{2,0} & m_{2,1} & m_{2,2} & m_{2,3}"]
#[doc = " \\end{array}"]
#[doc = " \\right)"]
#[doc = " *"]
#[doc = " \\left( \\begin{array}{c} Y \\\\ Cb \\\\ Cr \\\\ 1.0 \\end{array}"]
#[doc = "      \\right)"]
#[doc = " \\f]"]
pub type VdpCSCMatrix = [[f32; 4usize]; 3usize];
#[doc = " \\brief Procamp operation parameterization data."]
#[doc = ""]
#[doc = " When performing a color space conversion operation, various"]
#[doc = " adjustments can be performed at the same time, such as"]
#[doc = " brightness and contrast. This structure defines the level of"]
#[doc = " adjustments to make."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpProcamp {
    #[doc = " This field must be filled with VDP_PROCAMP_VERSION"]
    pub struct_version: u32,
    #[doc = " Brightness adjustment amount. A value clamped between"]
    #[doc = " -1.0 and 1.0. 0.0 represents no modification."]
    pub brightness: f32,
    #[doc = " Contrast adjustment amount. A value clamped between"]
    #[doc = " 0.0 and 10.0. 1.0 represents no modification."]
    pub contrast: f32,
    #[doc = " Saturation adjustment amount. A value clamped between 0.0 and"]
    #[doc = " 10.0. 1.0 represents no modification."]
    pub saturation: f32,
    #[doc = " Hue adjustment amount. A value clamped between"]
    #[doc = " -PI and PI. 0.0 represents no modification."]
    pub hue: f32,
}
#[test]
fn bindgen_test_layout_VdpProcamp() {
    assert_eq!(
        ::std::mem::size_of::<VdpProcamp>(),
        20usize,
        concat!("Size of: ", stringify!(VdpProcamp))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpProcamp>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpProcamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).struct_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).brightness as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(brightness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).contrast as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(contrast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).saturation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(saturation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpProcamp>())).hue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpProcamp),
            "::",
            stringify!(hue)
        )
    );
}
#[doc = " \\brief YCbCr color space specification."]
#[doc = ""]
#[doc = " A number of YCbCr color spaces exist. This enumeration"]
#[doc = " defines the specifications known to VDPAU."]
pub type VdpColorStandard = u32;
#[doc = " \\brief Generate a color space conversion matrix"]
#[doc = " \\param[in] procamp The procamp adjustments to make. If NULL,"]
#[doc = "        no adjustments will be made."]
#[doc = " \\param[in] standard The YCbCr color space to convert from."]
#[doc = " \\param[out] csc_matrix The CSC matrix to initialize."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpGenerateCSCMatrix = ::std::option::Option<
    unsafe extern "C" fn(
        procamp: *mut VdpProcamp,
        standard: VdpColorStandard,
        csc_matrix: *mut VdpCSCMatrix,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpVideoSurface"]
#[doc = "        capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_chroma_type The type of chroma type for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this chroma type supported?"]
#[doc = " \\param[out] max_width The maximum supported surface width for"]
#[doc = "       this chroma type."]
#[doc = " \\param[out] max_height The maximum supported surface height"]
#[doc = "       for this chroma type."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_chroma_type: VdpChromaType,
        is_supported: *mut VdpBool,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpVideoSurface"]
#[doc = "        GetBits/PutBits capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_chroma_type The type of chroma type for"]
#[doc = "       which information is requested."]
#[doc = " \\param[in] bits_ycbcr_format The format of application \"bits\""]
#[doc = "       buffer for which information is requested."]
#[doc = " \\param[out] is_supported Is this chroma type supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceQueryGetPutBitsYCbCrCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_chroma_type: VdpChromaType,
        bits_ycbcr_format: VdpYCbCrFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpVideoSurface"]
#[doc = "        object."]
pub type VdpVideoSurface = u32;
#[doc = " \\brief Create a VdpVideoSurface."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] chroma_type The chroma type of the new surface."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[out] surface The new surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The memory backing the surface may not be initialized during"]
#[doc = " creation. Applications are expected to initialize any region"]
#[doc = " that they use, via \\ref VdpDecoderRender or \\ref"]
#[doc = " VdpVideoSurfacePutBitsYCbCr."]
#[doc = ""]
#[doc = " Note that certain widths/heights are impossible for specific values of"]
#[doc = " chroma_type. For example, the definition of VDP_CHROMA_TYPE_420 implies"]
#[doc = " that the width must be even, since each single chroma sample covers two"]
#[doc = " luma samples horizontally. A similar argument applies to surface heights,"]
#[doc = " although doubly so, since interlaced pictures must be supported; each"]
#[doc = " field's height must itself be a multiple of 2. Hence the overall surface's"]
#[doc = " height must be a multiple of 4."]
#[doc = ""]
#[doc = " Similar rules apply to other chroma_type values."]
#[doc = ""]
#[doc = " Implementations may also impose additional restrictions on the surface"]
#[doc = " sizes they support, potentially requiring additional rounding of actual"]
#[doc = " surface sizes."]
#[doc = ""]
#[doc = " In most cases, this is not an issue, since:"]
#[doc = " - Video streams are encoded as an array of macro-blocks, which typically"]
#[doc = "   have larger size alignment requirements than video surfaces do."]
#[doc = " - APIs such as \\ref VdpVideoMixerRender allow specification of a sub-region"]
#[doc = "   of the surface to read, which allows the padding data to be clipped away."]
#[doc = ""]
#[doc = " However, other APIs such as \\ref VdpVideoSurfaceGetBitsYCbCr and"]
#[doc = " \\ref VdpVideoSurfacePutBitsYCbCr do not allow a sub-region to be specified,"]
#[doc = " and always operate on surface size that was actually allocated, rather"]
#[doc = " than the surface size that was requested. In this case, applications need"]
#[doc = " to be aware of the actual surface size, in order to allocate appropriately"]
#[doc = " sized buffers for the get-/put-bits operations."]
#[doc = ""]
#[doc = " For this reason, applications may need to call"]
#[doc = " \\ref VdpVideoSurfaceGetParameters after creation, in order to retrieve the"]
#[doc = " actual surface size."]
pub type VdpVideoSurfaceCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        chroma_type: VdpChromaType,
        width: u32,
        height: u32,
        surface: *mut VdpVideoSurface,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpVideoSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceDestroy =
    ::std::option::Option<unsafe extern "C" fn(surface: VdpVideoSurface) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpVideoSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] chroma_type The chroma type of the surface."]
#[doc = " \\param[out] width The width of the surface."]
#[doc = " \\param[out] height The height of the surface."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpVideoSurface,
        chroma_type: *mut VdpChromaType,
        width: *mut u32,
        height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from a VdpVideoSurface to application"]
#[doc = "        memory in a specified YCbCr format."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] destination_ycbcr_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] destination_data Pointers to the application data"]
#[doc = "       buffers into which the image data will be written. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfaceGetBitsYCbCr = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpVideoSurface,
        destination_ycbcr_format: VdpYCbCrFormat,
        destination_data: *const *mut ::std::os::raw::c_void,
        destination_pitches: *const u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in a specific"]
#[doc = "        YCbCr format to a VdpVideoSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_ycbcr_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoSurfacePutBitsYCbCr = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpVideoSurface,
        source_ycbcr_format: VdpYCbCrFormat,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief The set of all known color table formats, for use with"]
#[doc = " \\ref VdpOutputSurfacePutBitsIndexed."]
pub type VdpColorTableFormat = u32;
#[doc = " \\brief Query the implementation's VdpOutputSurface"]
#[doc = "        capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\param[out] max_width The maximum supported surface width for"]
#[doc = "       this chroma type."]
#[doc = " \\param[out] max_height The maximum supported surface height"]
#[doc = "       for this chroma type."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        is_supported: *mut VdpBool,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's capability to perform a"]
#[doc = "        PutBits operation using application data matching the"]
#[doc = "        surface's format."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryGetPutBitsNativeCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's capability to perform a"]
#[doc = "        PutBits operation using application data in a specific"]
#[doc = "        indexed format."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[in] bits_indexed_format The format of the application"]
#[doc = "       data buffer."]
#[doc = " \\param[in] color_table_format The format of the color lookup"]
#[doc = "       table."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryPutBitsIndexedCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        bits_indexed_format: VdpIndexedFormat,
        color_table_format: VdpColorTableFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's capability to perform a"]
#[doc = "        PutBits operation using application data in a specific"]
#[doc = "        YCbCr/YUB format."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for which"]
#[doc = "       information is requested."]
#[doc = " \\param[in] bits_ycbcr_format The format of the application"]
#[doc = "       data buffer."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceQueryPutBitsYCbCrCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        bits_ycbcr_format: VdpYCbCrFormat,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpOutputSurface"]
#[doc = "        object."]
pub type VdpOutputSurface = u32;
#[doc = " \\brief Create a VdpOutputSurface."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] rgba_format The format of the new surface."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[out] surface The new surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The memory backing the surface will be initialized to 0 color"]
#[doc = " and 0 alpha (i.e. black.)"]
pub type VdpOutputSurfaceCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        rgba_format: VdpRGBAFormat,
        width: u32,
        height: u32,
        surface: *mut VdpOutputSurface,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceDestroy =
    ::std::option::Option<unsafe extern "C" fn(surface: VdpOutputSurface) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] rgba_format The format of the surface."]
#[doc = " \\param[out] width The width of the surface."]
#[doc = " \\param[out] height The height of the surface."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        rgba_format: *mut VdpRGBAFormat,
        width: *mut u32,
        height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from a VdpOutputSurface to application"]
#[doc = "        memory in the surface's native format."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_rect The sub-rectangle of the source"]
#[doc = "       surface to copy. If NULL, the entire surface will be"]
#[doc = "       retrieved."]
#[doc = " \\param[in] destination_data Pointers to the application data"]
#[doc = "       buffers into which the image data will be written. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       destination_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfaceGetBitsNative = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_rect: *const VdpRect,
        destination_data: *const *mut ::std::os::raw::c_void,
        destination_pitches: *const u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in the"]
#[doc = "        surface's native format to a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfacePutBitsNative = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
        destination_rect: *const VdpRect,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in a specific"]
#[doc = "        indexed format to a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_indexed_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_indexed_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_indexed_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\param[in] color_table_format The format of the color_table."]
#[doc = " \\param[in] color_table A table that maps between source index"]
#[doc = "       and target color data. See \\ref VdpColorTableFormat for"]
#[doc = "       details regarding the memory layout."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfacePutBitsIndexed = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_indexed_format: VdpIndexedFormat,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitch: *const u32,
        destination_rect: *const VdpRect,
        color_table_format: VdpColorTableFormat,
        color_table: *const ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in a specific"]
#[doc = "        YCbCr format to a VdpOutputSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_ycbcr_format The format of the"]
#[doc = "       application's data buffers."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_ycbcr_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_ycbcr_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\param[in] csc_matrix The color space conversion matrix used"]
#[doc = "       by the copy operation. If NULL, a default matrix will"]
#[doc = "       be used internally. Th default matrix is equivalent to"]
#[doc = "       ITU-R BT.601 with no procamp changes."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpOutputSurfacePutBitsYCbCr = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpOutputSurface,
        source_ycbcr_format: VdpYCbCrFormat,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
        destination_rect: *const VdpRect,
        csc_matrix: *const VdpCSCMatrix,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpBitmapSurface"]
#[doc = "        capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] surface_rgba_format The surface format for"]
#[doc = "       which information is requested."]
#[doc = " \\param[out] is_supported Is this surface format supported?"]
#[doc = " \\param[out] max_width The maximum supported surface width for"]
#[doc = "       this chroma type."]
#[doc = " \\param[out] max_height The maximum supported surface height"]
#[doc = "       for this chroma type."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfaceQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        surface_rgba_format: VdpRGBAFormat,
        is_supported: *mut VdpBool,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpBitmapSurface"]
#[doc = "        object."]
pub type VdpBitmapSurface = u32;
#[doc = " \\brief Create a VdpBitmapSurface."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] rgba_format The format of the new surface."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[in] frequently_accessed Is this bitmap used"]
#[doc = "       frequently, or infrequently, by compositing options?"]
#[doc = "       Implementations may use this as a hint to determine how"]
#[doc = "       to allocate the underlying storage for the surface."]
#[doc = " \\param[out] surface The new surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The memory backing the surface may not be initialized"]
#[doc = " during creation. Applications are expected initialize any"]
#[doc = " region that they use, via \\ref VdpBitmapSurfacePutBitsNative."]
pub type VdpBitmapSurfaceCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        rgba_format: VdpRGBAFormat,
        width: u32,
        height: u32,
        frequently_accessed: VdpBool,
        surface: *mut VdpBitmapSurface,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpBitmapSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfaceDestroy =
    ::std::option::Option<unsafe extern "C" fn(surface: VdpBitmapSurface) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpBitmapSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] rgba_format The format of the surface."]
#[doc = " \\param[out] width The width of the surface."]
#[doc = " \\param[out] height The height of the surface."]
#[doc = " \\param[out] frequently_accessed The frequently_accessed state"]
#[doc = "       of the surface."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfaceGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpBitmapSurface,
        rgba_format: *mut VdpRGBAFormat,
        width: *mut u32,
        height: *mut u32,
        frequently_accessed: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Copy image data from application memory in the"]
#[doc = "        surface's native format to a VdpBitmapSurface."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[in] source_data Pointers to the application data"]
#[doc = "       buffers from which the image data will be copied. Note"]
#[doc = "       that this is an array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] source_pitches Pointers to the pitch values"]
#[doc = "       for the application data buffers. Note that this is an"]
#[doc = "       array of pointers, one per plane. The"]
#[doc = "       source_format parameter will define how many"]
#[doc = "       planes are required."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the surface"]
#[doc = "       to fill with application data. If NULL, the entire"]
#[doc = "       surface will be updated."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpBitmapSurfacePutBitsNative = ::std::option::Option<
    unsafe extern "C" fn(
        surface: VdpBitmapSurface,
        source_data: *const *const ::std::os::raw::c_void,
        source_pitches: *const u32,
        destination_rect: *const VdpRect,
    ) -> VdpStatus,
>;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ZERO:
    VdpOutputSurfaceRenderBlendFactor = 0;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE:
    VdpOutputSurfaceRenderBlendFactor = 1;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_SRC_COLOR:
    VdpOutputSurfaceRenderBlendFactor = 2;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_SRC_COLOR : VdpOutputSurfaceRenderBlendFactor = 3 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_SRC_ALPHA:
    VdpOutputSurfaceRenderBlendFactor = 4;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA : VdpOutputSurfaceRenderBlendFactor = 5 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_DST_ALPHA:
    VdpOutputSurfaceRenderBlendFactor = 6;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_DST_ALPHA : VdpOutputSurfaceRenderBlendFactor = 7 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_DST_COLOR:
    VdpOutputSurfaceRenderBlendFactor = 8;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_DST_COLOR : VdpOutputSurfaceRenderBlendFactor = 9 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_SRC_ALPHA_SATURATE : VdpOutputSurfaceRenderBlendFactor = 10 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_CONSTANT_COLOR : VdpOutputSurfaceRenderBlendFactor = 11 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR : VdpOutputSurfaceRenderBlendFactor = 12 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_CONSTANT_ALPHA : VdpOutputSurfaceRenderBlendFactor = 13 ;
pub const VdpOutputSurfaceRenderBlendFactor_VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA : VdpOutputSurfaceRenderBlendFactor = 14 ;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The blending equation factors."]
pub type VdpOutputSurfaceRenderBlendFactor = u32;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_SUBTRACT:
    VdpOutputSurfaceRenderBlendEquation = 0;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_REVERSE_SUBTRACT : VdpOutputSurfaceRenderBlendEquation = 1 ;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_ADD:
    VdpOutputSurfaceRenderBlendEquation = 2;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_MIN:
    VdpOutputSurfaceRenderBlendEquation = 3;
pub const VdpOutputSurfaceRenderBlendEquation_VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_MAX:
    VdpOutputSurfaceRenderBlendEquation = 4;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The blending equations."]
pub type VdpOutputSurfaceRenderBlendEquation = u32;
#[doc = " \\brief Complete blending operation definition."]
#[doc = ""]
#[doc = " A \"blend state\" operation controls the math behind certain rendering"]
#[doc = " operations."]
#[doc = ""]
#[doc = " The blend math is the familiar OpenGL blend math:"]
#[doc = "     \\f["]
#[doc = "     dst.a = equation(blendFactorDstAlpha*dst.a,"]
#[doc = "     blendFactorSrcAlpha*src.a);"]
#[doc = "     \\f]"]
#[doc = "     \\f["]
#[doc = "     dst.rgb = equation(blendFactorDstColor*dst.rgb,"]
#[doc = "     blendFactorSrcColor*src.rgb);"]
#[doc = "     \\f]"]
#[doc = ""]
#[doc = " Note that when equation is MIN or MAX, the blend factors and constants"]
#[doc = " are ignored, and are treated as if they were 1.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpOutputSurfaceRenderBlendState {
    #[doc = " This field must be filled with VDP_OUTPUT_SURFACE_RENDER_BLEND_STATE_VERSIION"]
    pub struct_version: u32,
    pub blend_factor_source_color: VdpOutputSurfaceRenderBlendFactor,
    pub blend_factor_destination_color: VdpOutputSurfaceRenderBlendFactor,
    pub blend_factor_source_alpha: VdpOutputSurfaceRenderBlendFactor,
    pub blend_factor_destination_alpha: VdpOutputSurfaceRenderBlendFactor,
    pub blend_equation_color: VdpOutputSurfaceRenderBlendEquation,
    pub blend_equation_alpha: VdpOutputSurfaceRenderBlendEquation,
    pub blend_constant: VdpColor,
}
#[test]
fn bindgen_test_layout_VdpOutputSurfaceRenderBlendState() {
    assert_eq!(
        ::std::mem::size_of::<VdpOutputSurfaceRenderBlendState>(),
        44usize,
        concat!("Size of: ", stringify!(VdpOutputSurfaceRenderBlendState))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpOutputSurfaceRenderBlendState>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VdpOutputSurfaceRenderBlendState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).struct_version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_factor_source_color
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_source_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>()))
                .blend_factor_destination_color as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_destination_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_factor_source_alpha
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_source_alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>()))
                .blend_factor_destination_alpha as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_factor_destination_alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_equation_color
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_equation_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_equation_alpha
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_equation_alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpOutputSurfaceRenderBlendState>())).blend_constant as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpOutputSurfaceRenderBlendState),
            "::",
            stringify!(blend_constant)
        )
    );
}
#[doc = " \\brief Composite a sub-rectangle of a \\ref VdpOutputSurface"]
#[doc = "        \"VdpOutputSurface\" into a sub-rectangle of another"]
#[doc = "        \\ref VdpOutputSurface VdpOutputSurface."]
#[doc = " \\param[in] destination_surface The destination surface of the"]
#[doc = "       compositing operation."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the"]
#[doc = "       destination surface to update. If NULL, the entire"]
#[doc = "       destination surface will be updated."]
#[doc = " \\param[in] source_surface The source surface for the"]
#[doc = "       compositing operation. The surface is treated as having"]
#[doc = "       four components: red, green, blue and alpha. Any"]
#[doc = "       missing components are treated as 1.0. For example, for"]
#[doc = "       an A8 VdpOutputSurface, alpha will come from the surface"]
#[doc = "       but red, green and blue will be treated as 1.0. If"]
#[doc = "       source_surface is VDP_INVALID_HANDLE, all components will"]
#[doc = "       be treated as 1.0. Note that destination_surface and"]
#[doc = "       source_surface must have been allocated via the same"]
#[doc = "       \\ref VdpDevice \"VdpDevice\"."]
#[doc = " \\param[in] source_rect The sub-rectangle of the source"]
#[doc = "       surface to read from. If NULL, the entire"]
#[doc = "       source_surface will be read. Left/right and/or top/bottom"]
#[doc = "       co-ordinates may be swapped to flip the source. Any"]
#[doc = "       flip occurs prior to any requested rotation. Values"]
#[doc = "       from outside the source surface are valid and samples"]
#[doc = "       at those locations will be taken from the nearest edge."]
#[doc = " \\param[in] colors A pointer to an array of \\ref VdpColor"]
#[doc = "      \"VdpColor\" objects. If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is set,"]
#[doc = "      VDPAU will four entries from the array, and treat them"]
#[doc = "      as the colors corresponding to the upper-left,"]
#[doc = "      upper-right, lower-right and lower-left corners of the"]
#[doc = "      post-rotation source (i.e. indices 0, 1, 2 and 3 run"]
#[doc = "      clockwise from the upper left corner). If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is not"]
#[doc = "      set, VDPAU will use the single VdpColor for all four"]
#[doc = "      corners. If colors is NULL then red, green, blue and"]
#[doc = "      alpha values of 1.0 will be used."]
#[doc = " \\param[in] blend_state If a blend state is provided, the"]
#[doc = "     blend state will be used for the composite operation. If"]
#[doc = "     NULL, blending is effectively disabled, which is"]
#[doc = "     equivalent to a blend equation of ADD, source blend"]
#[doc = "     factors of ONE and destination blend factors of ZERO."]
#[doc = "     See \\ref VdpOutputSurfaceRenderBlendState for details"]
#[doc = "     regarding the mathematics of the blending operation."]
#[doc = " \\param[in] flags A set of flags influencing how the"]
#[doc = "       compositing operation works."]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_0"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_90"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_180"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_270"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX"]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The general compositing pipeline is as follows."]
#[doc = ""]
#[doc = " -# Extract source_rect from source_surface."]
#[doc = ""]
#[doc = " -# The extracted source is rotated 0, 90, 180 or 270 degrees"]
#[doc = "    according to the flags."]
#[doc = ""]
#[doc = " -# The rotated source is component-wise multiplied by a"]
#[doc = "    smooth-shaded quad with a (potentially) different color at"]
#[doc = "    each vertex."]
#[doc = ""]
#[doc = " -# The resulting rotated, smooth-shaded quad is scaled to the"]
#[doc = "    size of destination_rect and composited with"]
#[doc = "    destination_surface using the provided blend state."]
#[doc = ""]
pub type VdpOutputSurfaceRenderOutputSurface = ::std::option::Option<
    unsafe extern "C" fn(
        destination_surface: VdpOutputSurface,
        destination_rect: *const VdpRect,
        source_surface: VdpOutputSurface,
        source_rect: *const VdpRect,
        colors: *const VdpColor,
        blend_state: *const VdpOutputSurfaceRenderBlendState,
        flags: u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Composite a sub-rectangle of a \\ref VdpBitmapSurface"]
#[doc = "        \"VdpBitmapSurface\" into a sub-rectangle of a"]
#[doc = "        \\ref VdpOutputSurface VdpOutputSurface."]
#[doc = " \\param[in] destination_surface The destination surface of the"]
#[doc = "       compositing operation."]
#[doc = " \\param[in] destination_rect The sub-rectangle of the"]
#[doc = "       destination surface to update. If NULL, the entire"]
#[doc = "       destination surface will be updated."]
#[doc = " \\param[in] source_surface The source surface for the"]
#[doc = "       compositing operation. The surface is treated as having"]
#[doc = "       four components: red, green, blue and alpha. Any"]
#[doc = "       missing components are treated as 1.0. For example, for"]
#[doc = "       an A8 VdpBitmapSurface, alpha will come from the surface"]
#[doc = "       but red, green and blue will be treated as 1.0. If"]
#[doc = "       source_surface is VDP_INVALID_HANDLE, all components will"]
#[doc = "       be treated as 1.0. Note that destination_surface and"]
#[doc = "       source_surface must have been allocated via the same"]
#[doc = "       \\ref VdpDevice \"VdpDevice\"."]
#[doc = " \\param[in] source_rect The sub-rectangle of the source"]
#[doc = "       surface to read from. If NULL, the entire"]
#[doc = "       source_surface will be read. Left/right ot top/bottom"]
#[doc = "       co-ordinates may be swapped to flip the source. Any"]
#[doc = "       flip occurs prior to any requested rotation. Values"]
#[doc = "       from outside the source surface are valid and samples"]
#[doc = "       at those locations will be taken from the nearest edge."]
#[doc = " \\param[in] colors A pointer to an array of \\ref VdpColor"]
#[doc = "      \"VdpColor\" objects. If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is set,"]
#[doc = "      VDPAU will four entries from the array, and treat them"]
#[doc = "      as the colors corresponding to the upper-left,"]
#[doc = "      upper-right, lower-right and lower-left corners of the"]
#[doc = "      post-rotation source (i.e. indices 0, 1, 2 and 3 run"]
#[doc = "      clockwise from the upper left corner). If the flag"]
#[doc = "      VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX is not"]
#[doc = "      set, VDPAU will use the single VdpColor for all four"]
#[doc = "      corners. If colors is NULL then red, green, blue and"]
#[doc = "      alpha values of 1.0 will be used."]
#[doc = " \\param[in] blend_state If a blend state is provided, the"]
#[doc = "     blend state will be used for the composite operation. If"]
#[doc = "     NULL, blending is effectively disabled, which is"]
#[doc = "     equivalent to a blend equation of ADD, source blend"]
#[doc = "     factors of ONE and destination blend factors of ZERO."]
#[doc = "     See \\ref VdpOutputSurfaceRenderBlendState for details"]
#[doc = "     regarding the mathematics of the blending operation."]
#[doc = " \\param[in] flags A set of flags influencing how the"]
#[doc = "       compositing operation works."]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_0"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_90"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_180"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_ROTATE_270"]
#[doc = " \\arg \\ref VDP_OUTPUT_SURFACE_RENDER_COLOR_PER_VERTEX"]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " The general compositing pipeline is as follows."]
#[doc = ""]
#[doc = " -# Extract source_rect from source_surface."]
#[doc = ""]
#[doc = " -# The extracted source is rotated 0, 90, 180 or 270 degrees"]
#[doc = "   according to the flags."]
#[doc = ""]
#[doc = " -# The rotated source is component-wise multiplied by a"]
#[doc = "    smooth-shaded quad with a (potentially) different color at"]
#[doc = "    each vertex."]
#[doc = ""]
#[doc = " -# The resulting rotated, smooth-shaded quad is scaled to the"]
#[doc = "    size of destination_rect and composited with"]
#[doc = "    destination_surface using the provided blend state."]
#[doc = ""]
pub type VdpOutputSurfaceRenderBitmapSurface = ::std::option::Option<
    unsafe extern "C" fn(
        destination_surface: VdpOutputSurface,
        destination_rect: *const VdpRect,
        source_surface: VdpBitmapSurface,
        source_rect: *const VdpRect,
        colors: *const VdpColor,
        blend_state: *const VdpOutputSurfaceRenderBlendState,
        flags: u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief The set of all known compressed video formats, and"]
#[doc = "        associated profiles, that may be decoded."]
pub type VdpDecoderProfile = u32;
pub const VdpVideoSurfaceSupportedPictureStructure_VDP_VIDEO_SURFACE_FIELD_STRUCTURE:
    VdpVideoSurfaceSupportedPictureStructure = 1;
pub const VdpVideoSurfaceSupportedPictureStructure_VDP_VIDEO_SURFACE_FRAME_STRUCTURE:
    VdpVideoSurfaceSupportedPictureStructure = 2;
pub type VdpVideoSurfaceSupportedPictureStructure = u32;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_LEVEL: VdpDecoderCapability = 0;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_MACROBLOCKS: VdpDecoderCapability = 1;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_WIDTH: VdpDecoderCapability = 2;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_MAX_HEIGHT: VdpDecoderCapability = 3;
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_SUPPORTED_PICTURE_STRUCTURE:
    VdpDecoderCapability = 4;
#[doc = " A list of supported chroma types, stored as a bitmask of 1 shifted"]
#[doc = " by each supported VdpChromaType value.  E.g.,"]
#[doc = "   (1 << VDP_CHROMA_TYPE_420) |"]
#[doc = "   (1 << VDP_CHROMA_TYPE_422) |"]
#[doc = "   (1 << VDP_CHROMA_TYPE_444)"]
pub const VdpDecoderCapability_VDP_DECODER_PROFILE_SUPPORTED_CHROMA_TYPES: VdpDecoderCapability = 5;
pub type VdpDecoderCapability = u32;
#[doc = " \\brief Query the supported value of the requested capability, for"]
#[doc = "       the specified profile on the specified device."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] profile The decoder profile for which information is requested."]
#[doc = " \\param[in] capability The decoder profile capability for which the value"]
#[doc = "       is requested."]
#[doc = " \\param[out] capability_value The value of the requested capability."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderQueryProfileCapability = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        profile: VdpDecoderProfile,
        capability: VdpDecoderCapability,
        capability_value: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's VdpDecoder capabilities."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] profile The decoder profile for which information is requested."]
#[doc = " \\param[out] is_supported Is this profile supported?"]
#[doc = " \\param[out] max_level The maximum specification level supported for this"]
#[doc = "       profile."]
#[doc = " \\param[out] max_macroblocks The maximum supported surface size in"]
#[doc = "       macroblocks. Note that this could be greater than that dictated by"]
#[doc = "       the maximum level."]
#[doc = " \\param[out] max_width The maximum supported surface width for this profile."]
#[doc = "       Note that this could be greater than that dictated by the maximum"]
#[doc = "       level."]
#[doc = " \\param[out] max_height The maximum supported surface height for this"]
#[doc = "       profile. Note that this could be greater than that dictated by the"]
#[doc = "       maximum level."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderQueryCapabilities = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        profile: VdpDecoderProfile,
        is_supported: *mut VdpBool,
        max_level: *mut u32,
        max_macroblocks: *mut u32,
        max_width: *mut u32,
        max_height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpDecoder object."]
pub type VdpDecoder = u32;
#[doc = " \\brief Create a VdpDecoder."]
#[doc = " \\param[in] device The device that will contain the surface."]
#[doc = " \\param[in] profile The video format the decoder will decode."]
#[doc = " \\param[in] width The width of the new surface."]
#[doc = " \\param[in] height The height of the new surface."]
#[doc = " \\param[in] max_references The maximum number of references that may be"]
#[doc = "       used by a single frame in the stream to be decoded. This parameter"]
#[doc = "       exists mainly for formats such as H.264, where different streams"]
#[doc = "       may use a different number of references. Requesting too many"]
#[doc = "       references may waste memory, but decoding should still operate"]
#[doc = "       correctly. Requesting too few references will cause decoding to"]
#[doc = "       fail."]
#[doc = " \\param[out] decoder The new decoder's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        profile: VdpDecoderProfile,
        width: u32,
        height: u32,
        max_references: u32,
        decoder: *mut VdpDecoder,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpDecoder."]
#[doc = " \\param[in] surface The decoder's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderDestroy =
    ::std::option::Option<unsafe extern "C" fn(decoder: VdpDecoder) -> VdpStatus>;
#[doc = " \\brief Retrieve the parameters used to create a"]
#[doc = "        VdpDecoder."]
#[doc = " \\param[in] surface The surface's handle."]
#[doc = " \\param[out] profile The video format used to create the"]
#[doc = "       decoder."]
#[doc = " \\param[out] width The width of surfaces decode by the"]
#[doc = "       decoder."]
#[doc = " \\param[out] height The height of surfaces decode by the"]
#[doc = "       decoder"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDecoderGetParameters = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: VdpDecoder,
        profile: *mut VdpDecoderProfile,
        width: *mut u32,
        height: *mut u32,
    ) -> VdpStatus,
>;
#[doc = " \\brief Application data buffer containing compressed video"]
#[doc = "        data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpBitstreamBuffer {
    #[doc = " This field must be filled with VDP_BITSTREAM_BUFFER_VERSION"]
    pub struct_version: u32,
    #[doc = " A pointer to the bitstream data bytes"]
    pub bitstream: *const ::std::os::raw::c_void,
    #[doc = " The number of data bytes"]
    pub bitstream_bytes: u32,
}
#[test]
fn bindgen_test_layout_VdpBitstreamBuffer() {
    assert_eq!(
        ::std::mem::size_of::<VdpBitstreamBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(VdpBitstreamBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpBitstreamBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(VdpBitstreamBuffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpBitstreamBuffer>())).struct_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpBitstreamBuffer),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpBitstreamBuffer>())).bitstream as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpBitstreamBuffer),
            "::",
            stringify!(bitstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpBitstreamBuffer>())).bitstream_bytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpBitstreamBuffer),
            "::",
            stringify!(bitstream_bytes)
        )
    );
}
#[doc = " \\brief A generic \"picture information\" type."]
#[doc = ""]
#[doc = " This type serves solely to document the expected usage of a"]
#[doc = " generic (void *) function parameter. In actual usage, the"]
#[doc = " application is expected to physically provide a pointer to an"]
#[doc = " instance of one of the \"real\" VdpPictureInfo* structures,"]
#[doc = " picking the type appropriate for the decoder object in"]
#[doc = " question."]
pub type VdpPictureInfo = ::std::os::raw::c_void;
#[doc = " \\brief Picture parameter information for an MPEG 1 or MPEG 2"]
#[doc = "        picture."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoMPEG1Or2 {
    #[doc = " Reference used by B and P frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub forward_reference: VdpVideoSurface,
    #[doc = " Reference used by B frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub backward_reference: VdpVideoSurface,
    #[doc = " Number of slices in the bitstream provided."]
    pub slice_count: u32,
    #[doc = " \\name MPEG bitstream"]
    #[doc = ""]
    #[doc = " Copies of the MPEG bitstream fields."]
    #[doc = " @{"]
    pub picture_structure: u8,
    pub picture_coding_type: u8,
    pub intra_dc_precision: u8,
    pub frame_pred_frame_dct: u8,
    pub concealment_motion_vectors: u8,
    pub intra_vlc_format: u8,
    pub alternate_scan: u8,
    pub q_scale_type: u8,
    pub top_field_first: u8,
    #[doc = " MPEG-1 only. For MPEG-2, set to 0."]
    pub full_pel_forward_vector: u8,
    #[doc = " MPEG-1 only. For MPEG-2, set to 0."]
    pub full_pel_backward_vector: u8,
    #[doc = " For MPEG-1, fill both horizontal and vertical entries."]
    pub f_code: [[u8; 2usize]; 2usize],
    #[doc = " Convert to raster order."]
    pub intra_quantizer_matrix: [u8; 64usize],
    #[doc = " Convert to raster order."]
    pub non_intra_quantizer_matrix: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoMPEG1Or2() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoMPEG1Or2>(),
        156usize,
        concat!("Size of: ", stringify!(VdpPictureInfoMPEG1Or2))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoMPEG1Or2>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoMPEG1Or2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).forward_reference as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(forward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).backward_reference as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(backward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).slice_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).picture_structure as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).picture_coding_type as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(picture_coding_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).intra_dc_precision as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).frame_pred_frame_dct as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(frame_pred_frame_dct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).concealment_motion_vectors
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(concealment_motion_vectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).intra_vlc_format as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(intra_vlc_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).alternate_scan as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(alternate_scan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).q_scale_type as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(q_scale_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).top_field_first as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).full_pel_forward_vector as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(full_pel_forward_vector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).full_pel_backward_vector as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(full_pel_backward_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).f_code as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(f_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).intra_quantizer_matrix as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(intra_quantizer_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG1Or2>())).non_intra_quantizer_matrix
                as *const _ as usize
        },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG1Or2),
            "::",
            stringify!(non_intra_quantizer_matrix)
        )
    );
}
impl ::std::fmt::Debug for VdpPictureInfoMPEG1Or2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "VdpPictureInfoMPEG1Or2 {{ forward_reference: {:?}, backward_reference: {:?}, slice_count: {:?}, picture_structure: {:?}, picture_coding_type: {:?}, intra_dc_precision: {:?}, frame_pred_frame_dct: {:?}, concealment_motion_vectors: {:?}, intra_vlc_format: {:?}, alternate_scan: {:?}, q_scale_type: {:?}, top_field_first: {:?}, full_pel_forward_vector: {:?}, full_pel_backward_vector: {:?}, f_code: {:?}, intra_quantizer_matrix: [{}], non_intra_quantizer_matrix: [{}] }}" , self . forward_reference , self . backward_reference , self . slice_count , self . picture_structure , self . picture_coding_type , self . intra_dc_precision , self . frame_pred_frame_dct , self . concealment_motion_vectors , self . intra_vlc_format , self . alternate_scan , self . q_scale_type , self . top_field_first , self . full_pel_forward_vector , self . full_pel_backward_vector , self . f_code , self . intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . non_intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
#[doc = " \\brief Information about an H.264 reference frame"]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpReferenceFrameH264 {
    #[doc = " The surface that contains the reference image."]
    #[doc = " Set to VDP_INVALID_HANDLE for unused entries."]
    pub surface: VdpVideoSurface,
    #[doc = " Is this a long term reference (else short term)."]
    pub is_long_term: VdpBool,
    #[doc = " Is the top field used as a reference."]
    #[doc = " Set to VDP_FALSE for unused entries."]
    pub top_is_reference: VdpBool,
    #[doc = " Is the bottom field used as a reference."]
    #[doc = " Set to VDP_FALSE for unused entries."]
    pub bottom_is_reference: VdpBool,
    #[doc = " [0]: top, [1]: bottom"]
    pub field_order_cnt: [i32; 2usize],
    #[doc = " Copy of the H.264 bitstream field:"]
    #[doc = " frame_num from slice_header for short-term references,"]
    #[doc = " LongTermPicNum from decoding algorithm for long-term references."]
    pub frame_idx: u16,
}
#[test]
fn bindgen_test_layout_VdpReferenceFrameH264() {
    assert_eq!(
        ::std::mem::size_of::<VdpReferenceFrameH264>(),
        28usize,
        concat!("Size of: ", stringify!(VdpReferenceFrameH264))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpReferenceFrameH264>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpReferenceFrameH264))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpReferenceFrameH264>())).surface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).is_long_term as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(is_long_term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).top_is_reference as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(top_is_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).bottom_is_reference as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(bottom_is_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpReferenceFrameH264>())).field_order_cnt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpReferenceFrameH264>())).frame_idx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpReferenceFrameH264),
            "::",
            stringify!(frame_idx)
        )
    );
}
#[doc = " \\brief Picture parameter information for an H.264 picture."]
#[doc = ""]
#[doc = " Note: The \\ref referenceFrames array must contain the \"DPB\" as"]
#[doc = " defined by the H.264 specification. In particular, once a"]
#[doc = " reference frame has been decoded to a surface, that surface must"]
#[doc = " continue to appear in the DPB until no longer required to predict"]
#[doc = " any future frame. Once a surface is removed from the DPB, it can"]
#[doc = " no longer be used as a reference, unless decoded again."]
#[doc = ""]
#[doc = " Also note that only surfaces previously generated using \\ref"]
#[doc = " VdpDecoderRender may be used as reference frames. In particular,"]
#[doc = " surfaces filled using any \"put bits\" API will not work."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[doc = ""]
#[doc = " Note: VDPAU clients must use VdpPictureInfoH264Predictive to describe the"]
#[doc = " attributes of a frame being decoded with"]
#[doc = " VDP_DECODER_PROFILE_H264_HIGH_444_PREDICTIVE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoH264 {
    #[doc = " Number of slices in the bitstream provided."]
    pub slice_count: u32,
    #[doc = " [0]: top, [1]: bottom"]
    pub field_order_cnt: [i32; 2usize],
    #[doc = " Will the decoded frame be used as a reference later."]
    pub is_reference: VdpBool,
    #[doc = " \\name H.264 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the H.264 bitstream fields."]
    #[doc = " @{"]
    pub frame_num: u16,
    pub field_pic_flag: u8,
    pub bottom_field_flag: u8,
    pub num_ref_frames: u8,
    pub mb_adaptive_frame_field_flag: u8,
    pub constrained_intra_pred_flag: u8,
    pub weighted_pred_flag: u8,
    pub weighted_bipred_idc: u8,
    pub frame_mbs_only_flag: u8,
    pub transform_8x8_mode_flag: u8,
    pub chroma_qp_index_offset: i8,
    pub second_chroma_qp_index_offset: i8,
    pub pic_init_qp_minus26: i8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub log2_max_frame_num_minus4: u8,
    pub pic_order_cnt_type: u8,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
    pub delta_pic_order_always_zero_flag: u8,
    pub direct_8x8_inference_flag: u8,
    pub entropy_coding_mode_flag: u8,
    pub pic_order_present_flag: u8,
    pub deblocking_filter_control_present_flag: u8,
    pub redundant_pic_cnt_present_flag: u8,
    #[doc = " Convert to raster order."]
    pub scaling_lists_4x4: [[u8; 16usize]; 6usize],
    #[doc = " Convert to raster order."]
    pub scaling_lists_8x8: [[u8; 64usize]; 2usize],
    #[doc = " See \\ref VdpPictureInfoH264 for instructions regarding this field."]
    pub referenceFrames: [VdpReferenceFrameH264; 16usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoH264() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoH264>(),
        716usize,
        concat!("Size of: ", stringify!(VdpPictureInfoH264))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoH264>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoH264))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoH264>())).slice_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).field_order_cnt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoH264>())).is_reference as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(is_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoH264>())).frame_num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).field_pic_flag as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(field_pic_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).bottom_field_flag as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(bottom_field_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).num_ref_frames as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(num_ref_frames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).mb_adaptive_frame_field_flag as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(mb_adaptive_frame_field_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).constrained_intra_pred_flag as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(constrained_intra_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).weighted_pred_flag as *const _ as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(weighted_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).weighted_bipred_idc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(weighted_bipred_idc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).frame_mbs_only_flag as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(frame_mbs_only_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).transform_8x8_mode_flag as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(transform_8x8_mode_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).chroma_qp_index_offset as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).second_chroma_qp_index_offset as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(second_chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).pic_init_qp_minus26 as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(pic_init_qp_minus26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).num_ref_idx_l0_active_minus1 as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(num_ref_idx_l0_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).num_ref_idx_l1_active_minus1 as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(num_ref_idx_l1_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).log2_max_frame_num_minus4 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(log2_max_frame_num_minus4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).pic_order_cnt_type as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(pic_order_cnt_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).log2_max_pic_order_cnt_lsb_minus4
                as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(log2_max_pic_order_cnt_lsb_minus4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).delta_pic_order_always_zero_flag
                as *const _ as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(delta_pic_order_always_zero_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).direct_8x8_inference_flag as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(direct_8x8_inference_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).entropy_coding_mode_flag as *const _
                as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(entropy_coding_mode_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).pic_order_present_flag as *const _
                as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(pic_order_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).deblocking_filter_control_present_flag
                as *const _ as usize
        },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(deblocking_filter_control_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).redundant_pic_cnt_present_flag
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(redundant_pic_cnt_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).scaling_lists_4x4 as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(scaling_lists_4x4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).scaling_lists_8x8 as *const _ as usize
        },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(scaling_lists_8x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264>())).referenceFrames as *const _ as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264),
            "::",
            stringify!(referenceFrames)
        )
    );
}
#[doc = " \\brief Picture parameter information for an H.264 Hi444PP picture."]
#[doc = ""]
#[doc = " Note: VDPAU clients must use VdpPictureInfoH264Predictive to describe the"]
#[doc = " attributes of a frame being decoded with"]
#[doc = " VDP_DECODER_PROFILE_H264_HIGH_444_PREDICTIVE."]
#[doc = ""]
#[doc = " Note: software drivers may choose to honor values of"]
#[doc = " qpprime_y_zero_transform_bypass_flag greater than 1 for internal use."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoH264Predictive {
    #[doc = " \\ref VdpPictureInfoH264 struct."]
    pub pictureInfo: VdpPictureInfoH264,
    #[doc = " \\name H.264 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the H.264 bitstream fields."]
    #[doc = " @{ */"]
    #[doc = "  0 - lossless disabled"]
    #[doc = "  1 - lossless enabled"]
    pub qpprime_y_zero_transform_bypass_flag: u8,
    #[doc = "  0 - disabled"]
    #[doc = "  1 - enabled"]
    pub separate_colour_plane_flag: u8,
}
#[test]
fn bindgen_test_layout_VdpPictureInfoH264Predictive() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoH264Predictive>(),
        720usize,
        concat!("Size of: ", stringify!(VdpPictureInfoH264Predictive))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoH264Predictive>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoH264Predictive))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264Predictive>())).pictureInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264Predictive),
            "::",
            stringify!(pictureInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264Predictive>()))
                .qpprime_y_zero_transform_bypass_flag as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264Predictive),
            "::",
            stringify!(qpprime_y_zero_transform_bypass_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoH264Predictive>())).separate_colour_plane_flag
                as *const _ as usize
        },
        717usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoH264Predictive),
            "::",
            stringify!(separate_colour_plane_flag)
        )
    );
}
#[doc = " \\brief Picture parameter information for a VC1 picture."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpPictureInfoVC1 {
    #[doc = " Reference used by B and P frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub forward_reference: VdpVideoSurface,
    #[doc = " Reference used by B frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub backward_reference: VdpVideoSurface,
    #[doc = " Number of slices in the bitstream provided."]
    pub slice_count: u32,
    #[doc = " I=0, P=1, B=3, BI=4  from 7.1.1.4."]
    pub picture_type: u8,
    #[doc = " Progressive=0, Frame-interlace=2, Field-interlace=3; see VC-1 7.1.1.15."]
    pub frame_coding_mode: u8,
    #[doc = " \\name VC-1 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the VC-1 bitstream fields."]
    #[doc = " @{ */"]
    pub postprocflag: u8,
    #[doc = " See VC-1 6.1.8."]
    pub pulldown: u8,
    #[doc = " See VC-1 6.1.9."]
    pub interlace: u8,
    #[doc = " See VC-1 6.1.10."]
    pub tfcntrflag: u8,
    #[doc = " See VC-1 6.1.11."]
    pub finterpflag: u8,
    #[doc = " See VC-1 6.1.3."]
    pub psf: u8,
    #[doc = " See VC-1 6.2.8."]
    pub dquant: u8,
    #[doc = " See VC-1 6.2.3."]
    pub panscan_flag: u8,
    #[doc = " See VC-1 6.2.4."]
    pub refdist_flag: u8,
    #[doc = " See VC-1 6.2.11."]
    pub quantizer: u8,
    #[doc = " See VC-1 6.2.7."]
    pub extended_mv: u8,
    #[doc = " See VC-1 6.2.14."]
    pub extended_dmv: u8,
    #[doc = " See VC-1 6.2.10."]
    pub overlap: u8,
    #[doc = " See VC-1 6.2.9."]
    pub vstransform: u8,
    #[doc = " See VC-1 6.2.5."]
    pub loopfilter: u8,
    #[doc = " See VC-1 6.2.6."]
    pub fastuvmc: u8,
    #[doc = " See VC-1 6.12.15."]
    pub range_mapy_flag: u8,
    pub range_mapy: u8,
    #[doc = " See VC-1 6.2.16."]
    pub range_mapuv_flag: u8,
    pub range_mapuv: u8,
    #[doc = " See VC-1 J.1.10."]
    #[doc = " Only used by simple and main profiles."]
    pub multires: u8,
    #[doc = " See VC-1 J.1.16."]
    #[doc = " Only used by simple and main profiles."]
    pub syncmarker: u8,
    #[doc = " VC-1 SP/MP range reduction control."]
    #[doc = " Only used by simple and main profiles."]
    #[doc = " Bit 0: Copy of rangered VC-1 bitstream field; See VC-1 J.1.17."]
    #[doc = " Bit 1: Copy of rangeredfrm VC-1 bitstream fiels; See VC-1 7.1.13."]
    pub rangered: u8,
    #[doc = " See VC-1 J.1.17."]
    #[doc = " Only used by simple and main profiles."]
    pub maxbframes: u8,
    #[doc = " Out-of-loop deblocking enable."]
    #[doc = " Bit 0 of POSTPROC from VC-1 7.1.1.27"]
    #[doc = " Note that bit 1 of POSTPROC (dering enable) should not be included."]
    pub deblockEnable: u8,
    #[doc = " Parameter used by VC-1 Annex H deblocking algorithm. Note that VDPAU"]
    #[doc = " implementations may choose which deblocking algorithm to use."]
    #[doc = " See VC-1 7.1.1.6"]
    pub pquant: u8,
}
#[test]
fn bindgen_test_layout_VdpPictureInfoVC1() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoVC1>(),
        40usize,
        concat!("Size of: ", stringify!(VdpPictureInfoVC1))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoVC1>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoVC1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).forward_reference as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(forward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).backward_reference as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(backward_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).slice_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).picture_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(picture_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).frame_coding_mode as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(frame_coding_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).postprocflag as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(postprocflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).pulldown as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(pulldown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).interlace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(interlace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).tfcntrflag as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(tfcntrflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).finterpflag as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(finterpflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).psf as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(psf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).dquant as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(dquant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).panscan_flag as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(panscan_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).refdist_flag as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(refdist_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).quantizer as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(quantizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).extended_mv as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(extended_mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).extended_dmv as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(extended_dmv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).overlap as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(overlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).vstransform as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(vstransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).loopfilter as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(loopfilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).fastuvmc as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(fastuvmc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapy_flag as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapy_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapy as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapuv_flag as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapuv_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).range_mapuv as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(range_mapuv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).multires as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(multires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).syncmarker as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(syncmarker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).rangered as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(rangered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).maxbframes as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(maxbframes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).deblockEnable as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(deblockEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVC1>())).pquant as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVC1),
            "::",
            stringify!(pquant)
        )
    );
}
#[doc = " \\brief Picture parameter information for an MPEG-4 Part 2 picture."]
#[doc = ""]
#[doc = " Note: References to bitstream fields below may refer to data literally parsed"]
#[doc = " from the bitstream, or derived from the bitstream using a mechanism described"]
#[doc = " in the specification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoMPEG4Part2 {
    #[doc = " Reference used by B and P frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub forward_reference: VdpVideoSurface,
    #[doc = " Reference used by B frames."]
    #[doc = " Set to VDP_INVALID_HANDLE when not used."]
    pub backward_reference: VdpVideoSurface,
    #[doc = " \\name MPEG 4 part 2 bitstream"]
    #[doc = ""]
    #[doc = " Copies of the MPEG 4 part 2 bitstream fields."]
    #[doc = " @{"]
    pub trd: [i32; 2usize],
    pub trb: [i32; 2usize],
    pub vop_time_increment_resolution: u16,
    pub vop_coding_type: u8,
    pub vop_fcode_forward: u8,
    pub vop_fcode_backward: u8,
    pub resync_marker_disable: u8,
    pub interlaced: u8,
    pub quant_type: u8,
    pub quarter_sample: u8,
    pub short_video_header: u8,
    #[doc = " Derived from vop_rounding_type bitstream field."]
    pub rounding_control: u8,
    pub alternate_vertical_scan_flag: u8,
    pub top_field_first: u8,
    pub intra_quantizer_matrix: [u8; 64usize],
    pub non_intra_quantizer_matrix: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoMPEG4Part2() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoMPEG4Part2>(),
        168usize,
        concat!("Size of: ", stringify!(VdpPictureInfoMPEG4Part2))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoMPEG4Part2>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoMPEG4Part2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).forward_reference as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(forward_reference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).backward_reference as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(backward_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).trd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(trd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).trb as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(trb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_time_increment_resolution
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_time_increment_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_coding_type as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_coding_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_fcode_forward as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_fcode_forward)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).vop_fcode_backward as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(vop_fcode_backward)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).resync_marker_disable as *const _
                as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(resync_marker_disable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).interlaced as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).quant_type as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(quant_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).quarter_sample as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(quarter_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).short_video_header as *const _
                as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(short_video_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).rounding_control as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(rounding_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).alternate_vertical_scan_flag
                as *const _ as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(alternate_vertical_scan_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).top_field_first as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).intra_quantizer_matrix as *const _
                as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(intra_quantizer_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoMPEG4Part2>())).non_intra_quantizer_matrix
                as *const _ as usize
        },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoMPEG4Part2),
            "::",
            stringify!(non_intra_quantizer_matrix)
        )
    );
}
impl ::std::fmt::Debug for VdpPictureInfoMPEG4Part2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "VdpPictureInfoMPEG4Part2 {{ forward_reference: {:?}, backward_reference: {:?}, trd: {:?}, trb: {:?}, vop_time_increment_resolution: {:?}, vop_coding_type: {:?}, vop_fcode_forward: {:?}, vop_fcode_backward: {:?}, resync_marker_disable: {:?}, interlaced: {:?}, quant_type: {:?}, quarter_sample: {:?}, short_video_header: {:?}, rounding_control: {:?}, alternate_vertical_scan_flag: {:?}, top_field_first: {:?}, intra_quantizer_matrix: [{}], non_intra_quantizer_matrix: [{}] }}" , self . forward_reference , self . backward_reference , self . trd , self . trb , self . vop_time_increment_resolution , self . vop_coding_type , self . vop_fcode_forward , self . vop_fcode_backward , self . resync_marker_disable , self . interlaced , self . quant_type , self . quarter_sample , self . short_video_header , self . rounding_control , self . alternate_vertical_scan_flag , self . top_field_first , self . intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . non_intra_quantizer_matrix . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) )
    }
}
#[doc = " \\brief Picture parameter information for a DivX 4 picture."]
#[doc = ""]
#[doc = " Due to similarites between MPEG-4 Part 2 and DivX 4, the picture"]
#[doc = " parameter structure is re-used."]
pub type VdpPictureInfoDivX4 = VdpPictureInfoMPEG4Part2;
#[doc = " \\brief Picture parameter information for a DivX 5 picture."]
#[doc = ""]
#[doc = " Due to similarites between MPEG-4 Part 2 and DivX 5, the picture"]
#[doc = " parameter structure is re-used."]
pub type VdpPictureInfoDivX5 = VdpPictureInfoMPEG4Part2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpPictureInfoVP9 {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub lastReference: VdpVideoSurface,
    pub goldenReference: VdpVideoSurface,
    pub altReference: VdpVideoSurface,
    pub colorSpace: ::std::os::raw::c_uchar,
    pub profile: ::std::os::raw::c_ushort,
    pub frameContextIdx: ::std::os::raw::c_ushort,
    pub keyFrame: ::std::os::raw::c_ushort,
    pub showFrame: ::std::os::raw::c_ushort,
    pub errorResilient: ::std::os::raw::c_ushort,
    pub frameParallelDecoding: ::std::os::raw::c_ushort,
    pub subSamplingX: ::std::os::raw::c_ushort,
    pub subSamplingY: ::std::os::raw::c_ushort,
    pub intraOnly: ::std::os::raw::c_ushort,
    pub allowHighPrecisionMv: ::std::os::raw::c_ushort,
    pub refreshEntropyProbs: ::std::os::raw::c_ushort,
    pub refFrameSignBias: [::std::os::raw::c_uchar; 4usize],
    pub bitDepthMinus8Luma: ::std::os::raw::c_uchar,
    pub bitDepthMinus8Chroma: ::std::os::raw::c_uchar,
    pub loopFilterLevel: ::std::os::raw::c_uchar,
    pub loopFilterSharpness: ::std::os::raw::c_uchar,
    pub modeRefLfEnabled: ::std::os::raw::c_uchar,
    pub log2TileColumns: ::std::os::raw::c_uchar,
    pub log2TileRows: ::std::os::raw::c_uchar,
    pub segmentEnabled: ::std::os::raw::c_uchar,
    pub segmentMapUpdate: ::std::os::raw::c_uchar,
    pub segmentMapTemporalUpdate: ::std::os::raw::c_uchar,
    pub segmentFeatureMode: ::std::os::raw::c_uchar,
    pub segmentFeatureEnable: [[::std::os::raw::c_uchar; 4usize]; 8usize],
    pub segmentFeatureData: [[::std::os::raw::c_short; 4usize]; 8usize],
    pub mbSegmentTreeProbs: [::std::os::raw::c_uchar; 7usize],
    pub segmentPredProbs: [::std::os::raw::c_uchar; 3usize],
    pub reservedSegment16Bits: [::std::os::raw::c_uchar; 2usize],
    pub qpYAc: ::std::os::raw::c_int,
    pub qpYDc: ::std::os::raw::c_int,
    pub qpChDc: ::std::os::raw::c_int,
    pub qpChAc: ::std::os::raw::c_int,
    pub activeRefIdx: [::std::os::raw::c_uint; 3usize],
    pub resetFrameContext: ::std::os::raw::c_uint,
    pub mcompFilterType: ::std::os::raw::c_uint,
    pub mbRefLfDelta: [::std::os::raw::c_uint; 4usize],
    pub mbModeLfDelta: [::std::os::raw::c_uint; 2usize],
    pub uncompressedHeaderSize: ::std::os::raw::c_uint,
    pub compressedHeaderSize: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VdpPictureInfoVP9() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoVP9>(),
        236usize,
        concat!("Size of: ", stringify!(VdpPictureInfoVP9))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoVP9>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoVP9))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).lastReference as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(lastReference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).goldenReference as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(goldenReference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).altReference as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(altReference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).colorSpace as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(colorSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).profile as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).frameContextIdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(frameContextIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).keyFrame as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(keyFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).showFrame as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(showFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).errorResilient as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(errorResilient)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).frameParallelDecoding as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(frameParallelDecoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).subSamplingX as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(subSamplingX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).subSamplingY as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(subSamplingY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).intraOnly as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(intraOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).allowHighPrecisionMv as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(allowHighPrecisionMv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).refreshEntropyProbs as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(refreshEntropyProbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).refFrameSignBias as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(refFrameSignBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).bitDepthMinus8Luma as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(bitDepthMinus8Luma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).bitDepthMinus8Chroma as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(bitDepthMinus8Chroma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).loopFilterLevel as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(loopFilterLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).loopFilterSharpness as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(loopFilterSharpness)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).modeRefLfEnabled as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(modeRefLfEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).log2TileColumns as *const _ as usize
        },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(log2TileColumns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).log2TileRows as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(log2TileRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentEnabled as *const _ as usize
        },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentEnabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentMapUpdate as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentMapUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentMapTemporalUpdate as *const _
                as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentMapTemporalUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentFeatureMode as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentFeatureMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentFeatureEnable as *const _ as usize
        },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentFeatureEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentFeatureData as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentFeatureData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mbSegmentTreeProbs as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mbSegmentTreeProbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).segmentPredProbs as *const _ as usize
        },
        163usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(segmentPredProbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).reservedSegment16Bits as *const _ as usize
        },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(reservedSegment16Bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpYAc as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpYAc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpYDc as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpYDc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpChDc as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpChDc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).qpChAc as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(qpChAc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).activeRefIdx as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(activeRefIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).resetFrameContext as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(resetFrameContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mcompFilterType as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mcompFilterType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mbRefLfDelta as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mbRefLfDelta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoVP9>())).mbModeLfDelta as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(mbModeLfDelta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).uncompressedHeaderSize as *const _
                as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(uncompressedHeaderSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoVP9>())).compressedHeaderSize as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoVP9),
            "::",
            stringify!(compressedHeaderSize)
        )
    );
}
#[doc = " \\brief Picture parameter information for an H.265/HEVC picture."]
#[doc = ""]
#[doc = " References to bitsream fields below may refer to data literally parsed from"]
#[doc = " the bitstream, or derived from the bitstream using a mechanism described in"]
#[doc = " Rec. ITU-T H.265 (04/2013), hereafter referred to as \"the H.265/HEVC"]
#[doc = " Specification\"."]
#[doc = ""]
#[doc = " VDPAU H.265/HEVC implementations implement the portion of the decoding"]
#[doc = " process described by clauses 8.4, 8.5, 8.6 and 8.7 of the the"]
#[doc = " H.265/HEVC Specification. VdpPictureInfoHEVC provides enough data"]
#[doc = " to complete this portion of the decoding process, plus additional"]
#[doc = " information not defined in the H.265/HEVC Specification that may be"]
#[doc = " useful to particular implementations."]
#[doc = ""]
#[doc = " Client applications must supply every field in this struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoHEVC {
    #[doc = " \\name HEVC Sequence Parameter Set"]
    #[doc = ""]
    #[doc = " Copies of the HEVC Sequence Parameter Set bitstream fields."]
    #[doc = " @{"]
    pub chroma_format_idc: u8,
    #[doc = " Only valid if chroma_format_idc == 3. Ignored otherwise."]
    pub separate_colour_plane_flag: u8,
    pub pic_width_in_luma_samples: u32,
    pub pic_height_in_luma_samples: u32,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
    #[doc = " Provides the value corresponding to the nuh_temporal_id of the frame"]
    #[doc = "to be decoded."]
    pub sps_max_dec_pic_buffering_minus1: u8,
    pub log2_min_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_luma_coding_block_size: u8,
    pub log2_min_transform_block_size_minus2: u8,
    pub log2_diff_max_min_transform_block_size: u8,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
    pub scaling_list_enabled_flag: u8,
    #[doc = " Scaling lists, in diagonal order, to be used for this frame. */"]
    #[doc = "indexed as ScalingList4x4[matrixId][i]."]
    pub ScalingList4x4: [[u8; 16usize]; 6usize],
    #[doc = " Scaling List for 8x8 quantization matrix,"]
    #[doc = "indexed as ScalingList8x8[matrixId][i]."]
    pub ScalingList8x8: [[u8; 64usize]; 6usize],
    #[doc = " Scaling List for 16x16 quantization matrix,"]
    #[doc = "indexed as ScalingList16x16[matrixId][i]."]
    pub ScalingList16x16: [[u8; 64usize]; 6usize],
    #[doc = " Scaling List for 32x32 quantization matrix,"]
    #[doc = "indexed as ScalingList32x32[matrixId][i]."]
    pub ScalingList32x32: [[u8; 64usize]; 2usize],
    #[doc = " Scaling List DC Coefficients for 16x16,"]
    #[doc = "indexed as ScalingListDCCoeff16x16[matrixId]."]
    pub ScalingListDCCoeff16x16: [u8; 6usize],
    #[doc = " Scaling List DC Coefficients for 32x32,"]
    #[doc = "indexed as ScalingListDCCoeff32x32[matrixId]."]
    pub ScalingListDCCoeff32x32: [u8; 2usize],
    pub amp_enabled_flag: u8,
    pub sample_adaptive_offset_enabled_flag: u8,
    pub pcm_enabled_flag: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub pcm_sample_bit_depth_luma_minus1: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub pcm_sample_bit_depth_chroma_minus1: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub log2_min_pcm_luma_coding_block_size_minus3: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub log2_diff_max_min_pcm_luma_coding_block_size: u8,
    #[doc = " Only needs to be set if pcm_enabled_flag is set. Ignored otherwise."]
    pub pcm_loop_filter_disabled_flag: u8,
    #[doc = " Per spec, when zero, assume short_term_ref_pic_set_sps_flag"]
    #[doc = "is also zero."]
    pub num_short_term_ref_pic_sets: u8,
    pub long_term_ref_pics_present_flag: u8,
    #[doc = " Only needed if long_term_ref_pics_present_flag is set. Ignored"]
    #[doc = "otherwise."]
    pub num_long_term_ref_pics_sps: u8,
    pub sps_temporal_mvp_enabled_flag: u8,
    pub strong_intra_smoothing_enabled_flag: u8,
    #[doc = " \\name HEVC Picture Parameter Set"]
    #[doc = ""]
    #[doc = " Copies of the HEVC Picture Parameter Set bitstream fields."]
    #[doc = " @{"]
    pub dependent_slice_segments_enabled_flag: u8,
    pub output_flag_present_flag: u8,
    pub num_extra_slice_header_bits: u8,
    pub sign_data_hiding_enabled_flag: u8,
    pub cabac_init_present_flag: u8,
    pub num_ref_idx_l0_default_active_minus1: u8,
    pub num_ref_idx_l1_default_active_minus1: u8,
    pub init_qp_minus26: i8,
    pub constrained_intra_pred_flag: u8,
    pub transform_skip_enabled_flag: u8,
    pub cu_qp_delta_enabled_flag: u8,
    #[doc = " Only needed if cu_qp_delta_enabled_flag is set. Ignored otherwise."]
    pub diff_cu_qp_delta_depth: u8,
    pub pps_cb_qp_offset: i8,
    pub pps_cr_qp_offset: i8,
    pub pps_slice_chroma_qp_offsets_present_flag: u8,
    pub weighted_pred_flag: u8,
    pub weighted_bipred_flag: u8,
    pub transquant_bypass_enabled_flag: u8,
    pub tiles_enabled_flag: u8,
    pub entropy_coding_sync_enabled_flag: u8,
    #[doc = " Only valid if tiles_enabled_flag is set. Ignored otherwise."]
    pub num_tile_columns_minus1: u8,
    #[doc = " Only valid if tiles_enabled_flag is set. Ignored otherwise."]
    pub num_tile_rows_minus1: u8,
    #[doc = " Only valid if tiles_enabled_flag is set. Ignored otherwise."]
    pub uniform_spacing_flag: u8,
    #[doc = " Only need to set 0..num_tile_columns_minus1. The struct"]
    #[doc = "definition reserves up to the maximum of 20. Invalid values are"]
    #[doc = "ignored."]
    pub column_width_minus1: [u16; 20usize],
    #[doc = " Only need to set 0..num_tile_rows_minus1. The struct"]
    #[doc = "definition reserves up to the maximum of 22. Invalid values are"]
    #[doc = "ignored."]
    pub row_height_minus1: [u16; 22usize],
    #[doc = " Only needed if tiles_enabled_flag is set. Invalid values are"]
    #[doc = "ignored."]
    pub loop_filter_across_tiles_enabled_flag: u8,
    pub pps_loop_filter_across_slices_enabled_flag: u8,
    pub deblocking_filter_control_present_flag: u8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set. Ignored"]
    #[doc = "otherwise."]
    pub deblocking_filter_override_enabled_flag: u8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set. Ignored"]
    #[doc = "otherwise."]
    pub pps_deblocking_filter_disabled_flag: u8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set and"]
    #[doc = "pps_deblocking_filter_disabled_flag is not set. Ignored otherwise."]
    pub pps_beta_offset_div2: i8,
    #[doc = " Only valid if deblocking_filter_control_present_flag is set and"]
    #[doc = "pps_deblocking_filter_disabled_flag is not set. Ignored otherwise."]
    pub pps_tc_offset_div2: i8,
    pub lists_modification_present_flag: u8,
    pub log2_parallel_merge_level_minus2: u8,
    pub slice_segment_header_extension_present_flag: u8,
    #[doc = " \\name HEVC Slice Segment Header"]
    #[doc = ""]
    #[doc = " Copies of the HEVC Slice Segment Header bitstream fields and calculated"]
    #[doc = " values detailed in the specification."]
    #[doc = " @{ */"]
    #[doc = "Set to zero otherwise."]
    pub IDRPicFlag: u8,
    #[doc = " Set to 1 if nal_unit_type in the range of BLA_W_LP to"]
    #[doc = "RSV_IRAP_VCL23, inclusive. Set to zero otherwise."]
    pub RAPPicFlag: u8,
    #[doc = " See section 7.4.7.1 of the specification."]
    pub CurrRpsIdx: u8,
    #[doc = " See section 7.4.7.2 of the specification."]
    pub NumPocTotalCurr: u32,
    #[doc = " Corresponds to specification field, NumDeltaPocs[RefRpsIdx]."]
    #[doc = "Only applicable when short_term_ref_pic_set_sps_flag == 0."]
    #[doc = "Implementations will ignore this value in other cases. See 7.4.8."]
    pub NumDeltaPocsOfRefRpsIdx: u32,
    #[doc = " Section 7.6.3.1 of the H.265/HEVC Specification defines the syntax of"]
    #[doc = "the slice_segment_header. This header contains information that"]
    #[doc = "some VDPAU implementations may choose to skip. The VDPAU API"]
    #[doc = "requires client applications to track the number of bits used in the"]
    #[doc = "slice header for structures associated with short term and long term"]
    #[doc = "reference pictures. First, VDPAU requires the number of bits used by"]
    #[doc = "the short_term_ref_pic_set array in the slice_segment_header."]
    pub NumShortTermPictureSliceHeaderBits: u32,
    #[doc = " Second, VDPAU requires the number of bits used for long term reference"]
    #[doc = "pictures in the slice_segment_header. This is equal to the number"]
    #[doc = "of bits used for the contents of the block beginning with"]
    #[doc = "\"if(long_term_ref_pics_present_flag)\"."]
    pub NumLongTermPictureSliceHeaderBits: u32,
    #[doc = " Slice Decoding Process - Picture Order Count */"]
    #[doc = "containing the SEI message. The picture being decoded."]
    pub CurrPicOrderCntVal: i32,
    #[doc = " Slice Decoding Process - Reference Picture Sets */"]
    #[doc = "Set any unused positions to VDP_INVALID_HANDLE."]
    pub RefPics: [VdpVideoSurface; 16usize],
    #[doc = " Array of picture order counts. These correspond to positions"]
    #[doc = "in the RefPics array."]
    pub PicOrderCntVal: [i32; 16usize],
    #[doc = " Array used to specify whether a particular RefPic is"]
    #[doc = "a long term reference. A value of \"1\" indicates a long-term"]
    #[doc = "reference."]
    pub IsLongTerm: [u8; 16usize],
    #[doc = " Copy of specification field, see Section 8.3.2 of the"]
    #[doc = "H.265/HEVC Specification."]
    pub NumPocStCurrBefore: u8,
    #[doc = " Copy of specification field, see Section 8.3.2 of the"]
    #[doc = "H.265/HEVC Specification."]
    pub NumPocStCurrAfter: u8,
    #[doc = " Copy of specification field, see Section 8.3.2 of the"]
    #[doc = "H.265/HEVC Specification."]
    pub NumPocLtCurr: u8,
    #[doc = " Reference Picture Set list, one of the short-term RPS. These"]
    #[doc = "correspond to positions in the RefPics array."]
    pub RefPicSetStCurrBefore: [u8; 8usize],
    #[doc = " Reference Picture Set list, one of the short-term RPS. These"]
    #[doc = "correspond to positions in the RefPics array."]
    pub RefPicSetStCurrAfter: [u8; 8usize],
    #[doc = " Reference Picture Set list, one of the long-term RPS. These"]
    #[doc = "correspond to positions in the RefPics array."]
    pub RefPicSetLtCurr: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoHEVC() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoHEVC>(),
        1352usize,
        concat!("Size of: ", stringify!(VdpPictureInfoHEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoHEVC>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoHEVC))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).chroma_format_idc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(chroma_format_idc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).separate_colour_plane_flag as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(separate_colour_plane_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pic_width_in_luma_samples as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pic_width_in_luma_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pic_height_in_luma_samples as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pic_height_in_luma_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).bit_depth_luma_minus8 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(bit_depth_luma_minus8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).bit_depth_chroma_minus8 as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(bit_depth_chroma_minus8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_max_pic_order_cnt_lsb_minus4
                as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_max_pic_order_cnt_lsb_minus4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sps_max_dec_pic_buffering_minus1
                as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sps_max_dec_pic_buffering_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_min_luma_coding_block_size_minus3
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_min_luma_coding_block_size_minus3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_diff_max_min_luma_coding_block_size
                as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_diff_max_min_luma_coding_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_min_transform_block_size_minus2
                as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_min_transform_block_size_minus2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_diff_max_min_transform_block_size
                as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_diff_max_min_transform_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).max_transform_hierarchy_depth_inter
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(max_transform_hierarchy_depth_inter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).max_transform_hierarchy_depth_intra
                as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(max_transform_hierarchy_depth_intra)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).scaling_list_enabled_flag as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(scaling_list_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList4x4 as *const _ as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList4x4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList8x8 as *const _ as usize
        },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList8x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList16x16 as *const _ as usize
        },
        503usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList16x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingList32x32 as *const _ as usize
        },
        887usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingList32x32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingListDCCoeff16x16 as *const _
                as usize
        },
        1015usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingListDCCoeff16x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).ScalingListDCCoeff32x32 as *const _
                as usize
        },
        1021usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(ScalingListDCCoeff32x32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).amp_enabled_flag as *const _ as usize
        },
        1023usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(amp_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sample_adaptive_offset_enabled_flag
                as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sample_adaptive_offset_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_enabled_flag as *const _ as usize
        },
        1025usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_sample_bit_depth_luma_minus1
                as *const _ as usize
        },
        1026usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_sample_bit_depth_luma_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_sample_bit_depth_chroma_minus1
                as *const _ as usize
        },
        1027usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_sample_bit_depth_chroma_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .log2_min_pcm_luma_coding_block_size_minus3 as *const _ as usize
        },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_min_pcm_luma_coding_block_size_minus3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .log2_diff_max_min_pcm_luma_coding_block_size as *const _ as usize
        },
        1029usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_diff_max_min_pcm_luma_coding_block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pcm_loop_filter_disabled_flag as *const _
                as usize
        },
        1030usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pcm_loop_filter_disabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_short_term_ref_pic_sets as *const _
                as usize
        },
        1031usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_short_term_ref_pic_sets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).long_term_ref_pics_present_flag
                as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(long_term_ref_pics_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_long_term_ref_pics_sps as *const _
                as usize
        },
        1033usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_long_term_ref_pics_sps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sps_temporal_mvp_enabled_flag as *const _
                as usize
        },
        1034usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sps_temporal_mvp_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).strong_intra_smoothing_enabled_flag
                as *const _ as usize
        },
        1035usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(strong_intra_smoothing_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).dependent_slice_segments_enabled_flag
                as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(dependent_slice_segments_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).output_flag_present_flag as *const _
                as usize
        },
        1037usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(output_flag_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_extra_slice_header_bits as *const _
                as usize
        },
        1038usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_extra_slice_header_bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).sign_data_hiding_enabled_flag as *const _
                as usize
        },
        1039usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(sign_data_hiding_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).cabac_init_present_flag as *const _
                as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(cabac_init_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_ref_idx_l0_default_active_minus1
                as *const _ as usize
        },
        1041usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_ref_idx_l0_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_ref_idx_l1_default_active_minus1
                as *const _ as usize
        },
        1042usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_ref_idx_l1_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).init_qp_minus26 as *const _ as usize
        },
        1043usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(init_qp_minus26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).constrained_intra_pred_flag as *const _
                as usize
        },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(constrained_intra_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).transform_skip_enabled_flag as *const _
                as usize
        },
        1045usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(transform_skip_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).cu_qp_delta_enabled_flag as *const _
                as usize
        },
        1046usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(cu_qp_delta_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).diff_cu_qp_delta_depth as *const _
                as usize
        },
        1047usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(diff_cu_qp_delta_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_cb_qp_offset as *const _ as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_cb_qp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_cr_qp_offset as *const _ as usize
        },
        1049usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_cr_qp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_slice_chroma_qp_offsets_present_flag
                as *const _ as usize
        },
        1050usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_slice_chroma_qp_offsets_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).weighted_pred_flag as *const _ as usize
        },
        1051usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(weighted_pred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).weighted_bipred_flag as *const _ as usize
        },
        1052usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(weighted_bipred_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).transquant_bypass_enabled_flag
                as *const _ as usize
        },
        1053usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(transquant_bypass_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).tiles_enabled_flag as *const _ as usize
        },
        1054usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(tiles_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).entropy_coding_sync_enabled_flag
                as *const _ as usize
        },
        1055usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(entropy_coding_sync_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_tile_columns_minus1 as *const _
                as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_tile_columns_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).num_tile_rows_minus1 as *const _ as usize
        },
        1057usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(num_tile_rows_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).uniform_spacing_flag as *const _ as usize
        },
        1058usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(uniform_spacing_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).column_width_minus1 as *const _ as usize
        },
        1060usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(column_width_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).row_height_minus1 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(row_height_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).loop_filter_across_tiles_enabled_flag
                as *const _ as usize
        },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(loop_filter_across_tiles_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .pps_loop_filter_across_slices_enabled_flag as *const _ as usize
        },
        1145usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_loop_filter_across_slices_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).deblocking_filter_control_present_flag
                as *const _ as usize
        },
        1146usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(deblocking_filter_control_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).deblocking_filter_override_enabled_flag
                as *const _ as usize
        },
        1147usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(deblocking_filter_override_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_deblocking_filter_disabled_flag
                as *const _ as usize
        },
        1148usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_deblocking_filter_disabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_beta_offset_div2 as *const _ as usize
        },
        1149usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_beta_offset_div2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).pps_tc_offset_div2 as *const _ as usize
        },
        1150usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(pps_tc_offset_div2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).lists_modification_present_flag
                as *const _ as usize
        },
        1151usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(lists_modification_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).log2_parallel_merge_level_minus2
                as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(log2_parallel_merge_level_minus2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>()))
                .slice_segment_header_extension_present_flag as *const _ as usize
        },
        1153usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(slice_segment_header_extension_present_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).IDRPicFlag as *const _ as usize },
        1154usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(IDRPicFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RAPPicFlag as *const _ as usize },
        1155usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RAPPicFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).CurrRpsIdx as *const _ as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(CurrRpsIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocTotalCurr as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocTotalCurr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumDeltaPocsOfRefRpsIdx as *const _
                as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumDeltaPocsOfRefRpsIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumShortTermPictureSliceHeaderBits
                as *const _ as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumShortTermPictureSliceHeaderBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumLongTermPictureSliceHeaderBits
                as *const _ as usize
        },
        1172usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumLongTermPictureSliceHeaderBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).CurrPicOrderCntVal as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(CurrPicOrderCntVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPics as *const _ as usize },
        1180usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).PicOrderCntVal as *const _ as usize
        },
        1244usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(PicOrderCntVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).IsLongTerm as *const _ as usize },
        1308usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(IsLongTerm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocStCurrBefore as *const _ as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocStCurrBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocStCurrAfter as *const _ as usize
        },
        1325usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocStCurrAfter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).NumPocLtCurr as *const _ as usize },
        1326usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(NumPocLtCurr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPicSetStCurrBefore as *const _
                as usize
        },
        1327usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPicSetStCurrBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPicSetStCurrAfter as *const _ as usize
        },
        1335usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPicSetStCurrAfter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC>())).RefPicSetLtCurr as *const _ as usize
        },
        1343usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC),
            "::",
            stringify!(RefPicSetLtCurr)
        )
    );
}
#[doc = " \\brief Picture parameter information for an HEVC 444 picture."]
#[doc = ""]
#[doc = " Note: VDPAU clients must use VdpPictureInfoHEVC444 to describe the"]
#[doc = " attributes of a frame being decoded with"]
#[doc = " VDP_DECODER_PROFILE_HEVC_MAIN_444."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VdpPictureInfoHEVC444 {
    #[doc = " \\ref VdpPictureInfoHEVC struct."]
    pub pictureInfo: VdpPictureInfoHEVC,
    pub sps_range_extension_flag: u8,
    pub transformSkipRotationEnableFlag: u8,
    pub transformSkipContextEnableFlag: u8,
    pub implicitRdpcmEnableFlag: u8,
    pub explicitRdpcmEnableFlag: u8,
    pub extendedPrecisionProcessingFlag: u8,
    pub intraSmoothingDisabledFlag: u8,
    pub highPrecisionOffsetsEnableFlag: u8,
    pub persistentRiceAdaptationEnableFlag: u8,
    pub cabacBypassAlignmentEnableFlag: u8,
    pub intraBlockCopyEnableFlag: u8,
    pub pps_range_extension_flag: u8,
    pub log2MaxTransformSkipSize: u8,
    pub crossComponentPredictionEnableFlag: u8,
    pub chromaQpAdjustmentEnableFlag: u8,
    pub diffCuChromaQpAdjustmentDepth: u8,
    pub chromaQpAdjustmentTableSize: u8,
    pub log2SaoOffsetScaleLuma: u8,
    pub log2SaoOffsetScaleChroma: u8,
    pub cb_qp_adjustment: [i8; 6usize],
    pub cr_qp_adjustment: [i8; 6usize],
}
#[test]
fn bindgen_test_layout_VdpPictureInfoHEVC444() {
    assert_eq!(
        ::std::mem::size_of::<VdpPictureInfoHEVC444>(),
        1384usize,
        concat!("Size of: ", stringify!(VdpPictureInfoHEVC444))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpPictureInfoHEVC444>(),
        4usize,
        concat!("Alignment of ", stringify!(VdpPictureInfoHEVC444))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).pictureInfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(pictureInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).sps_range_extension_flag as *const _
                as usize
        },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(sps_range_extension_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).transformSkipRotationEnableFlag
                as *const _ as usize
        },
        1353usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(transformSkipRotationEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).transformSkipContextEnableFlag
                as *const _ as usize
        },
        1354usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(transformSkipContextEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).implicitRdpcmEnableFlag as *const _
                as usize
        },
        1355usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(implicitRdpcmEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).explicitRdpcmEnableFlag as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(explicitRdpcmEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).extendedPrecisionProcessingFlag
                as *const _ as usize
        },
        1357usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(extendedPrecisionProcessingFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).intraSmoothingDisabledFlag as *const _
                as usize
        },
        1358usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(intraSmoothingDisabledFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).highPrecisionOffsetsEnableFlag
                as *const _ as usize
        },
        1359usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(highPrecisionOffsetsEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).persistentRiceAdaptationEnableFlag
                as *const _ as usize
        },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(persistentRiceAdaptationEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).cabacBypassAlignmentEnableFlag
                as *const _ as usize
        },
        1361usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(cabacBypassAlignmentEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).intraBlockCopyEnableFlag as *const _
                as usize
        },
        1362usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(intraBlockCopyEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).pps_range_extension_flag as *const _
                as usize
        },
        1363usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(pps_range_extension_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).log2MaxTransformSkipSize as *const _
                as usize
        },
        1364usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(log2MaxTransformSkipSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).crossComponentPredictionEnableFlag
                as *const _ as usize
        },
        1365usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(crossComponentPredictionEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).chromaQpAdjustmentEnableFlag
                as *const _ as usize
        },
        1366usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(chromaQpAdjustmentEnableFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).diffCuChromaQpAdjustmentDepth
                as *const _ as usize
        },
        1367usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(diffCuChromaQpAdjustmentDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).chromaQpAdjustmentTableSize
                as *const _ as usize
        },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(chromaQpAdjustmentTableSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).log2SaoOffsetScaleLuma as *const _
                as usize
        },
        1369usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(log2SaoOffsetScaleLuma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).log2SaoOffsetScaleChroma as *const _
                as usize
        },
        1370usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(log2SaoOffsetScaleChroma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).cb_qp_adjustment as *const _ as usize
        },
        1371usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(cb_qp_adjustment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VdpPictureInfoHEVC444>())).cr_qp_adjustment as *const _ as usize
        },
        1377usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpPictureInfoHEVC444),
            "::",
            stringify!(cr_qp_adjustment)
        )
    );
}
#[doc = " \\brief Picture parameter information for HEVC FormatRangeExtensions picture."]
#[doc = ""]
#[doc = " HEVC Main 444 Profile is part of Format Range Extensions profiles,"]
#[doc = " Due to similarities between Format Range Extensions profiles, the picture"]
#[doc = " parameter structure is re-used for Format Range Extensions profiles"]
#[doc = " supported."]
pub type VdpPictureInfoHEVCRangeExt = VdpPictureInfoHEVC444;
#[doc = " \\brief Decode a compressed field/frame and render the result"]
#[doc = "        into a \\ref VdpVideoSurface \"VdpVideoSurface\"."]
#[doc = " \\param[in] decoder The decoder object that will perform the"]
#[doc = "       decode operation."]
#[doc = " \\param[in] target The video surface to render to."]
#[doc = " \\param[in] picture_info A (pointer to a) structure containing"]
#[doc = "       information about the picture to be decoded. Note that"]
#[doc = "       the appropriate type of VdpPictureInfo* structure must"]
#[doc = "       be provided to match to profile that the decoder was"]
#[doc = "       created for."]
#[doc = " \\param[in] bitstream_buffer_count The number of bitstream"]
#[doc = "       buffers containing compressed data for this picture."]
#[doc = " \\param[in] bitstream_buffers An array of bitstream buffers."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " See \\ref video_mixer_usage for additional information."]
pub type VdpDecoderRender = ::std::option::Option<
    unsafe extern "C" fn(
        decoder: VdpDecoder,
        target: VdpVideoSurface,
        picture_info: *const VdpPictureInfo,
        bitstream_buffer_count: u32,
        bitstream_buffers: *const VdpBitstreamBuffer,
    ) -> VdpStatus,
>;
#[doc = " \\brief A VdpVideoMixer feature that must be requested at"]
#[doc = "        creation time to be used."]
#[doc = ""]
#[doc = " Certain advanced VdpVideoMixer features are optional, and the"]
#[doc = " ability to use those features at all must be requested when"]
#[doc = " the VdpVideoMixer object is created. Each feature is named via"]
#[doc = " a specific VdpVideoMixerFeature value."]
#[doc = ""]
#[doc = " Once requested, these features are permanently available"]
#[doc = " within that specific VdpVideoMixer object. All features that"]
#[doc = " are not explicitly requested at creation time default to"]
#[doc = " being permanently unavailable."]
#[doc = ""]
#[doc = " Even when requested, all features default to being initially"]
#[doc = " disabled. However, applications can subsequently enable and"]
#[doc = " disable features at any time. See \\ref"]
#[doc = " VdpVideoMixerSetFeatureEnables."]
#[doc = ""]
#[doc = " Some features allow configuration of their operation. Each"]
#[doc = " configurable item is an \\ref VdpVideoMixerAttribute. These"]
#[doc = " attributes may be manipulated at any time using \\ref"]
#[doc = " VdpVideoMixerSetAttributeValues."]
pub type VdpVideoMixerFeature = u32;
#[doc = " \\brief A VdpVideoMixer creation parameter."]
#[doc = ""]
#[doc = " When a VdpVideoMixer is created, certain parameters may be"]
#[doc = " supplied. Each parameter is named via a specific"]
#[doc = " VdpVideoMixerParameter value."]
#[doc = ""]
#[doc = " Each parameter has a specific type, and specific default"]
#[doc = " value if not specified at VdpVideoMixer creation time. The"]
#[doc = " application may query the legal supported range for some"]
#[doc = " parameters."]
pub type VdpVideoMixerParameter = u32;
#[doc = " \\brief An adjustable attribute of VdpVideoMixer operation."]
#[doc = ""]
#[doc = " Various attributes of VdpVideoMixer operation may be adjusted"]
#[doc = " at any time. Each attribute is named via a specific"]
#[doc = " VdpVideoMixerAttribute value."]
#[doc = ""]
#[doc = " Each attribute has a specific type, and specific default"]
#[doc = " value if not specified at VdpVideoMixer creation time. The"]
#[doc = " application may query the legal supported range for some"]
#[doc = " attributes."]
pub type VdpVideoMixerAttribute = u32;
#[doc = " \\brief Query the implementation's support for a specific"]
#[doc = "        feature."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] feature The feature for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] is_supported Is the specified feature supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryFeatureSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        feature: VdpVideoMixerFeature,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's support for a specific"]
#[doc = "        parameter."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] parameter The parameter for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] is_supported Is the specified parameter"]
#[doc = "       supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryParameterSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        parameter: VdpVideoMixerParameter,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's support for a specific"]
#[doc = "        attribute."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] feature The feature for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] is_supported Is the specified feature supported?"]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryAttributeSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        attribute: VdpVideoMixerAttribute,
        is_supported: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's supported for a specific"]
#[doc = "        parameter."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] parameter The parameter for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] min_value The minimum supported value."]
#[doc = " \\param[out] max_value The maximum supported value."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryParameterValueRange = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        parameter: VdpVideoMixerParameter,
        min_value: *mut ::std::os::raw::c_void,
        max_value: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Query the implementation's supported for a specific"]
#[doc = "        attribute."]
#[doc = " \\param[in] device The device to query."]
#[doc = " \\param[in] attribute The attribute for which support is to be"]
#[doc = "       queried."]
#[doc = " \\param[out] min_value The minimum supported value."]
#[doc = " \\param[out] max_value The maximum supported value."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerQueryAttributeValueRange = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        attribute: VdpVideoMixerAttribute,
        min_value: *mut ::std::os::raw::c_void,
        max_value: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a VdpVideoMixer object."]
pub type VdpVideoMixer = u32;
#[doc = " \\brief Create a VdpVideoMixer."]
#[doc = " \\param[in] device The device that will contain the mixer."]
#[doc = " \\param[in] feature_count The number of features to request."]
#[doc = " \\param[in] features The list of features to request."]
#[doc = " \\param[in] parameter_count The number of parameters to set."]
#[doc = " \\param[in] parameters The list of parameters to set."]
#[doc = " \\param[in] parameter_values The values for the parameters. Note that each"]
#[doc = "     entry in the value array is a pointer to the actual value. In other"]
#[doc = "     words, the values themselves are not cast to \"void *\" and passed"]
#[doc = "     \"inside\" the array."]
#[doc = " \\param[out] mixer The new mixer's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Initially, all requested features will be disabled. They can"]
#[doc = " be enabled using \\ref VdpVideoMixerSetFeatureEnables."]
#[doc = ""]
#[doc = " Initially, all attributes will have default values. Values"]
#[doc = " can be changed using \\ref VdpVideoMixerSetAttributeValues."]
pub type VdpVideoMixerCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        parameter_count: u32,
        parameters: *const VdpVideoMixerParameter,
        parameter_values: *const *const ::std::os::raw::c_void,
        mixer: *mut VdpVideoMixer,
    ) -> VdpStatus,
>;
#[doc = " \\brief Enable or disable features."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] feature_count The number of features to"]
#[doc = "       enable/disable."]
#[doc = " \\param[in] features The list of features to enable/disable."]
#[doc = " \\param[in] feature_enables The list of new feature enable"]
#[doc = "       values."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerSetFeatureEnables = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        feature_enables: *const VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Set attribute values"]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] attribute_count The number of attributes to set."]
#[doc = " \\param[in] attributes The list of attributes to set."]
#[doc = " \\param[in] attribute_values The values for the attributes. Note that each"]
#[doc = "     entry in the value array is a pointer to the actual value. In other"]
#[doc = "     words, the values themselves are not cast to \"void *\" and passed"]
#[doc = "     \"inside\" the array. A NULL pointer requests that the default value be"]
#[doc = "     set for that attribute."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerSetAttributeValues = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        attribute_count: u32,
        attributes: *const VdpVideoMixerAttribute,
        attribute_values: *const *const ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve whether features were requested at creation"]
#[doc = "        time."]
#[doc = " \\param[in] mixer The mixer to query."]
#[doc = " \\param[in] feature_count The number of features to query."]
#[doc = " \\param[in] features The list of features to query."]
#[doc = " \\param[out] feature_supported A list of values indicating"]
#[doc = "       whether the feature was requested, and hence is"]
#[doc = "       available."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetFeatureSupport = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        feature_supports: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve whether features are enabled."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] feature_count The number of features to query."]
#[doc = " \\param[in] features The list of features to query."]
#[doc = " \\param[out] feature_enabled A list of values indicating"]
#[doc = "       whether the feature is enabled."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetFeatureEnables = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        feature_count: u32,
        features: *const VdpVideoMixerFeature,
        feature_enables: *mut VdpBool,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve parameter values given at creation time."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] parameter_count The number of parameters to query."]
#[doc = " \\param[in] parameters The list of parameters to query."]
#[doc = " \\param[out] parameter_values The list of current values for"]
#[doc = "     the parameters. Note that each entry in the value array is a pointer to"]
#[doc = "     storage that will receive the actual value. If the attribute's type is"]
#[doc = "     a pointer itself, please closely read the documentation for that"]
#[doc = "     attribute type for any other data passing requirements."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetParameterValues = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        parameter_count: u32,
        parameters: *const VdpVideoMixerParameter,
        parameter_values: *const *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve current attribute values."]
#[doc = " \\param[in] mixer The mixer to manipulate."]
#[doc = " \\param[in] attribute_count The number of attributes to query."]
#[doc = " \\param[in] attributes The list of attributes to query."]
#[doc = " \\param[out] attribute_values The list of current values for"]
#[doc = "     the attributes. Note that each entry in the value array is a pointer to"]
#[doc = "     storage that will receive the actual value. If the attribute's type is"]
#[doc = "     a pointer itself, please closely read the documentation for that"]
#[doc = "     attribute type for any other data passing requirements."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerGetAttributeValues = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        attribute_count: u32,
        attributes: *const VdpVideoMixerAttribute,
        attribute_values: *const *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpVideoMixer."]
#[doc = " \\param[in] device The device to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpVideoMixerDestroy =
    ::std::option::Option<unsafe extern "C" fn(mixer: VdpVideoMixer) -> VdpStatus>;
#[doc = " The picture is a field, and is the top field of the surface."]
pub const VdpVideoMixerPictureStructure_VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD:
    VdpVideoMixerPictureStructure = 0;
#[doc = " The picture is a field, and is the bottom field of the"]
#[doc = " surface."]
pub const VdpVideoMixerPictureStructure_VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD:
    VdpVideoMixerPictureStructure = 1;
#[doc = " The picture is a frame, and hence is the entire surface."]
pub const VdpVideoMixerPictureStructure_VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME:
    VdpVideoMixerPictureStructure = 2;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The structure of the picture present in a \\ref"]
#[doc = "        VdpVideoSurface \"VdpVideoSurface\"."]
pub type VdpVideoMixerPictureStructure = u32;
#[doc = " \\brief Definition of an additional \\ref VdpOutputSurface"]
#[doc = "        \"VdpOutputSurface\" layer in the composting model."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VdpLayer {
    #[doc = " This field must be filled with VDP_LAYER_VERSION"]
    pub struct_version: u32,
    #[doc = " The surface to composite from."]
    pub source_surface: VdpOutputSurface,
    #[doc = " The sub-rectangle of the source surface to use. If NULL, the"]
    #[doc = " entire source surface will be used."]
    pub source_rect: *const VdpRect,
    #[doc = " The sub-rectangle of the destination surface to map"]
    #[doc = " this layer into. This rectangle is relative to the entire"]
    #[doc = " destination surface. This rectangle will be clipped by \\ref"]
    #[doc = " VdpVideoMixerRender's \\b destination_rect. If NULL, the"]
    #[doc = " destination rectangle will be sized to match the source"]
    #[doc = " rectangle, and will be located at the origin."]
    pub destination_rect: *const VdpRect,
}
#[test]
fn bindgen_test_layout_VdpLayer() {
    assert_eq!(
        ::std::mem::size_of::<VdpLayer>(),
        24usize,
        concat!("Size of: ", stringify!(VdpLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<VdpLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(VdpLayer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).struct_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).source_surface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(source_surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).source_rect as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(source_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VdpLayer>())).destination_rect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VdpLayer),
            "::",
            stringify!(destination_rect)
        )
    );
}
#[doc = " \\brief Perform a video post-processing and compositing"]
#[doc = "        operation."]
#[doc = " \\param[in] mixer The mixer object that will perform the"]
#[doc = "       mixing/rendering operation."]
#[doc = " \\param[in] background_surface A background image. If set to any value other"]
#[doc = "       than VDP_INVALID_HANDLE, the specific surface will be used instead of"]
#[doc = "       the background color as the first layer in the mixer's compositing"]
#[doc = "       process."]
#[doc = " \\param[in] background_source_rect When background_surface is specified,"]
#[doc = "       this parameter indicates the portion of background_surface that will"]
#[doc = "       be used as the background layer. The specified region will be"]
#[doc = "       extracted and scaled to match the size of destination_rect. If NULL,"]
#[doc = "       the entire background_surface will be used."]
#[doc = " \\param[in] current_picture_structure The picture structure of"]
#[doc = "       the field/frame to be processed. This field/frame is"]
#[doc = "       presented in the \\b video_surface_current parameter. If"]
#[doc = "       frame, then all \\b video_surface_* parameters are"]
#[doc = "       assumed to be frames. If field, then all"]
#[doc = "       video_surface_* parameters are assumed to be fields,"]
#[doc = "       with alternating top/bottom-ness derived from"]
#[doc = "       video_surface_current."]
#[doc = " \\param[in] video_surfaces_past_count The number of provided"]
#[doc = "       fields/frames prior to the current picture."]
#[doc = " \\param[in] video_surfaces_past The fields/frames prior to the"]
#[doc = "       current field/frame. Note that array index 0 is the"]
#[doc = "       field/frame temporally nearest to the current"]
#[doc = "       field/frame, with increasing array indices used for"]
#[doc = "       older frames. Unavailable entries may be set to"]
#[doc = "       \\ref VDP_INVALID_HANDLE."]
#[doc = " \\param[in] video_surface_current The field/frame to be"]
#[doc = "       processed."]
#[doc = " \\param[in] video_surfaces_future_count The number of provided"]
#[doc = "       fields/frames following the current picture."]
#[doc = " \\param[in] video_surfaces_future The fields/frames that"]
#[doc = "       follow the current field/frame. Note that array index 0"]
#[doc = "       is the field/frame temporally nearest to the current"]
#[doc = "       field/frame, with increasing array indices used for"]
#[doc = "       newer frames. Unavailable entries may be set to \\ref"]
#[doc = "       VDP_INVALID_HANDLE."]
#[doc = " \\param[in] video_source_rect The sub-rectangle of the source"]
#[doc = "       video surface to extract and process. If NULL, the"]
#[doc = "       entire surface will be used. Left/right and/or top/bottom"]
#[doc = "       co-ordinates may be swapped to flip the source. Values"]
#[doc = "       from outside the video surface are valid and samples"]
#[doc = "       at those locations will be taken from the nearest edge."]
#[doc = " \\param[in] destination_surface"]
#[doc = " \\param[in] destination_rect The sub-rectangle of the"]
#[doc = "       destination surface to modify. Note that rectangle clips"]
#[doc = "       all other actions."]
#[doc = " \\param[in] destination_video_rect The sub-rectangle of the"]
#[doc = "       destination surface that will contain the processed"]
#[doc = "       video. This rectangle is relative to the entire"]
#[doc = "       destination surface. This rectangle is clipped by \\b"]
#[doc = "       destination_rect. If NULL, the destination rectangle"]
#[doc = "       will be sized to match the source rectangle, and will"]
#[doc = "       be located at the origin."]
#[doc = " \\param[in] layer_count The number of additional layers to"]
#[doc = "       composite above the video."]
#[doc = " \\param[in] layers The array of additional layers to composite"]
#[doc = "       above the video."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " For a complete discussion of how to use this API, please see"]
#[doc = " \\ref video_mixer_usage."]
pub type VdpVideoMixerRender = ::std::option::Option<
    unsafe extern "C" fn(
        mixer: VdpVideoMixer,
        background_surface: VdpOutputSurface,
        background_source_rect: *const VdpRect,
        current_picture_structure: VdpVideoMixerPictureStructure,
        video_surface_past_count: u32,
        video_surface_past: *const VdpVideoSurface,
        video_surface_current: VdpVideoSurface,
        video_surface_future_count: u32,
        video_surface_future: *const VdpVideoSurface,
        video_source_rect: *const VdpRect,
        destination_surface: VdpOutputSurface,
        destination_rect: *const VdpRect,
        destination_video_rect: *const VdpRect,
        layer_count: u32,
        layers: *const VdpLayer,
    ) -> VdpStatus,
>;
#[doc = " \\brief The representation of a point in time."]
#[doc = ""]
#[doc = " VdpTime timestamps are intended to be a high-precision timing"]
#[doc = " system, potentially independent from any other time domain in"]
#[doc = " the system."]
#[doc = ""]
#[doc = " Time is represented in units of nanoseconds. The origin"]
#[doc = " (i.e. the time represented by a value of 0) is implementation"]
#[doc = " dependent."]
pub type VdpTime = u64;
#[doc = " \\brief An opaque handle representing the location where"]
#[doc = "        video will be presented."]
#[doc = ""]
#[doc = " VdpPresentationQueueTarget are created using a \\ref api_winsys"]
#[doc = " specific API, such as \\ref"]
#[doc = " VdpPresentationQueueTargetCreateX11."]
pub type VdpPresentationQueueTarget = u32;
#[doc = " \\brief Destroy a VdpPresentationQueueTarget."]
#[doc = " \\param[in] presentation_queue_target The target to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueTargetDestroy = ::std::option::Option<
    unsafe extern "C" fn(presentation_queue_target: VdpPresentationQueueTarget) -> VdpStatus,
>;
#[doc = " \\brief An opaque handle representing a presentation queue"]
#[doc = "        object."]
pub type VdpPresentationQueue = u32;
#[doc = " \\brief Create a VdpPresentationQueue."]
#[doc = " \\param[in] device The device that will contain the queue."]
#[doc = " \\param[in] presentation_queue_target The location to display"]
#[doc = "       the content."]
#[doc = " \\param[out] presentation_queue The new queue's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Note: The initial value for the background color will be set to"]
#[doc = " an implementation-defined value."]
pub type VdpPresentationQueueCreate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        presentation_queue_target: VdpPresentationQueueTarget,
        presentation_queue: *mut VdpPresentationQueue,
    ) -> VdpStatus,
>;
#[doc = " \\brief Destroy a VdpPresentationQueue."]
#[doc = " \\param[in] presentation_queue The queue to destroy."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueDestroy = ::std::option::Option<
    unsafe extern "C" fn(presentation_queue: VdpPresentationQueue) -> VdpStatus,
>;
#[doc = " \\brief Configure the background color setting."]
#[doc = " \\param[in] presentation_queue The queue to manipulate."]
#[doc = " \\param[in] background_color The new background color."]
#[doc = ""]
#[doc = " Note: Implementations may choose whether to apply the"]
#[doc = " new background color value immediately, or defer it until"]
#[doc = " the next surface is presented."]
pub type VdpPresentationQueueSetBackgroundColor = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        background_color: *mut VdpColor,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve the current background color setting."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[out] background_color The current background color."]
pub type VdpPresentationQueueGetBackgroundColor = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        background_color: *mut VdpColor,
    ) -> VdpStatus,
>;
#[doc = " \\brief Retrieve the presentation queue's \"current\" time."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[out] current_time The current time, which may"]
#[doc = "       represent a point between display VSYNC events."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueGetTime = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        current_time: *mut VdpTime,
    ) -> VdpStatus,
>;
#[doc = " \\brief Enter a surface into the presentation queue."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[in] surface The surface to enter into the queue."]
#[doc = " \\param[in] clip_width If set to a non-zero value, the presentation queue"]
#[doc = "       will display only clip_width pixels of the surface (anchored to the"]
#[doc = "       top-left corner of the surface."]
#[doc = " \\param[in] clip_height If set to a non-zero value, the presentation queue"]
#[doc = "       will display only clip_height lines of the surface (anchored to the"]
#[doc = "       top-left corner of the surface."]
#[doc = " \\param[in] earliest_presentation_time The timestamp"]
#[doc = "       associated with the surface. The presentation queue"]
#[doc = "       will not display the surface until the presentation"]
#[doc = "       queue's current time is at least this value."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Applications may choose to allow resizing of the presentation queue target"]
#[doc = " (which may be e.g. a regular Window when using an X11-based"]
#[doc = " implementation)."]
#[doc = ""]
#[doc = " \\b clip_width and \\b clip_height may be used to limit the size of the"]
#[doc = " displayed region of a surface, in order to match the specific region that"]
#[doc = " was rendered to."]
#[doc = ""]
#[doc = " In turn, this allows the application to allocate over-sized (e.g."]
#[doc = " screen-sized) surfaces, but render to a region that matches the current"]
#[doc = " size of the video window."]
#[doc = ""]
#[doc = " Using this technique, an application's response to window resizing may"]
#[doc = " simply be to render to, and display, a different region of the surface,"]
#[doc = " rather than de-/re-allocation of surfaces to match the updated window size."]
#[doc = ""]
#[doc = " Implementations may impose an upper bound on the number of entries"]
#[doc = " contained by the presentation queue at a given time. This limit is likely"]
#[doc = " different to the number of \\ref VdpOutputSurface \"VdpOutputSurface\"s that"]
#[doc = " may be allocated at a given time. This limit applies to entries in the"]
#[doc = " QUEUED or VISIBLE state only. In other words, entries that have"]
#[doc = " transitioned from a QUEUED or VISIBLE state to an IDLE state do not count"]
#[doc = " toward this limit."]
pub type VdpPresentationQueueDisplay = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        surface: VdpOutputSurface,
        clip_width: u32,
        clip_height: u32,
        earliest_presentation_time: VdpTime,
    ) -> VdpStatus,
>;
#[doc = " \\brief Wait for a surface to finish being displayed."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[in] surface The surface to wait for."]
#[doc = " \\param[out] first_presentation_time The timestamp of the"]
#[doc = "       VSYNC at which this surface was first displayed. Note"]
#[doc = "       that 0 means the surface was never displayed."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Note that this API would block forever if queried about the surface most"]
#[doc = " recently added to a presentation queue. That is because there would be no"]
#[doc = " other surface that could possibly replace that surface as the currently"]
#[doc = " displayed surface, and hence that surface would never become idle. For"]
#[doc = " that reason, this function will return an error in that case."]
pub type VdpPresentationQueueBlockUntilSurfaceIdle = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        surface: VdpOutputSurface,
        first_presentation_time: *mut VdpTime,
    ) -> VdpStatus,
>;
#[doc = " The surface is not queued or currently visible."]
pub const VdpPresentationQueueStatus_VDP_PRESENTATION_QUEUE_STATUS_IDLE:
    VdpPresentationQueueStatus = 0;
#[doc = " The surface is in the queue, and not currently visible."]
pub const VdpPresentationQueueStatus_VDP_PRESENTATION_QUEUE_STATUS_QUEUED:
    VdpPresentationQueueStatus = 1;
#[doc = " The surface is the currently visible surface."]
pub const VdpPresentationQueueStatus_VDP_PRESENTATION_QUEUE_STATUS_VISIBLE:
    VdpPresentationQueueStatus = 2;
#[doc = " \\hideinitializer"]
#[doc = " \\brief The status of a surface within a presentation queue."]
pub type VdpPresentationQueueStatus = u32;
#[doc = " \\brief Poll the current queue status of a surface."]
#[doc = " \\param[in] presentation_queue The queue to query."]
#[doc = " \\param[in] surface The surface to query."]
#[doc = " \\param[out] status The current status of the surface within"]
#[doc = "       the queue."]
#[doc = " \\param[out] first_presentation_time The timestamp of the"]
#[doc = "       VSYNC at which this surface was first displayed. Note"]
#[doc = "       that 0 means the surface was never displayed."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPresentationQueueQuerySurfaceStatus = ::std::option::Option<
    unsafe extern "C" fn(
        presentation_queue: VdpPresentationQueue,
        surface: VdpOutputSurface,
        status: *mut VdpPresentationQueueStatus,
        first_presentation_time: *mut VdpTime,
    ) -> VdpStatus,
>;
#[doc = " \\brief A callback to notify the client application that a"]
#[doc = "        device's display has been preempted."]
#[doc = " \\param[in] device The device that had its display preempted."]
#[doc = " \\param[in] context The client-supplied callback context"]
#[doc = "       information."]
#[doc = " \\return void No return value"]
pub type VdpPreemptionCallback = ::std::option::Option<
    unsafe extern "C" fn(device: VdpDevice, context: *mut ::std::os::raw::c_void),
>;
#[doc = " \\brief Configure the display preemption callback."]
#[doc = " \\param[in] device The device to be monitored for preemption."]
#[doc = " \\param[in] callback The client application's callback"]
#[doc = "       function. If NULL, the callback is unregistered."]
#[doc = " \\param[in] context The client-supplied callback context"]
#[doc = "       information. This information will be passed to the"]
#[doc = "       callback function if/when invoked."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpPreemptionCallbackRegister = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        callback: VdpPreemptionCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief A type suitable for \\ref VdpGetProcAddress"]
#[doc = "        \"VdpGetProcAddress\"'s \\b function_id parameter."]
pub type VdpFuncId = u32;
#[doc = " \\brief Retrieve a VDPAU function pointer."]
#[doc = " \\param[in] device The device that the function will operate"]
#[doc = "       against."]
#[doc = " \\param[in] function_id The specific function to retrieve."]
#[doc = " \\param[out] function_pointer The actual pointer for the"]
#[doc = "       application to call."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpGetProcAddress = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        function_id: VdpFuncId,
        function_pointer: *mut *mut ::std::os::raw::c_void,
    ) -> VdpStatus,
>;
#[doc = " \\brief Create a VdpDevice object for use with X11."]
#[doc = " \\param[in] display The X Display that the VdpDevice VdpDevice"]
#[doc = "       will operate against."]
#[doc = " \\param[in] screen The X screen that the VdpDevice will operate"]
#[doc = "       against."]
#[doc = " \\param[out] device The new device's handle."]
#[doc = " \\param[out] get_proc_address The get_proc_address entry point"]
#[doc = "       to use with this device."]
#[doc = " \\return VdpStatus The completion status of the operation."]
pub type VdpDeviceCreateX11 = ::std::option::Option<
    unsafe extern "C" fn(
        display: *mut Display,
        screen: ::std::os::raw::c_int,
        device: *mut VdpDevice,
        get_proc_address: *mut VdpGetProcAddress,
    ) -> VdpStatus,
>;
extern "C" {
    #[doc = " \\brief Create a VdpDevice object for use with X11."]
    #[doc = " This is an actual symbol of type \\ref VdpDeviceCreateX11"]
    #[doc = ""]
    pub fn vdp_device_create_x11(
        display: *mut Display,
        screen: ::std::os::raw::c_int,
        device: *mut VdpDevice,
        get_proc_address: *mut VdpGetProcAddress,
    ) -> VdpStatus;
}
#[doc = " \\brief Create a VdpPresentationQueueTarget for use with X11."]
#[doc = " \\param[in] device The device that will contain the queue"]
#[doc = "       target."]
#[doc = " \\param[in] drawable The X11 Drawable that the presentation"]
#[doc = "       queue will present into."]
#[doc = " \\param[out] target The new queue target's handle."]
#[doc = " \\return VdpStatus The completion status of the operation."]
#[doc = ""]
#[doc = " Note: VDPAU expects to own the entire drawable for the duration of time"]
#[doc = " that the presentation queue target exists. In particular,"]
#[doc = " implementations may choose to manipulate client-visible X11 window state"]
#[doc = " as required. As such, it is recommended that applications create a"]
#[doc = " dedicated window for the presentation queue target, as a child"]
#[doc = " (grand-child, ...) of their top-level application window."]
#[doc = ""]
#[doc = " Applications may also create child-windows of the presentation queue"]
#[doc = " target, which will cover any presented video in the normal fashion. VDPAU"]
#[doc = " implementations will not manipulate such child windows in any fashion."]
pub type VdpPresentationQueueTargetCreateX11 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VdpDevice,
        drawable: Drawable,
        target: *mut VdpPresentationQueueTarget,
    ) -> VdpStatus,
>;
